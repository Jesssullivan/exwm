# EXWM-VR: 20-Week Implementation Plan (Expanded)

## VR-First Transhuman Emacs Window Manager

**Target Platforms:** NixOS, Rocky Linux 9/10 (x86_64, aarch64, s390x headless, riscv64 aspirational)
**Core Stack:** Smithay (Rust compositor) + Emacs (pgtk) + Monado (OpenXR) + XELB fork
**Primary Eye Tracking:** Pupil Labs (Core/Neon) via ZMQ, OpenXR XR_EXT_eye_gaze_interaction
**Primary BCI:** OpenBCI (Cyton 8ch / Cyton+Daisy 16ch) via BrainFlow
**Key Integrations:** KeePassXC, Qutebrowser, WayVR, Stardust XR
**Aspirational HMDs:** Somnium VR1, Pimax Crystal SLAM, Beyond 2E (moving targets)
**IPC:** S-expression over Unix domain socket
**Rendering:** GLES2 (2D flat), Vulkan (VR stereoscopic), DMA-BUF zero-copy texture import

---

## Architecture Overview

```
+=======================+
|     Emacs (pgtk)      |  User's primary interface
|  ewwm.el (WM logic)  |  Elisp layout/workspace/keybind management
+-----------+-----------+
            |
    Unix socket IPC (s-expression / msgpack)
            |
+-----------v-----------+
|  VR Compositor (Rust) |  Built on Smithay
|  +-- Wayland Server   |  xdg-shell, layer-shell, foreign-toplevel
|  +-- DRM Lease        |  wp_drm_lease_v1 for VR headset
|  +-- OpenXR Bridge    |  Monado for eye/hand tracking
|  +-- Input Manager    |  libinput + gaze virtual device
|  +-- Renderer         |  GLES2 (2D), Vulkan (VR passthrough)
|  +-- IPC Server       |  Emacs communication channel
+-----------+-----------+
            |
    DRM/KMS | OpenXR/Monado
            |
+-----------v-----------+
|   GPU + VR Hardware   |
+=======================+
```

---

## Phase 0: Foundation (Weeks 1-3)

### Week 1: Repository Setup & Architecture Validation

**Goal:** Clean project scaffold with Nix flake, justfile task runner, git-cliff changelog, pre-commit hooks, ERT test harness, CI pipeline; validated Smithay hello-compositor; comprehensive EXWM module analysis (12 modules, 9363 lines) to inform Week 2 refactoring plan

**Dependencies:** None (project inception)

| Stage | Task | Agents | Gate |
|-------|------|--------|------|
| 1.1 | **Nix flake with full dependency closure.** Create `flake.nix` with inputs: `nixpkgs` (unstable for latest Smithay deps), `emacs-overlay` (emacs-pgtk with native-comp), `rust-overlay` (nightly Rust for Smithay), `flake-utils`. Outputs: `devShells.default` providing Rust toolchain (nightly, components: `rustc`, `cargo`, `clippy`, `rustfmt`, `rust-analyzer`), Emacs 30.x pgtk with XELB + compat packages, Wayland development libraries (`wayland`, `wayland-protocols`, `libdrm`, `mesa`, `libinput`, `libxkbcommon`, `seatd`), Monado OpenXR runtime, BrainFlow Python environment (deferred, placeholder). `devShell` sets environment variables: `LD_LIBRARY_PATH` for Wayland libs, `LIBCLANG_PATH` for Rust bindgen, `PKG_CONFIG_PATH` for cross-platform builds. Add `cachix` input pointing to `exwm-vr` cache (empty initially, populated in Week 15). Nix formatting: use `nixpkgs-fmt`. Add `.envrc` with `use flake` for direnv integration. Pin Nixpkgs to specific commit for reproducibility. | 2 | GO: `nix develop` drops into shell with `rustc --version`, `emacs --version`, `pkg-config --list-all | grep wayland` all succeeding |
| 1.2 | **Justfile with recipe groups.** Create `justfile` with recipe groups: `[build]` group: `build` (byte-compile all .el files), `build-compositor` (placeholder `cargo build` for Week 3), `build-all` (both). `[test]` group: `test` (run ERT suite via `emacs --batch`), `test-compositor` (placeholder `cargo test`), `test-integration` (placeholder). `[lint]` group: `lint-elisp` (byte-compile warnings + `package-lint` + `checkdoc`), `lint-rust` (placeholder `cargo clippy`), `lint-all`. `[vr]` group: `vr-mock` (placeholder: launch compositor with Monado headless), `vr-test` (placeholder: VR integration test). `[dev]` group: `dev` (launch Emacs with load-path set), `clean` (remove .elc files, target/), `changelog` (run `git-cliff`). `[ci]` group: `ci` (runs lint-all, build-all, test). All recipes use absolute paths and work from any working directory. Include `set dotenv-load` for `.env` overrides. | 1 | GO: `just build` byte-compiles all 12 .el files without error; `just test` invokes ERT |
| 1.3 | **Git-cliff changelog configuration.** Create `cliff.toml` for conventional commit changelog generation. Configuration: `[changelog]` header = "# Changelog\n", body template with grouped commits by type (feat, fix, refactor, test, docs, ci, chore). `[git]` conventional_commits = true, filter_unconventional = true, commit_parsers mapping: `feat` -> "Features", `fix` -> "Bug Fixes", `refactor` -> "Refactoring", `test` -> "Testing", `docs` -> "Documentation", `ci` -> "CI/CD", `chore` -> "Miscellaneous". Tag pattern = "v[0-9]*". Sort commits by oldest. Link to GitHub compare URLs for tag ranges. Add `just changelog` recipe: `git-cliff --output CHANGELOG.md`. Add `just changelog-unreleased`: `git-cliff --unreleased`. Validate with `git-cliff --validate` in CI. | 1 | GO: `just changelog` generates valid CHANGELOG.md; `git-cliff --validate cliff.toml` passes |
| 1.4 | **Pre-commit hooks and editor configuration.** Create `.githooks/pre-commit` with checks: (a) byte-compile all modified .el files -- `emacs --batch -f batch-byte-compile $MODIFIED_EL_FILES`, fail on warnings. (b) Secrets detection: scan staged files for patterns matching API keys, passwords, private keys (`grep -rn 'PRIVATE KEY\|password\s*=\|api_key\|secret_key'`). (c) Trailing whitespace removal check. (d) No large binary files (> 1MB). Create `.githooks/commit-msg` enforcing conventional commit format via regex: `^(feat|fix|refactor|test|docs|ci|chore|perf|style|build)(\(.+\))?!?:\s.+`. Error message shows expected format. Create `.editorconfig`: root = true, default indent = 2 spaces, .el files use Emacs default (spaces), .rs files use 4 spaces, .nix files use 2 spaces, .toml/.yml use 2 spaces. Create `.dir-locals.el` setting `(indent-tabs-mode . nil)`, `(fill-column . 80)`, `(sentence-end-double-space . t)` for Elisp convention. Create `.gitattributes` with `*.el diff=lisp`, `*.rs diff=rust`. Configure git to use hooks dir: document `git config core.hooksPath .githooks` in README. | 1 | GO: pre-commit hook catches a staged file with `password = "test"`; commit-msg rejects `wip: stuff` |
| 1.5 | **ERT test harness and initial test suite.** Create `test/run-tests.el`: set `load-path` to include project root, require all exwm modules, load all test files matching `test/*-test.el`, invoke `(ert-run-tests-batch-and-exit)`. Create `test/exwm-core-test.el` with initial tests: (a) `exwm--id-buffer-alist` is initially nil. (b) `exwm-mode` derives from `special-mode`. (c) `exwm-class-name` buffer-local variable exists. (d) `exwm-title` buffer-local variable exists. (e) `exwm-debug--backtrace` macro expands correctly. (f) `exwm--log` produces output when debug enabled. (g) `exwm-mode-map` is a valid keymap. (h) `exwm-reset` is a valid interactive command. (i) `exwm-mode` buffer is read-only. (j) `exwm--id-buffer-alist` add/remove operations work. Create `test/exwm-input-test.el` with 3 tests: key simulation utilities exist, `exwm-input--global-keys` is a list, `exwm-input-set-key` is interactive. Create `test/exwm-workspace-test.el` with 2 tests: `exwm-workspace-number` defcustom exists with default value, `exwm-workspace-list` function exists. Total: >= 15 initial tests. Justfile `test` recipe: `emacs --batch -l test/run-tests.el`. | 2 | GO: `just test` passes with >= 15 ERT tests; all tests exercise actual EXWM module code |
| 1.6 | **EXWM codebase deep analysis.** Perform systematic analysis of all 12 EXWM modules (9363 total lines): `exwm-core.el` (463 lines -- core variables: `exwm--connection`, `exwm--id-buffer-alist`, `exwm--root`; XELB/xcb dependency), `exwm-workspace.el` (1763 lines -- workspace management, frame manipulation, 8 refs to `exwm--id-buffer-alist`), `exwm-input.el` (1215 lines -- key handling, line-mode/char-mode, global keys, simulation keys), `exwm.el` (1303 lines -- init, WM acquisition, client message dispatch, requires all core modules), `exwm-manage.el` (833 lines -- window lifecycle: manage/unmanage, PropertyNotify, 8 refs to `exwm--id-buffer-alist`), `exwm-floating.el` (760 lines -- floating window mode, reparenting, 2 refs to `exwm--id-buffer-alist`), `exwm-layout.el` (663 lines -- window geometry, show/hide, 3 refs to `exwm--id-buffer-alist`), `exwm-xim.el` (793 lines -- X Input Method), `exwm-systemtray.el` (701 lines -- system tray via freedesktop spec), `exwm-randr.el` (339 lines -- multi-monitor via RandR), `exwm-xsettings.el` (325 lines -- XSETTINGS protocol), `exwm-background.el` (205 lines -- root background). Document: inter-module dependency graph (all modules require `exwm-core`, `exwm-randr` and `exwm-systemtray` also require `exwm-workspace`, `exwm-xim` requires `exwm-input`). Identify X11-only code paths vs portable logic. Produce `docs/exwm-analysis.org` with per-module summary, dependency edges, and keep/transform/drop recommendation for each. | 2 | GO: analysis document covers all 12 modules with function counts, dependency edges, and Wayland portability assessment |
| 1.7 | **GitHub Actions CI pipeline.** Create `.github/workflows/ci.yml` with jobs: (a) `byte-compile`: runs on `ubuntu-latest`, installs Emacs 30.x pgtk via Nix (`nix develop --command just build`), fails on any byte-compile warning. (b) `ert-test`: runs on `ubuntu-latest`, `nix develop --command just test`, requires all tests pass. (c) `lint`: `nix develop --command just lint-elisp`. (d) `nix-build`: `nix build .#devShells.x86_64-linux.default`, verifies flake evaluates without error; `nix flake check`. (e) `changelog-validate`: `nix develop --command git-cliff --validate cliff.toml`. Cache: Nix store via `DeterminateSystems/nix-installer-action` and `DeterminateSystems/magic-nix-cache-action`. Trigger: push to `main`, push to `dev`, all pull requests. Timeout: 15 minutes per job. Concurrency: cancel in-progress for same branch. | 1 | GO: CI pipeline green on push to `main`; all 5 jobs pass |
| 1.8 | **Project scaffolding files.** Create `.gitignore`: `*.elc`, `target/`, `result`, `.direnv/`, `.envrc.local`, `*.so`, `*.dylib`, `__pycache__/`, `.cache/`, `CHANGELOG.md` (generated). Create `LICENSE` (already exists, verify GPL-3.0+). Create initial `docs/` directory with `docs/exwm-analysis.org` (from 1.6) and `docs/architecture.org` (placeholder referencing PLAN.md architecture diagram). Create `compositor/` directory with placeholder `compositor/README.md` noting Rust crate created in Week 3. Verify `.gitattributes` handles line endings correctly for cross-platform contributors. | 1 | GO: `git status` clean after committing scaffold; directory structure matches plan |
| 1.9 | **Smithay "hello compositor" spike.** In a temporary directory (not committed to main repo), create minimal Rust project depending on `smithay 0.3` (or latest). Implement: (a) `calloop::EventLoop` creation with 1-second tick timer. (b) Smithay `Winit` backend initialization (window-based, for development). (c) Basic `WlCompositor` global registration. (d) Basic `XdgShell` global registration. (e) Event loop: drain Wayland socket, process libinput events (none in Winit mode), render empty scene (clear to black via GLES2). (f) Measure: event loop iteration time, memory usage at idle. Deliverable: written findings document with Smithay API surface assessment, calloop integration patterns, and specific Smithay version recommendation for production use. Reference anvil (Smithay example compositor) and niri (production Smithay compositor) for patterns. | 2 | GO: hello compositor opens a window, accepts `WAYLAND_DISPLAY` connections, renders black; findings documented |
| 1.10 | **Emacs pgtk under headless Wayland validation.** Test Emacs 30.x pgtk build under: (a) `cage` (single-window Wayland compositor, ideal for testing). (b) `weston --backend=headless` (headless Wayland compositor). (c) Smithay Winit backend from 1.9 (if functional). Validation criteria: Emacs launches without errors, `(display-graphic-p)` returns `t`, `(frame-parameter nil 'display)` returns Wayland display, basic Elisp evaluation works, `M-x` opens minibuffer, buffer switching works, ERT tests pass in graphical mode. Document any pgtk regressions or incompatibilities. Test with both Emacs 29.x and 30.x. Record GDK_BACKEND=wayland behavior. If pgtk fails, test XWayland fallback path. | 1 | GO: Emacs pgtk launches under at least one headless Wayland compositor; all basic operations work |
| 1.11 | **ewx (Emacs Wayland compositor PoC) evaluation.** Clone and build `ewx` project (Emacs Wayland compositor proof-of-concept). Evaluate: (a) IPC mechanism used (socket type, protocol format, message types). (b) Surface-to-buffer mapping approach. (c) Input handling architecture. (d) What worked and what was abandoned/incomplete. (e) Applicable patterns for our architecture. (f) Key differences from our planned approach (ewx embeds compositor in Emacs process vs our separate-process architecture). Document findings in `docs/ewx-evaluation.org`. Extract any reusable Elisp patterns for IPC or surface management. | 1 | GO: evaluation document complete with >= 5 actionable findings for our architecture |
| 1.12 | **Integration tests for Week 1 deliverables.** Verify all deliverables compose correctly: (a) `nix develop --command just ci` runs full CI locally. (b) Pre-commit hook fires on `git commit`. (c) Commit-msg hook validates conventional commits. (d) `git-cliff` produces correct output from initial commits. (e) ERT tests load all EXWM modules without error. (f) `.dir-locals.el` applies correctly in Emacs. Write meta-test: `test/week1-integration-test.el` that verifies test harness itself works (can load modules, can define tests, can run them). Target: >= 3 new integration tests. | 1 | GO: `just ci` passes locally AND in GitHub Actions; >= 18 total ERT tests |

**Research (parallel):**
- R1.1: **Smithay API surface audit.** Catalog all Smithay traits relevant to compositor implementation: `CompositorHandler`, `ShmHandler`, `SeatHandler`, `KeyboardHandler`, `PointerHandler`, `DataDeviceHandler`, `XdgShellHandler`, `DmabufHandler`, `DrmHandler`, `InputHandler`. For each trait: document required methods, callback signatures, typical implementation pattern from anvil and niri. Assess API stability: check Smithay git history for breaking changes in last 6 months. Document in `docs/research/smithay-api-audit.md`. (2 agents)
- R1.2: **Emacs pgtk Wayland capabilities survey.** Test which Wayland protocols Emacs pgtk (via GDK4) supports: `xdg-shell`, `xdg-decoration`, `wl_data_device` (clipboard), `zwp_text_input_v3` (input method), `org_kde_kwin_server_decoration`. Test clipboard integration: `kill-ring` <-> Wayland clipboard. Test drag-and-drop. Document pgtk limitations vs X11 EXWM features. (1 agent)
- R1.3: **Evaluate ewx and other Emacs-Wayland projects.** In addition to ewx, survey: `emacs-wl-compositor` (if exists), any Guile-based Wayland compositor projects, and Way-cooler (Rust+Lua WM, discontinued but informative). Extract lessons learned from each. (1 agent)
- R1.4: **Niri architecture study.** niri is the most successful Smithay-based compositor. Study its: event loop structure, state management pattern, `calloop` source registration, IPC mechanism (niri-ipc crate), configuration system, DRM backend initialization sequence. Extract patterns directly applicable to our compositor. Document niri Nix packaging approach (`niri-flake`) for Week 15 reference. (1 agent)

**Completion Metrics:**
- [ ] `nix develop` drops into functional development shell on x86_64-linux
- [ ] `nix flake check` passes with no evaluation errors
- [ ] All justfile recipes execute without error (`just build`, `just test`, `just lint-elisp`, `just changelog`, `just ci`)
- [ ] Pre-commit hooks catch byte-compile warnings and secrets patterns
- [ ] Commit-msg hook enforces conventional commit format
- [ ] `git-cliff` generates valid CHANGELOG.md from initial commits
- [ ] ERT test suite has >= 18 passing tests across exwm-core, exwm-input, exwm-workspace
- [ ] CI pipeline green on GitHub Actions (all 5 jobs)
- [ ] EXWM module analysis document covers all 12 modules with dependency graph
- [ ] Smithay hello compositor renders black screen and accepts Wayland connections
- [ ] Emacs pgtk validated under headless Wayland compositor
- [ ] ewx evaluation document complete with actionable findings
- [ ] Niri architecture patterns documented for compositor reference

**Gate: GO/NOGO/ASK**
- GO if all metrics met: flake works, CI green, tests pass, Smithay spike successful, pgtk validated
- ASK if flake.nix fails on aarch64 (defer cross-compilation to Week 16, proceed with x86_64 only)
- ASK if Smithay API has had major breaking changes in last 3 months (evaluate pinning strategy vs tracking upstream)
- NOGO if Emacs pgtk cannot run under ANY headless Wayland compositor (fundamental blocker for development workflow)
- NOGO if Smithay calloop event loop cannot maintain < 16ms iteration time in hello compositor (performance ceiling too low)

**Risk Table:**

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Nix flake evaluation failure on emacs-overlay | Low | Medium | Pin emacs-overlay to known-good commit; test with both emacs29-pgtk and emacs30-pgtk |
| Smithay version incompatibility with niri patterns | Medium | Low | Pin Smithay to same version niri uses; both track Smithay closely |
| Pre-commit hooks slow down development | Low | Low | Add `--no-verify` escape hatch documentation; hooks complete in < 5s |
| EXWM byte-compilation requires XELB at compile time | Certain | Low | Include XELB in devShell; document dependency |

**Composability Notes:**
- Flake.nix foundation extended in every subsequent week (compositor package in Week 3, NixOS module in Week 15, multi-arch in Week 16)
- Justfile recipe groups grow weekly; `just ci` always runs the full current test suite
- ERT test harness from 1.5 is the foundation for all future test stages (target: 150+ tests by Week 20)
- EXWM module analysis (1.6) directly informs Week 2 keep/transform/drop decisions
- Smithay spike (1.9) de-risks Week 3 compositor scaffold

**Parallelism Opportunities:**
- Stages 1.1 (flake) and 1.2 (justfile) and 1.3 (git-cliff) are fully independent
- Stages 1.4 (hooks) and 1.5 (ERT) are independent
- Stages 1.6 (analysis) and 1.7 (CI) are independent
- Stages 1.9 (Smithay spike) and 1.10 (pgtk validation) and 1.11 (ewx eval) are independent research-like tasks
- All 4 research agents run in parallel with build stages

**Integration Points:**
- Week 2: EXWM analysis (1.6) feeds directly into module reorganization decisions
- Week 3: Smithay spike (1.9) findings inform compositor scaffold architecture
- Week 4: IPC patterns from ewx evaluation (1.11) inform protocol design
- Week 5: ERT test harness (1.5) extended for ewwm.el module tests
- Week 15: flake.nix (1.1) extended into full NixOS module; niri patterns (R1.4) inform packaging

---

### Week 2: EXWM Codebase Reorganization

**Goal:** Construct complete module dependency graph from Week 1 analysis; classify each of 12 EXWM modules as keep/transform/drop for Wayland migration; restructure directory layout into lisp/core/, lisp/vr/, lisp/ext/; create VR stub modules; build comprehensive test harness validating that X11 functionality remains unbroken; extract portable Elisp patterns from X11-coupled modules

**Dependencies:** Week 1 (EXWM module analysis, ERT harness, flake.nix)

| Stage | Task | Agents | Gate |
|-------|------|--------|------|
| 2.1 | **Module dependency graph construction.** From Week 1 analysis (stage 1.6), produce a formal dependency graph in DOT format (`docs/module-dependencies.dot`). Nodes: all 12 EXWM modules. Edges: `require` relationships. Known graph: `exwm-core.el` is root (required by all 11 others). `exwm.el` requires `exwm-core`, `exwm-workspace`, `exwm-layout`, `exwm-floating`, `exwm-manage`, `exwm-input` (6 direct deps). `exwm-randr.el` requires `exwm-core`, `exwm-workspace`. `exwm-systemtray.el` requires `exwm-core`, `exwm-workspace`. `exwm-xim.el` requires `exwm-core`, `exwm-input`. All others require only `exwm-core`. Annotate edges with coupling type: "require only" (clean), "shared variable" (exwm--id-buffer-alist has 28 refs across 7 files), "shared hook" (exwm-manage hooks called from exwm.el), "XELB/xcb dependency" (hard X11 coupling). Generate SVG via `dot -Tsvg`. Identify: strongly connected components, critical path through dependency chain, modules that can be loaded independently. | 1 | GO: dependency graph SVG generated; all edges verified against actual `require` statements and shared variable references |
| 2.2 | **Module classification: keep/transform/drop.** Based on dependency graph and Wayland portability analysis, classify each module. **Keep as-is** (X11 backward compat, no changes needed for Wayland track): `exwm-core.el` (core data structures, partially portable), `exwm.el` (init orchestrator). **Transform** (extract portable logic, create Wayland-compatible sibling): `exwm-workspace.el` (1763 lines -- workspace logic is portable, frame manipulation is X11-specific; extract `ewwm-workspace.el`), `exwm-input.el` (1215 lines -- key binding dispatch is portable, X11 grab mechanism is not; extract `ewwm-input.el`), `exwm-layout.el` (663 lines -- tiling logic is portable, X11 geometry management is not; extract `ewwm-layout.el`), `exwm-manage.el` (833 lines -- window lifecycle concepts are portable, X11 PropertyNotify/MapRequest are not; extract `ewwm-manage.el`), `exwm-floating.el` (760 lines -- floating window model is portable, X11 reparenting is not; extract `ewwm-floating.el`). **Drop for Wayland** (X11-only, no Wayland equivalent needed): `exwm-xim.el` (X Input Method -- Wayland has `zwp_text_input_v3`), `exwm-systemtray.el` (X11 system tray -- Wayland uses `wlr-foreign-toplevel` or `ext-session-lock`), `exwm-xsettings.el` (XSETTINGS is X11-only), `exwm-background.el` (root window background -- Wayland has no root window). `exwm-randr.el` (339 lines -- RandR is X11; Wayland uses `wl_output` and `xdg-output`; drop but note output management still needed). Document rationale for each classification in `docs/module-classification.md`. | 2 | GO: classification document complete with rationale; all 12 modules categorized; 5 transform candidates identified |
| 2.3 | **Directory restructure: lisp/core/.** Create `lisp/core/` directory. Move all 12 existing .el files into `lisp/core/`. Update `justfile` `build` recipe to byte-compile from `lisp/core/`. Update `test/run-tests.el` to add `lisp/core/` to `load-path`. Critical: verify that all `require` statements still resolve correctly after move -- XELB packages (`xcb`, `xcb-icccm`, `xcb-ewmh`, `xcb-debug`, `xcb-randr`, `xcb-xim`, `xcb-systemtray`) must still be findable via Nix-provided load-path. Run full ERT test suite. Verify byte-compilation produces .elc files in `lisp/core/`. Git move (not copy+delete) to preserve history: `git mv exwm-core.el lisp/core/exwm-core.el` for each file. | 1 | GO: `just build` byte-compiles all 12 .el files from lisp/core/ without warning; `just test` passes all existing tests |
| 2.4 | **Directory restructure: lisp/vr/ with stub modules.** Create `lisp/vr/` directory. Create stub modules that byte-compile cleanly and define the public API surface for the Wayland/VR track: (a) `ewwm-core.el` -- `(defvar ewwm--surface-buffer-alist nil "Alist of (<Wayland surface ID> . <Emacs buffer>).")` (analogous to `exwm--id-buffer-alist`), `(defvar ewwm--compositor-process nil)`, `(defvar ewwm--ipc-connection nil)`, `(defun ewwm--surface-buffer (id) "Get buffer for surface ID.")`, `(defun ewwm--buffer-surface (buffer) "Get surface ID for buffer.")`. (b) `ewwm-workspace.el` -- `(defcustom ewwm-workspace-number 4)`, `(defun ewwm-workspace-switch (index))`. (c) `ewwm-layout.el` -- `(defcustom ewwm-layout-default 'tiling)`, `(defun ewwm-layout-set (layout))`. (d) `ewwm-input.el` -- `(defvar ewwm-input-global-keys nil)`, `(defun ewwm-input-set-key (key cmd))`. (e) `ewwm-manage.el` -- `(defun ewwm-manage--on-surface-create (surface-id))`, `(defun ewwm-manage--on-surface-destroy (surface-id))`. (f) `ewwm-floating.el` -- `(defun ewwm-floating-toggle (surface-id))`. (g) `ewwm-ipc.el` -- IPC client stub: `(defun ewwm-ipc-connect ())`, `(defun ewwm-ipc-send (msg))`, `(defun ewwm-ipc-disconnect ())`. (h) `exwm-vr.el` -- VR mode entry point: `(defun exwm-vr-mode ())`. (i) `exwm-vr-eye.el` -- eye tracking stub. (j) `exwm-vr-input.el` -- VR input stub. All stubs require `cl-lib` only (no XELB dependency). Each stub includes `provide` form. | 2 | GO: `just build` byte-compiles all stubs in lisp/vr/ without warning; stubs define documented public API |
| 2.5 | **Directory restructure: lisp/ext/ with extension framework.** Create `lisp/ext/` directory. Create `exwm-ext.el` implementing a lightweight extension loading framework. API: `(exwm-ext-register NAME &key init-fn enable-fn disable-fn deps)` -- registers an extension with lifecycle hooks. `(exwm-ext-enable NAME)` -- calls init-fn then enable-fn. `(exwm-ext-disable NAME)` -- calls disable-fn. `(exwm-ext-list)` -- returns list of registered extensions. `(defcustom exwm-ext-enabled-list nil "List of extension names to auto-enable on startup.")`. Dependency resolution: if extension A depends on B, enabling A first enables B. Circular dependency detection. Error handling: if extension init fails, log warning and continue. This framework allows Week 13+ features (wink, gaze zones, BCI) to be loaded as optional extensions. Create example extension `exwm-ext-template.el` demonstrating the API. | 1 | GO: `(exwm-ext-register 'test :init-fn #'ignore :enable-fn #'ignore)` works; dependency resolution handles A->B chain |
| 2.6 | **Source directory for native modules.** Create `src/` directory. Create `src/README.md` documenting: native module compilation approach (Emacs dynamic modules via `emacs-module.h`), Rust FFI via `emacs-module-rs` crate (evaluated, not yet used), C hello-world module for validation. Create `src/hello-module.c`: minimal Emacs dynamic module that defines function `(hello-module-greet)` returning "Hello from native module". Create `src/Makefile` (or integrate into justfile): `gcc -shared -o hello-module.so -I${EMACS_INCLUDE} hello-module.c`. Test: `(require 'hello-module)` then `(hello-module-greet)` returns expected string. This validates the native module pipeline for potential future use (e.g., performance-critical IPC encoding, GPU texture handle passing). Note: Week 4 IPC will likely use pure Elisp `make-network-process` instead of native modules. | 1 | GO: `(require 'hello-module)` loads; `(hello-module-greet)` returns "Hello from native module" |
| 2.7 | **Update all load-path references.** After directory restructure, update: (a) `test/run-tests.el` -- add `lisp/core/`, `lisp/vr/`, `lisp/ext/` to `load-path`. (b) `justfile` `build` recipe -- byte-compile from all three directories. (c) `.github/workflows/ci.yml` -- ensure CI uses updated paths. (d) `.dir-locals.el` -- set `eval` form to add directories to `load-path` for interactive development. (e) `flake.nix` `devShell` -- set `EMACSLOADPATH` to include all directories. (f) Verify no hardcoded paths remain in any .el file (grep for `load-file`, `load`, `add-to-list.*load-path`). Run full ERT suite to validate. | 1 | GO: `just test` passes all tests; `just build` compiles all directories; no hardcoded paths remain |
| 2.8 | **Portable logic extraction analysis.** For each "transform" module identified in 2.2, perform detailed analysis of which functions are portable vs X11-coupled. Produce per-module extraction plan: (a) `exwm-workspace.el` (1763 lines): portable functions -- workspace list management, workspace switching logic, frame-workspace mapping concepts; X11-coupled -- `xcb:ConfigureWindow`, `xcb:MapWindow`, `xcb:UnmapWindow`, frame geometry via X11 root window. Estimated portable: ~40%. (b) `exwm-input.el` (1215 lines): portable -- key binding dispatch, `exwm-input-set-key` logic, simulation key mapping; X11-coupled -- `xcb:GrabKey`, `xcb:AllowEvents`, X11 key event translation. Estimated portable: ~35%. (c) `exwm-manage.el` (833 lines): portable -- buffer creation on window manage, buffer cleanup on unmanage, class/title tracking; X11-coupled -- `xcb:MapRequest`, `xcb:PropertyNotify`, ICCCM/EWMH property reading. Estimated portable: ~30%. (d) `exwm-layout.el` (663 lines): portable -- tiling algorithm, layout switching logic; X11-coupled -- `xcb:ConfigureWindow` for geometry. Estimated portable: ~45%. (e) `exwm-floating.el` (760 lines): portable -- floating toggle concept, position tracking; X11-coupled -- reparenting via `xcb:ReparentWindow`. Estimated portable: ~25%. Document in `docs/extraction-plan.md` with per-function classifications. | 2 | GO: extraction plan covers all 5 transform modules with per-function portable/X11-coupled classification |
| 2.9 | **exwm--id-buffer-alist portability shim.** `exwm--id-buffer-alist` is the central data structure (28 references across 7 files) mapping X11 window IDs to Emacs buffers. Create `ewwm-core.el` counterpart `ewwm--surface-buffer-alist` (started in 2.4) with identical API semantics but using Wayland surface IDs (integers from compositor IPC) instead of X11 window IDs (xcb:WINDOW atoms). Define shared interface functions in `ewwm-core.el`: `(ewwm--get-buffer id)` = `(alist-get id ewwm--surface-buffer-alist)`, `(ewwm--set-buffer id buffer)` = `(setf (alist-get id ewwm--surface-buffer-alist) buffer)`, `(ewwm--remove-buffer id)` = `(setf (alist-get id ewwm--surface-buffer-alist nil 'remove) nil)`, `(ewwm--all-surfaces)` = returns list of all surface IDs, `(ewwm--all-buffers)` = returns list of all managed buffers. Write ERT tests for each operation: add, get, remove, list, empty-state. This is the foundation for Week 5's surface-as-buffer model. | 1 | GO: all `ewwm--surface-buffer-alist` operations tested; API mirrors `exwm--id-buffer-alist` semantics |
| 2.10 | **Comprehensive test harness expansion.** Expand ERT suite to cover reorganized codebase: (a) `test/exwm-core-test.el` -- add tests for buffer-local variables (`exwm-class-name`, `exwm-instance-name`, `exwm-title`, `exwm-window-type`, `exwm--frame`, `exwm-state`). (b) `test/ewwm-core-test.el` -- test `ewwm--surface-buffer-alist` CRUD operations, test `ewwm-core.el` stub loads without XELB. (c) `test/ewwm-ipc-test.el` -- test IPC stub function signatures exist. (d) `test/exwm-ext-test.el` -- test extension registration, enable/disable lifecycle, dependency resolution, circular dependency detection. (e) `test/directory-structure-test.el` -- verify expected files exist in lisp/core/, lisp/vr/, lisp/ext/ (regression test against accidental moves). Target: >= 30 cumulative ERT tests. Run all tests both in batch mode (`emacs --batch`) and verify they can also run interactively. | 2 | GO: `just test` passes >= 30 ERT tests; tests cover both lisp/core/ (EXWM) and lisp/vr/ (ewwm stubs) |
| 2.11 | **Smithay anvil deep-dive.** Systematically study the anvil reference compositor (ships with Smithay source). Extract: (a) State management pattern (`AnvilState<BackendData>` struct holding all compositor state). (b) Handler trait implementations (which traits anvil implements, typical method bodies). (c) Event loop source registration pattern (how anvil registers Wayland socket, DRM, libinput as calloop sources). (d) Rendering pipeline (how anvil composites surfaces to output). (e) Input handling (how anvil routes keyboard/pointer events to surfaces). (f) Multi-output support (how anvil handles multiple DRM outputs). Produce `docs/research/anvil-patterns.md` with code snippets from anvil annotated with our adaptation notes. Identify: minimum set of handler traits for a functional compositor. | 2 | GO: anvil patterns document covers state management, event loop, rendering, input routing with adaptation notes |

**Research (parallel):**
- R2.1: **Smithay anvil minimal viable compositor extraction.** From the anvil deep-dive (stage 2.11), produce a minimal trait implementation checklist: which `CompositorHandler`, `ShmHandler`, `SeatHandler`, `XdgShellHandler` methods are truly required vs optional for a basic compositor. Determine if anvil's `AnvilState` pattern can be simplified for our initial scaffold. (2 agents)
- R2.2: **Niri-flake NixOS packaging patterns.** Analyze niri-flake repository: Nix derivation structure, binary cache configuration, NixOS module options, systemd service files, environment variable propagation, display manager integration. Extract patterns directly applicable to our Week 15 NixOS module. (1 agent)
- R2.3: **Emacs-zmq evaluation for Pupil Labs IPC.** Build and test `emacs-zmq` package (Emacs dynamic module providing ZeroMQ bindings). Verify: package compiles under Nix, `zmq-socket` creation works, PUB/SUB pattern works, measure message latency. Assess whether emacs-zmq is viable for Week 11 Pupil Labs eye tracker integration (subscriber to gaze data stream). Alternative: communicate via compositor (Rust ZMQ client) relayed over our Unix socket IPC. (1 agent)
- R2.4: **EXWM community survey for migration concerns.** Review GitHub issues, wiki, and emacs-devel mailing list for user requests related to Wayland migration. Identify: most-requested Wayland features, concerns about X11 backward compatibility, extensions/configurations that would break with directory restructure. Inform our keep/transform/drop decisions. (1 agent)

**Completion Metrics:**
- [ ] All existing EXWM X11 functionality unchanged (full ERT suite passes after restructure)
- [ ] `just build` byte-compiles lisp/core/ (12 files), lisp/vr/ (10 stubs), lisp/ext/ (2 files) without warnings
- [ ] `just test` passes with >= 30 cumulative ERT tests
- [ ] Directory structure: lisp/core/, lisp/vr/, lisp/ext/, src/, test/, docs/ all present
- [ ] Module dependency graph SVG generated from DOT source
- [ ] Module classification document (keep/transform/drop) covers all 12 modules
- [ ] Portable logic extraction plan covers all 5 transform-candidate modules
- [ ] `ewwm--surface-buffer-alist` CRUD operations tested and working
- [ ] Extension framework registers, enables, and disables extensions with dependency resolution
- [ ] Native module pipeline validated with hello-module.c
- [ ] Anvil patterns document complete with adaptation notes
- [ ] No hardcoded load-path references remain in any .el file

**Gate: GO/NOGO/ASK**
- GO if all existing EXWM tests pass after restructure AND >= 30 tests AND classification document approved
- ASK if byte-compilation of interdependent modules fails after move (may need `eval-when-compile` adjustments for XELB requires)
- ASK if community survey reveals strong objections to directory restructure (consider compatibility shims)
- NOGO if restructure breaks byte-compilation in a way that cannot be resolved by load-path adjustments (would need to reconsider directory layout)

**Risk Table:**

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Moving .el files breaks `require` chains | Medium | High | Use `git mv`, update all load-paths, run full test suite before commit |
| XELB packages not found after restructure | Medium | Medium | Verify Nix devShell includes XELB in EMACSLOADPATH; add explicit `(add-to-list 'load-path ...)` in test harness |
| VR stub module names conflict with future packages | Low | Low | Prefix all Wayland modules with `ewwm-` (Emacs Wayland Window Manager) to avoid namespace collision |
| Extension framework over-engineering | Low | Low | Keep minimal: register/enable/disable only; no autoload magic |
| Community objects to directory restructure | Low | Medium | Maintain backward-compat `require` shims at old paths for one release cycle |

**Composability Notes:**
- Directory structure established here is permanent: all future modules land in lisp/vr/ (Wayland/VR) or lisp/ext/ (extensions)
- `ewwm--surface-buffer-alist` (2.9) is the central data structure consumed by Weeks 5, 6, 10, 12, 13, 14, 17
- Extension framework (2.5) enables optional loading of Week 13+ features (wink, gaze zones, BCI, KeePassXC)
- Module classification (2.2) directly drives Week 5 implementation priorities
- Test harness growth: 18 (Week 1) -> 30 (Week 2) -> 40 (Week 3 target)

**Parallelism Opportunities:**
- Stages 2.1 (dep graph) and 2.2 (classification) can start simultaneously but 2.2 consumes 2.1 output
- Stages 2.3 (lisp/core/) and 2.4 (lisp/vr/) and 2.5 (lisp/ext/) are independent directory operations
- Stage 2.6 (src/) is independent of all lisp restructuring
- Stages 2.8 (extraction analysis) and 2.9 (portability shim) can parallelize
- Stage 2.11 (anvil deep-dive) is independent research
- All 4 research agents run in parallel with build stages

**Integration Points:**
- Week 1: EXWM analysis (1.6) and Smithay spike (1.9) consumed as inputs
- Week 3: anvil patterns (2.11) directly inform compositor scaffold; native module pipeline (2.6) available if needed
- Week 4: IPC stub (2.4 ewwm-ipc.el) fleshed out with real protocol implementation
- Week 5: ewwm stubs (2.4) become real implementations; extraction plan (2.8) guides porting
- Week 13+: extension framework (2.5) loads optional features

---

### Week 3: Smithay Compositor Scaffold

**Goal:** Production-quality Smithay compositor crate with calloop event loop, DRM/libinput backends, Winit development backend, headless CI backend; implements wl_compositor, wl_shm, xdg_shell, wl_seat (keyboard + pointer); Wayland clients can connect, render surfaces, receive input; niri used as primary reference architecture; compositor integrated into flake.nix as buildable package

**Dependencies:** Week 1 (flake.nix, Smithay spike), Week 2 (anvil patterns analysis, directory structure)

| Stage | Task | Agents | Gate |
|-------|------|--------|------|
| 3.1 | **Rust crate scaffold.** Create `compositor/` directory with `Cargo.toml`. Dependencies: `smithay = { git = "https://github.com/Smithay/smithay", features = ["backend_drm", "backend_libinput", "backend_winit", "backend_session_libseat", "renderer_gles2", "xwayland", "wayland_frontend"] }`, `calloop = "0.13"` (event loop), `tracing = "0.1"` + `tracing-subscriber` (structured logging), `serde = { version = "1", features = ["derive"] }` + `serde-lexpr = "0.1"` (s-expression IPC encoding for Week 4), `thiserror` (error types), `bitflags` (state flags), `xkbcommon` (keyboard layout). Crate structure: `src/main.rs` (entry point, arg parsing), `src/state.rs` (compositor state struct), `src/backend/mod.rs` + `drm.rs` + `winit.rs` + `headless.rs` (backend implementations), `src/handlers/mod.rs` + `compositor.rs` + `xdg_shell.rs` + `seat.rs` + `shm.rs` (Wayland protocol handlers), `src/input.rs` (input routing), `src/render.rs` (rendering pipeline). Pin Smithay to specific git commit matching niri's proven version. Add `rust-toolchain.toml` specifying nightly channel (required by some Smithay features). | 2 | GO: `cargo build` succeeds; `cargo clippy` reports no errors; crate structure matches plan |
| 3.2 | **Compositor state struct following niri pattern.** Implement `EwwmState` struct (named after our project, analogous to niri's `Niri` struct and anvil's `AnvilState`). Fields: `display: wayland_server::Display<EwwmState>` (Wayland display), `loop_handle: calloop::LoopHandle<'static, EwwmState>` (event loop handle), `compositor_state: smithay::wayland::compositor::CompositorState` (compositor global), `xdg_shell_state: smithay::wayland::shell::xdg::XdgShellState` (xdg-shell global), `shm_state: smithay::wayland::shm::ShmState` (shared memory global), `seat_state: smithay::input::SeatHandler` (input seat), `seat: smithay::input::Seat<EwwmState>` (the seat), `output_state: smithay::wayland::output::OutputManagerState`, `surfaces: Vec<SurfaceData>` (tracked surfaces), `space: smithay::desktop::Space<Window>` (surface layout manager from smithay::desktop). Implement `SurfaceData` struct: `surface_id: u64` (unique monotonic ID), `toplevel: ToplevelSurface`, `app_id: Option<String>`, `title: Option<String>`, `geometry: Rectangle<i32, Logical>`. State owns all Wayland globals and is passed as `&mut self` to all handler trait implementations. | 2 | GO: `EwwmState` struct compiles; all fields correctly typed; state accessible from calloop callbacks |
| 3.3 | **Calloop event loop and Wayland socket.** Implement main event loop: `let mut event_loop = calloop::EventLoop::<EwwmState>::try_new()`. Register Wayland display socket as calloop source: `loop_handle.insert_source(display.backend().poll_fd(), ...)` -- when socket has data, call `display.dispatch_clients(&mut state)`. Set up WAYLAND_DISPLAY environment variable (default `wayland-1`, configurable via `--wayland-socket` CLI arg). Implement main loop body: (a) dispatch calloop events, (b) process pending Wayland client requests, (c) flush client buffers, (d) render frame if needed (damage-based, not every iteration), (e) sleep until next event or 16ms timeout (vblank-aligned). Verify event loop iteration time < 1ms when idle (no events, no rendering). Log event loop timing with `tracing::trace!`. Implement graceful shutdown on SIGTERM/SIGINT via calloop signal source. | 2 | GO: event loop runs; `WAYLAND_DISPLAY=wayland-1` socket created in `$XDG_RUNTIME_DIR`; clean shutdown on Ctrl+C |
| 3.4 | **wl_compositor and wl_shm handler implementation.** Implement `CompositorHandler` trait for `EwwmState`: `fn compositor_state(&mut self) -> &mut CompositorState`, `fn client_compositor_state(&self, client: &Client) -> &CompositorClientState`. This enables clients to create `wl_surface` objects. Implement `ShmHandler` trait: `fn shm_state(&self) -> &ShmState`. This enables clients to share pixel buffers via shared memory (the simplest buffer passing protocol, used by most toolkit fallbacks). Implement `BufferHandler` trait for buffer lifecycle. Register both as Wayland globals: `CompositorState::new::<EwwmState>(&display_handle)`, `ShmState::new::<EwwmState>(&display_handle, vec![wl_shm::Format::Argb8888, wl_shm::Format::Xrgb8888])`. Implement `on_commit` callback in `CompositorHandler`: when a surface commits new buffer content, mark it as needing redraw. Track all committed surfaces in `EwwmState.surfaces`. | 2 | GO: `wl_compositor` and `wl_shm` globals advertised; client can create surface and attach SHM buffer |
| 3.5 | **xdg_shell handler implementation.** Implement `XdgShellHandler` trait for `EwwmState`: `fn xdg_shell_state(&mut self) -> &mut XdgShellState`, `fn new_toplevel(&mut self, surface: ToplevelSurface)` -- called when client creates a new `xdg_toplevel` (application window). In `new_toplevel`: assign unique surface_id, create `SurfaceData`, add to `EwwmState.surfaces`, configure initial geometry (full output width x height for tiling, or client-requested size), send `xdg_toplevel::configure` with `activated` state and geometry. Implement `fn toplevel_destroyed(&mut self, surface: ToplevelSurface)` -- remove from surfaces list. Implement `fn new_popup`, `fn popup_destroyed` (stubs initially). Implement `fn grab` for interactive move/resize (stub). Handle `set_title`, `set_app_id` events to populate `SurfaceData` fields. After xdg_shell setup, a client like `weston-terminal` or `foot` should be able to connect, negotiate xdg_toplevel, and render content. | 2 | GO: `weston-terminal` (or `foot`) connects, creates xdg_toplevel, renders visible content |
| 3.6 | **DRM backend initialization.** Implement `src/backend/drm.rs` following the anvil DRM backend pattern. Startup sequence: (a) Open session via `libseat` (`smithay::backend::session::libseat::LibSeatSession::new()`). (b) Enumerate DRM devices via session. (c) Open primary DRM device (`DrmDevice::new()`). (d) Enumerate connectors and CRTCs. (e) Select output mode (prefer native resolution). (f) Initialize GBM allocator (`GbmAllocator::new()`). (g) Initialize GLES2 renderer (`GlesRenderer::new()`). (h) Create DRM compositor (`DrmCompositor::new()`) binding output, CRTC, and renderer. (i) Create Smithay `Output` and register as Wayland global. (j) Register DRM device fd as calloop source for vblank events. (k) On vblank: render all committed surfaces to output framebuffer, submit frame via `drm_compositor.queue_frame()`. Handle: multi-GPU (skip for now, single GPU only), hotplug (connector connect/disconnect events), mode switching. | 2 | GO: compositor opens DRM device; output mode set; empty frame submitted; monitor shows black screen (or compositor window content) |
| 3.7 | **Winit development backend.** Implement `src/backend/winit.rs` for development use (compositor runs inside an existing desktop as a window). Use `smithay::backend::winit::init()` which creates a Winit window with EGL context. Map Winit input events (keyboard, mouse) to Smithay input events. Render to Winit window instead of DRM output. This backend enables development without needing to switch TTYs or risk locking up the display. Implement `--backend winit|drm|headless` CLI flag to select backend at startup. Default: `winit` for development, `drm` for production (detected by checking if `$DISPLAY` or `$WAYLAND_DISPLAY` is set). | 1 | GO: `cargo run -- --backend winit` opens window showing compositor output; Wayland clients render inside window |
| 3.8 | **Input handling via libinput and wl_seat.** Implement `SeatHandler` trait for `EwwmState`. Create seat with keyboard and pointer capabilities. Keyboard: (a) Register libinput keyboard as calloop source. (b) On key event: convert libinput keycode to xkbcommon keysym. (c) Forward to focused surface via `seat.get_keyboard().input()`. (d) Use xkbcommon for keymap handling (load system keymap from `XKB_DEFAULT_LAYOUT` env var, default "us"). Pointer: (a) Register libinput pointer as calloop source. (b) On motion event: update pointer position, find surface under cursor via `EwwmState.space.element_under(point)`. (c) Forward enter/leave/motion/button events to surface via `seat.get_pointer().motion()`, `.button()`, etc. (d) Track focused surface: pointer enter sends `wl_pointer.enter`, leave sends `wl_pointer.leave`. Implement focus-follows-pointer: moving pointer to a surface focuses it. Keyboard focus follows pointer focus. | 2 | GO: keyboard input reaches focused client (type in terminal); pointer clicks work; focus-follows-pointer functional |
| 3.9 | **Headless backend for CI testing.** Implement `src/backend/headless.rs`. Use `smithay::backend::renderer::test::DummyRenderer` or GLES2 with EGL surfaceless context (`EGL_MESA_platform_surfaceless`). No DRM device, no physical output. Create virtual output (1920x1080). Render to off-screen framebuffer. Implement `--backend headless` CLI flag. For CI: compositor starts, clients can connect, surfaces are managed, but no physical display output. Implement `--headless-exit-after N` flag: run for N seconds then exit (for automated testing). Add `cargo test` integration tests using headless backend: (a) compositor starts in headless, (b) mock client connects via `wayland-client` crate, (c) mock client creates surface, (d) compositor assigns surface ID, (e) mock client destroys surface, (f) compositor cleans up. Target: >= 5 Rust integration tests. | 2 | GO: `cargo test` passes with headless backend; mock client connects and creates surface; tests run in CI without GPU |
| 3.10 | **GLES2 rendering pipeline.** Implement `src/render.rs`. Rendering per frame: (a) Begin render pass: `renderer.bind(output_buffer)`, clear to background color (configurable, default dark gray `#1e1e2e`). (b) For each surface in `EwwmState.space` (bottom to top stacking order): import surface buffer as texture (`renderer.import_buffer()`), draw textured quad at surface geometry position. (c) Draw pointer cursor (hardware cursor if DRM, software cursor overlay if Winit). (d) End render pass: `renderer.unbind()`. Damage tracking: only re-render regions where surface content changed (Smithay `OutputDamageTracker`). Frame scheduling: render on vblank event (DRM) or 60Hz timer (Winit). Measure frame time: log warning if > 12ms (approaching 16ms deadline). Performance target: < 5ms frame time with 0 surfaces, < 8ms with 3 surfaces (SHM buffers, no DMA-BUF optimization yet). | 2 | GO: surfaces render at correct positions; background visible; frame time < 8ms with 3 test clients |
| 3.11 | **Flake.nix compositor package.** Add compositor crate to `flake.nix` as `packages.x86_64-linux.compositor`. Use `rustPlatform.buildRustPackage` with: `cargoLock.lockFile = ./compositor/Cargo.lock`, `nativeBuildInputs = [ pkg-config ]`, `buildInputs = [ wayland libdrm mesa libinput libxkbcommon seatd udev ]`. Set `SMITHAY_HAS_RENDER_TEST` env var for Smithay feature detection. Handle Smithay's dependency on `libclang` for bindgen: add `llvmPackages.clang` to `nativeBuildInputs`. Verify `nix build .#compositor` produces binary, `nix run .#compositor -- --backend headless --headless-exit-after 5` runs and exits cleanly. Add to devShell: compositor binary in PATH. Update justfile: `build-compositor` recipe calls `cargo build --manifest-path compositor/Cargo.toml`, `test-compositor` calls `cargo test`. | 1 | GO: `nix build .#compositor` succeeds; resulting binary starts in headless mode; `just build-compositor` and `just test-compositor` work |
| 3.12 | **End-to-end validation and integration tests.** Full integration test: (a) Start compositor in Winit backend. (b) Set `WAYLAND_DISPLAY` to compositor's socket. (c) Launch `foot` terminal (or `weston-terminal`). (d) Verify terminal window appears, renders text, accepts keyboard input. (e) Launch second client. (f) Verify both render side by side (basic tiling from `smithay::desktop::Space`). (g) Close clients. (h) Verify compositor cleans up surface state. (i) Stop compositor. Write this as a shell script `test/integration/compositor-smoke-test.sh` invokable via `just test-integration`. Also add ERT test: `test/compositor-test.el` that verifies compositor binary exists and `--version` flag works. Target: >= 40 cumulative ERT tests (including Week 1+2 tests + new ones). | 2 | GO: smoke test passes end-to-end; two clients render simultaneously; >= 40 cumulative ERT tests |

**Research (parallel):**
- R3.1: **KWin VR MR texture import pipeline study.** Study the KDE KWin VR merge request's DMA-BUF import implementation: how `EGLImage` is created from DMA-BUF fd (`eglCreateImageKHR` with `EGL_LINUX_DMA_BUF_EXT`), how EGL image is bound as GL texture (`glEGLImageTargetTexture2DOES`), and how this texture is then used for VR frame submission. Document the full pipeline with code references. Identify which Smithay APIs correspond to each step. Assess GPU driver requirements (Mesa >= 21.x, NVIDIA >= 535 for GBM). This informs Week 8 VR rendering. (1 agent)
- R3.2: **wxrd (Collabora VR compositor) architecture study.** wxrd (formerly xrdesktop) is a Collabora-developed VR desktop compositor. Study: Vulkan rendering pipeline, OpenXR integration pattern, how 2D Wayland surfaces are textured onto 3D quads, input ray-casting implementation. Compare architecture against our Smithay approach. Identify any patterns we should adopt or pitfalls to avoid. (1 agent)
- R3.3: **Smithay desktop module evaluation.** Smithay provides `smithay::desktop` with `Space`, `Window`, `LayerMap` abstractions that simplify compositor development. Evaluate: does `Space` provide sufficient layout flexibility for our needs (tiling, floating, workspace switching)? Does `Window` correctly track xdg_toplevel lifecycle? Does damage tracking via `OutputDamageTracker` work correctly with `Space`? Compare against niri's custom window management (niri implements its own layout system instead of using `Space`). Recommend: use `Space` for initial scaffold, or follow niri's custom approach? (1 agent)

**Completion Metrics:**
- [ ] Compositor binary builds via `cargo build` and `nix build .#compositor`
- [ ] DRM backend: opens DRM device, sets output mode, submits frames
- [ ] Winit backend: compositor window opens, clients render inside
- [ ] Headless backend: starts without GPU, mock clients connect in tests
- [ ] wl_compositor + wl_shm: clients can create surfaces with shared memory buffers
- [ ] xdg_shell: clients can create toplevel windows with title and app_id
- [ ] Input: keyboard events reach focused client; pointer clicks work; focus-follows-pointer
- [ ] Rendering: surfaces composited at correct positions; damage tracking reduces unnecessary redraws
- [ ] Frame timing: < 5ms with 0 surfaces, < 8ms with 3 surfaces (Winit backend)
- [ ] `cargo test`: >= 5 Rust integration tests pass in headless mode
- [ ] `nix build .#compositor` produces valid binary
- [ ] End-to-end: two Wayland clients render simultaneously
- [ ] >= 40 cumulative ERT tests passing
- [ ] Justfile recipes: `build-compositor`, `test-compositor`, `test-integration` all functional

**Gate: GO/NOGO/ASK**
- GO if compositor renders client windows in Winit backend AND headless tests pass AND DRM backend initializes
- ASK if DRM backend fails on specific GPU (proceed with Winit + headless only; defer DRM debugging)
- ASK if Smithay `desktop::Space` is too limiting (switch to custom layout management following niri pattern)
- NOGO if Smithay API is too unstable for production use (> 3 breaking changes in handler traits during this week)
- NOGO if GLES2 renderer cannot import SHM buffers on target GPU (fundamental rendering failure)

**Risk Table:**

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Smithay API breaks between spike (Week 1) and scaffold (Week 3) | Low | High | Pin to exact git commit; monitor Smithay changelog |
| DRM backend fails on NVIDIA proprietary driver | High | Medium | NVIDIA < 535 lacks GBM; target AMD/Intel for initial development; document NVIDIA requirements |
| libseat session management fails in development environment | Medium | Medium | Winit backend bypasses libseat entirely; DRM only needed for production |
| Wayland client compatibility issues with custom compositor | Medium | Medium | Test with multiple clients (foot, weston-terminal, Alacritty); implement protocol correctly per spec |
| Headless backend insufficient for meaningful CI testing | Low | Medium | Headless still runs full Wayland protocol; only rendering is stubbed |

**Composability Notes:**
- Compositor binary is the long-lived artifact extended in every subsequent week (IPC in Week 4, XWayland in Week 6, OpenXR in Week 7, DMA-BUF in Week 8, eye tracking relay in Week 11)
- Backend selection pattern (DRM/Winit/headless) carries through to Week 16 multi-architecture builds
- `EwwmState` struct grows weekly; initial fields here are subset of final state
- Rendering pipeline from 3.10 is extended in Week 8 (VR stereoscopic) and Week 13 (gaze overlay)

**Parallelism Opportunities:**
- Stages 3.1 (scaffold) and 3.2 (state struct) must be sequential
- Stages 3.4 (wl_compositor) and 3.5 (xdg_shell) can parallelize once state struct is defined
- Stages 3.6 (DRM) and 3.7 (Winit) and 3.9 (headless) are independent backend implementations
- Stage 3.8 (input) depends on 3.5 (xdg_shell) for surface focus targets
- Stage 3.10 (rendering) depends on 3.4 + 3.5 (surfaces to render)
- Stage 3.11 (Nix package) can start once 3.1 (Cargo.toml) is done
- All 3 research agents run in parallel with build stages

**Integration Points:**
- Week 1: Smithay spike (1.9) findings and flake.nix (1.1) consumed
- Week 2: anvil patterns (2.11) guide handler implementations; crate lives in compositor/ directory
- Week 4: IPC server added to compositor event loop (calloop source)
- Week 5: ewwm.el connects to compositor via IPC to manage surfaces
- Week 6: XWayland integration adds X11 client support to compositor
- Week 7: OpenXR session management added to compositor
- Week 8: DMA-BUF import extends rendering pipeline for VR textures
- Week 15: compositor binary packaged into NixOS module and RPM

---

## Phase 1: Emacs-Compositor Bridge (Weeks 4-6)

### Week 4: IPC Protocol Design & Implementation

**Goal:** Full s-expression IPC protocol over Unix domain socket with 20+ message types; Rust IPC server integrated into compositor calloop event loop; Emacs IPC client via `make-network-process` in ewwm-ipc.el; bidirectional async messaging (Emacs commands compositor, compositor pushes events to Emacs); reconnection and error handling; protocol specification documented with wire format examples; sub-millisecond round-trip latency validated

**Dependencies:** Week 3 (compositor with calloop event loop), Week 2 (ewwm-ipc.el stub)

| Stage | Task | Agents | Gate |
|-------|------|--------|------|
| 4.1 | **IPC protocol specification.** Design and document the full protocol in `docs/ipc-protocol.md`. Wire format: s-expressions over Unix domain socket at `$XDG_RUNTIME_DIR/ewwm-ipc.sock`. Framing: length-prefixed messages -- 4-byte big-endian uint32 payload length followed by UTF-8 s-expression payload. This avoids delimiter ambiguity in nested s-expressions. Message structure: `(:type MESSAGE-TYPE :id REQUEST-ID &rest PAYLOAD)`. REQUEST-ID is a monotonically increasing integer for request/response correlation. Response structure: `(:type :response :id REQUEST-ID :status :ok|:error &rest PAYLOAD)`. Event structure (compositor-initiated, no request-id): `(:type :event :event EVENT-TYPE &rest PAYLOAD)`. Define 20+ message types organized by category: **Surface management:** `:surface-list` (query all surfaces -> returns list of `(:id N :app-id STR :title STR :geometry (:x N :y N :w N :h N) :workspace N :focused BOOL)`), `:surface-focus` (focus surface by ID), `:surface-close` (close surface), `:surface-move` (move to x,y), `:surface-resize` (resize to w,h), `:surface-fullscreen` (toggle fullscreen), `:surface-float` (toggle floating). **Workspace:** `:workspace-switch` (switch to workspace N), `:workspace-list` (query workspaces), `:workspace-move-surface` (move surface to workspace). **Layout:** `:layout-set` (set layout algorithm: tiling, floating, monocle), `:layout-cycle` (cycle through layouts). **Input:** `:key-grab` (grab global key combo), `:key-ungrab` (release key grab), `:autotype` (inject keystrokes into surface -- Week 14). **VR (stubs):** `:vr-status` (query VR session state), `:vr-surface-position` (3D position), `:gaze-data` (gaze coordinates). **Events (compositor -> Emacs):** `:surface-created` (new surface appeared), `:surface-destroyed` (surface closed), `:surface-title-changed`, `:surface-focused`, `:surface-geometry-changed`, `:workspace-changed`, `:key-pressed` (grabbed key event). Version negotiation: first message from client must be `(:type :hello :version 1 :client "ewwm.el")`, server responds with `(:type :hello :version 1 :server "ewwm-compositor" :features (:xwayland BOOL :vr BOOL))`. | 2 | GO: protocol spec documented with >= 20 message types, wire format examples, and version negotiation |
| 4.2 | **Rust IPC server: socket listener.** Implement `src/ipc/mod.rs` in compositor crate. Create Unix domain socket at `$XDG_RUNTIME_DIR/ewwm-ipc.sock` (remove stale socket on startup). Register listener as calloop source: `calloop::generic::Generic::new(listener.as_raw_fd(), calloop::Interest::READ, calloop::Mode::Level)`. On new connection: accept, create per-client state (`IpcClient { stream: UnixStream, read_buf: Vec<u8>, write_buf: Vec<u8>, authenticated: bool }`). Register each client stream as calloop source for read events. Socket permissions: `0700` (owner only, same as Wayland socket). Support multiple simultaneous clients (future: separate Emacs instances, debugging tools). Implement `IpcServer` struct holding listener fd, client list, and message dispatch table. | 2 | GO: `socat UNIX-CONNECT:$XDG_RUNTIME_DIR/ewwm-ipc.sock -` connects successfully; multiple simultaneous connections accepted |
| 4.3 | **Rust IPC server: message parsing and dispatch.** Implement s-expression parsing in Rust using `lexpr` crate (or `serde-lexpr` for typed deserialization). Read loop per client: (a) read bytes into buffer, (b) extract length prefix (4 bytes), (c) when full message received, parse s-expression via `lexpr::from_str()`, (d) extract `:type` field, (e) dispatch to handler function. Implement handler functions for initial message types: `handle_hello()` (version check, return server capabilities), `handle_surface_list()` (iterate `EwwmState.surfaces`, serialize to s-expression list), `handle_surface_focus()` (find surface by ID, set keyboard focus via `seat.get_keyboard().set_focus()`), `handle_surface_close()` (send `xdg_toplevel.close()` to surface), `handle_workspace_switch()` (switch active workspace in Space). Response serialization: `lexpr::to_string()` with length prefix. Event emission: when compositor state changes (new surface, focus change), serialize event and write to ALL connected clients. Implement backpressure: if client write buffer > 64KB, drop oldest events (not commands). | 2 | GO: `(:type :hello :version 1 :client "test")` returns valid hello response; `(:type :surface-list)` returns current surfaces |
| 4.4 | **Emacs IPC client: ewwm-ipc.el connection management.** Flesh out `lisp/vr/ewwm-ipc.el` (stub from Week 2). Implement `(ewwm-ipc-connect &optional SOCKET-PATH)`: create connection via `(make-network-process :name "ewwm-ipc" :family 'local :service (or SOCKET-PATH (expand-file-name "ewwm-ipc.sock" (getenv "XDG_RUNTIME_DIR"))) :coding 'binary :filter #'ewwm-ipc--filter :sentinel #'ewwm-ipc--sentinel :noquery t)`. Store process in `ewwm--ipc-connection` (from Week 2 stub). Implement length-prefixed framing: `(ewwm-ipc--encode-message SEXP)` converts Elisp form to string via `(prin1-to-string SEXP)`, prepends 4-byte big-endian length. `(ewwm-ipc--decode-message BYTES)` extracts length prefix, reads payload, parses via `(read PAYLOAD-STRING)`. Filter function `ewwm-ipc--filter`: accumulates bytes in process buffer, extracts complete framed messages, dispatches via `ewwm-ipc--dispatch`. Sentinel function `ewwm-ipc--sentinel`: handles disconnect, triggers reconnection logic (stage 4.8). | 2 | GO: `(ewwm-ipc-connect)` establishes connection; hello handshake completes; `ewwm--ipc-connection` is live process |
| 4.5 | **Emacs IPC client: request/response and event handling.** Implement `(ewwm-ipc-send REQUEST &optional CALLBACK)`: assigns request-id from `ewwm-ipc--next-id` counter, stores callback in `ewwm-ipc--pending-requests` hash table keyed by request-id, sends framed message. Synchronous variant: `(ewwm-ipc-send-sync REQUEST &optional TIMEOUT)` using `(accept-process-output)` with timeout (default 2 seconds). Dispatch function `ewwm-ipc--dispatch`: if message has `:id` matching pending request, invoke callback with response payload, remove from pending table. If message is `:type :event`, dispatch to event handlers via `ewwm-ipc--event-handlers` alist: `(:surface-created . ewwm-ipc--on-surface-created)`, `(:surface-destroyed . ewwm-ipc--on-surface-destroyed)`, etc. Implement convenience wrappers: `(ewwm-surface-list)` = `(ewwm-ipc-send-sync '(:type :surface-list))`, `(ewwm-surface-focus ID)` = `(ewwm-ipc-send '(:type :surface-focus :id ID))`, `(ewwm-workspace-switch N)` = `(ewwm-ipc-send '(:type :workspace-switch :workspace N))`. | 2 | GO: `(ewwm-surface-list)` returns list of surfaces from compositor; `(ewwm-surface-focus 1)` changes focus |
| 4.6 | **Compositor event emission pipeline.** In Rust compositor, implement `IpcEventEmitter` that broadcasts state changes to all connected IPC clients. Hook into compositor state transitions: (a) In `XdgShellHandler::new_toplevel()`: emit `(:type :event :event :surface-created :id N :app-id "..." :title "...")`. (b) In `XdgShellHandler::toplevel_destroyed()`: emit `(:type :event :event :surface-destroyed :id N)`. (c) On title change (`set_title`): emit `(:type :event :event :surface-title-changed :id N :title "new title")`. (d) On focus change (keyboard focus moves): emit `(:type :event :event :surface-focused :id N)`. (e) On workspace switch: emit `(:type :event :event :workspace-changed :workspace N)`. (f) On surface geometry change: emit `(:type :event :event :surface-geometry-changed :id N :geometry (:x X :y Y :w W :h H))`. Event emission is non-blocking: serialize to each client's write buffer, calloop flushes on next iteration. | 1 | GO: launching a new Wayland client triggers `:surface-created` event visible in Emacs `*Messages*` buffer |
| 4.7 | **Global key grab mechanism.** Implement `:key-grab` and `:key-ungrab` IPC messages. Emacs sends `(:type :key-grab :key "s-r" :id 42)` to register interest in Super+r. Compositor intercepts matching key events BEFORE forwarding to focused surface. On match: emit `(:type :event :event :key-pressed :key "s-r" :modifiers (:super t) :timestamp ...)` to Emacs. Emacs dispatches via `ewwm-input--global-key-handler`. Key format: Emacs-style key descriptions (`"s-r"` = Super+r, `"C-M-x"` = Ctrl+Alt+x). Compositor translates Emacs key descriptions to xkbcommon keysym + modifier mask. Support grab/ungrab at runtime (Emacs can dynamically add/remove key grabs). Initial grabbed keys: `s-r` (exwm-reset equivalent), `s-&` (launch command), `s-1` through `s-9` (workspace switch). This is the Wayland equivalent of EXWM's `xcb:GrabKey` mechanism. | 2 | GO: pressing Super+r with a Wayland client focused delivers `:key-pressed` event to Emacs; client does NOT receive the key |
| 4.8 | **Reconnection and error handling.** Implement robust reconnection in `ewwm-ipc.el`: (a) On disconnect (sentinel fires with "connection broken"): log warning, start reconnection timer via `(run-at-time 1 1 #'ewwm-ipc--try-reconnect)`. (b) Reconnection: attempt `(ewwm-ipc-connect)`, on success cancel timer, re-send hello, re-register all key grabs, request full surface list to resync state. (c) Exponential backoff: 1s, 2s, 4s, 8s, max 30s between reconnect attempts. (d) On compositor crash: all pending request callbacks invoked with `(:status :error :reason "disconnected")`. (e) `ewwm-ipc--pending-requests` cleared on disconnect. (f) Stale socket detection: if socket file exists but connection refused, remove socket file and wait for compositor restart. Implement `ewwm-ipc-status` command showing connection state, latency, message counts. Hook: `ewwm-ipc-connected-hook`, `ewwm-ipc-disconnected-hook` for user customization. | 1 | GO: killing compositor process triggers reconnection; restarting compositor results in automatic re-connection and state resync |
| 4.9 | **IPC latency benchmarking.** Implement `(ewwm-ipc-benchmark &optional COUNT)` interactive command: sends COUNT (default 1000) ping messages `(:type :ping)`, measures round-trip time for each, reports min/max/mean/p50/p95/p99. Compositor implements `:ping` handler that immediately responds with `(:type :pong :timestamp SERVER-TIMESTAMP)`. Also implement Rust-side benchmark: `cargo bench` using `criterion` crate, measures: s-expression parse time (target: < 10us per message), serialize time (< 10us), full message roundtrip via loopback socket (< 500us). Log results to `docs/benchmarks/ipc-latency.md`. Verify: round-trip p99 < 1ms on x86_64 with both Emacs and compositor running on same machine. If s-expression parsing exceeds 50us in Rust, evaluate `serde-lexpr` alternatives or fall back to msgpack with `rmp-serde`. | 1 | GO: IPC round-trip p99 < 1ms; Rust parse benchmark < 50us per message; results documented |
| 4.10 | **Protocol debugging tools.** Implement `ewwm-ipc-trace-mode` minor mode in Emacs: when enabled, logs all sent and received IPC messages to `*ewwm-ipc-trace*` buffer with timestamps. Format: `[2024-01-15 10:30:45.123] >> (:type :surface-focus :id 3 :id 42)` (sent) and `[2024-01-15 10:30:45.124] << (:type :response :id 42 :status :ok)` (received). Implement compositor-side `--ipc-trace` CLI flag that logs all IPC messages to stderr with timestamps. Create `tools/ewwm-ipc-client.py` -- simple Python script that connects to IPC socket and sends/receives messages for manual testing: `python3 tools/ewwm-ipc-client.py '(:type :surface-list)'`. Also usable via `socat`: document the `socat` command for raw socket interaction. | 1 | GO: `ewwm-ipc-trace-mode` shows real-time message flow; Python client sends and receives messages |
| 4.11 | **Comprehensive IPC test suite.** ERT tests in `test/ewwm-ipc-test.el`: (a) message encoding/decoding roundtrip for all basic types (integers, strings, symbols, nested lists, nil, t), (b) length-prefix framing handles partial reads correctly, (c) request-id correlation matches responses to requests, (d) event dispatch calls correct handler, (e) reconnection logic fires on disconnect, (f) synchronous send with timeout returns response, (g) synchronous send with timeout signals error on deadline. Rust tests in `compositor/tests/ipc_test.rs`: (a) s-expression parsing for all message types, (b) surface-list returns correct data, (c) concurrent client connections handled, (d) malformed message returns error response, (e) oversized message rejected (> 1MB), (f) backpressure drops old events when client is slow. Target: >= 12 new tests (6 ERT + 6 Rust). Cumulative: >= 52 ERT tests. | 2 | GO: all IPC tests pass; >= 52 cumulative ERT tests; Rust IPC tests pass in CI |
| 4.12 | **Protocol documentation with wire examples.** Finalize `docs/ipc-protocol.md` with: (a) Complete message type reference (all 20+ types with request/response examples). (b) Wire format diagram (length prefix + payload bytes). (c) Session lifecycle: connect -> hello -> key-grab -> surface-list -> ... -> disconnect. (d) Error handling: malformed messages, unknown types, version mismatch. (e) Event subscription model (all events broadcast to all clients). (f) Performance characteristics (latency, throughput, maximum message size). (g) Security considerations: socket permissions, no authentication (same user only), no encryption (local only). (h) Future extensions: msgpack binary mode, multi-socket for VR data streams, protocol versioning strategy. | 1 | GO: documentation covers all message types with copy-paste-able examples; new developer can implement client from docs alone |

**Research (parallel):**
- R4.1: **IPC encoding format benchmark.** Benchmark three encoding formats for our message types: (a) S-expression via `lexpr` crate (Rust) / `read`/`print` (Emacs). (b) Msgpack via `rmp-serde` (Rust) / `msgpack.el` (Emacs). (c) JSON via `serde-json` (Rust) / `json.el` (Emacs). Measure: encode time, decode time, message size, round-trip latency through Unix socket. Test with representative messages: surface-list with 20 surfaces, gaze data at 60Hz, key events. Expected result: s-expression fastest in Emacs (native `read`), msgpack smallest wire size, JSON most verbose. Recommend s-expression as primary with msgpack as future binary mode for high-frequency data (gaze, EEG). (1 agent)
- R4.2: **Niri IPC architecture comparison.** niri implements IPC via `niri-ipc` crate with JSON encoding over Unix socket. Study: message framing, request/response correlation, event subscription model, error handling. Compare against our s-expression protocol. Identify any design decisions we should adopt. Note: niri IPC is much simpler (fewer message types, no VR/biometric events). (1 agent)
- R4.3: **Emacs `make-network-process` performance profiling.** Profile Emacs handling 1000 IPC messages/second via `make-network-process` with local socket. Measure: filter function overhead, buffer allocation, GC pressure. Determine maximum sustainable message rate without impacting Emacs responsiveness. This informs Week 11+ where gaze data arrives at 60-200Hz and EEG at 250Hz. If Emacs cannot sustain > 500 msg/s, plan for compositor-side decimation. (1 agent)

**Completion Metrics:**
- [ ] IPC protocol specification documented with >= 20 message types and wire format examples
- [ ] Compositor IPC server accepts connections on Unix domain socket
- [ ] Emacs IPC client connects via `make-network-process` and completes hello handshake
- [ ] `(ewwm-surface-list)` returns correct surface data from compositor
- [ ] `(ewwm-surface-focus ID)` changes keyboard focus in compositor
- [ ] Compositor pushes `:surface-created` and `:surface-destroyed` events to Emacs
- [ ] Global key grab: Super+r intercepted by compositor, event delivered to Emacs
- [ ] Reconnection: compositor restart results in automatic re-connection within 5 seconds
- [ ] IPC round-trip latency p99 < 1ms (benchmarked with 1000 messages)
- [ ] IPC trace mode shows real-time message flow for debugging
- [ ] >= 52 cumulative ERT tests passing
- [ ] Rust IPC integration tests pass in headless CI

**Gate: GO/NOGO/ASK**
- GO if round-trip p99 < 2ms AND all core message types work AND event emission functional AND key grab works
- ASK if s-expression parsing > 100us in Rust (evaluate msgpack as primary encoding; s-expression as human-readable debug mode)
- ASK if Emacs `make-network-process` filter overhead > 1ms per message (consider batching or native module for IPC)
- NOGO if Unix socket IPC fundamentally unreliable (messages lost, ordering broken) -- would need to evaluate D-Bus or named pipe alternatives

**Risk Table:**

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| S-expression parsing too slow in Rust | Low | Medium | `lexpr` crate benchmarks at ~5us for typical messages; fallback to msgpack |
| Emacs filter function blocks during high-frequency events | Medium | Medium | Implement compositor-side event decimation; batch gaze events into 100ms windows |
| Socket permissions allow unauthorized access | Low | High | Default 0700 permissions; document security model |
| Length-prefix framing bugs cause message corruption | Medium | High | Extensive fuzz testing of framing code; checksum validation (optional) |
| Request-id overflow (u64 exhaustion) | Negligible | Low | u64 overflow at ~500 million years of continuous operation at 1000 msg/s |

**Composability Notes:**
- IPC protocol is the communication backbone for ALL Emacs-compositor interaction in Weeks 5-20
- Message types grow weekly: VR events (Week 7-10), gaze events (Week 11-13), BCI events (Week 19), autotype (Week 14)
- Key grab mechanism (4.7) is the Wayland replacement for EXWM's X11 key grab, consumed by Week 5 (ewwm-input.el)
- Event emission (4.6) is consumed by Week 5 (surface lifecycle management in ewwm-manage.el)
- IPC trace mode (4.10) is essential debugging tool for all future development
- Benchmark infrastructure (4.9) feeds into Week 20 performance benchmarks

**Parallelism Opportunities:**
- Stage 4.1 (protocol spec) is prerequisite for all implementation stages
- Stages 4.2/4.3 (Rust server + Emacs client) can parallelize after spec is defined
- Stages 4.4/4.5 (request/response + events) can parallelize once basic connection works
- Stages 4.6 (event emission) and 4.7 (key grab) are independent compositor features
- Stages 4.9 (benchmarking) and 4.10 (debugging) are independent tooling
- All 3 research agents run in parallel with build stages

**Integration Points:**
- Week 3: compositor calloop event loop receives IPC server as new calloop source
- Week 5: ewwm.el modules use IPC client to query and control compositor
- Week 6: XWayland surface events flow through same IPC channel
- Week 7-10: VR events (session state, frame timing, gaze ray) added as new message types
- Week 11-13: eye tracking events (gaze coordinates, blinks, winks) added at high frequency
- Week 14: autotype message (`:autotype :text "..." :surface-id N`) for KeePassXC
- Week 19: BCI events (attention, SSVEP, P300) added as new message types

---

### Week 5: Emacs Window Management Layer (ewwm.el)

**Goal:** Full Emacs-side window management layer with 6 core modules: ewwm-core.el (surface-as-buffer model mapping from EXWM's `exwm--id-buffer-alist`), ewwm-workspace.el (workspace switching and surface assignment), ewwm-layout.el (tiling/floating/monocle layouts using Emacs window tree), ewwm-input.el (global key dispatch via IPC key grabs), ewwm-manage.el (surface lifecycle from creation through destruction), ewwm-floating.el (floating window mode); all modules communicate with compositor exclusively via Week 4 IPC; surface-as-buffer model allows standard Emacs buffer commands (C-x b, ibuffer, consult-buffer) to manage Wayland windows

**Dependencies:** Week 4 (IPC protocol and client), Week 2 (ewwm stubs, extraction plan), Week 3 (compositor with surfaces)

| Stage | Task | Agents | Gate |
|-------|------|--------|------|
| 5.1 | **ewwm-core.el: surface-as-buffer model.** Flesh out the Week 2 stub into full implementation. Central data structure: `ewwm--surface-buffer-alist` (alist of `(SURFACE-ID . BUFFER)`) -- direct analog of EXWM's `exwm--id-buffer-alist` (28 refs across 7 files in original EXWM). On `:surface-created` IPC event: create new buffer via `(generate-new-buffer (format "*ewwm:%s*" app-id))`, set buffer-local variables: `ewwm-surface-id` (integer), `ewwm-app-id` (string, from xdg_toplevel `set_app_id`), `ewwm-title` (string, from `set_title`), `ewwm-class-name` (alias for app-id, EXWM compatibility), `ewwm-instance-name`, `ewwm-surface-state` (symbol: `managed`, `floating`, `fullscreen`), `ewwm-geometry` (plist `(:x N :y N :w N :h N)`), `ewwm-workspace` (integer). Set buffer major mode to `ewwm-mode`. Add to `ewwm--surface-buffer-alist`. On `:surface-destroyed` event: find buffer by surface-id, kill buffer (via `kill-buffer` with confirmation bypass), remove from alist. On `:surface-title-changed` event: update `ewwm-title` buffer-local, rename buffer to `*ewwm:new-title*` via `(rename-buffer)`. Implement `(ewwm-get-buffer ID)`, `(ewwm-get-surface BUFFER)`, `(ewwm-surface-list)`, `(ewwm-buffer-list)` accessors. | 2 | GO: launching `foot` terminal creates `*ewwm:foot*` buffer in Emacs; closing foot kills the buffer; `(ewwm-surface-list)` returns correct IDs |
| 5.2 | **ewwm-mode: buffer major mode for managed surfaces.** Define `ewwm-mode` derived from `special-mode` (read-only, like EXWM's `exwm-mode`). Keymap `ewwm-mode-map` with initial bindings: `q` -> `(ewwm-surface-close)`, `f` -> `(ewwm-floating-toggle)`, `F` -> `(ewwm-fullscreen-toggle)`, `m` -> `(ewwm-surface-move-to-workspace)`. Mode-line format: `(setq mode-line-format '(" " ewwm-title " [" ewwm-app-id "] ws:" (:eval (number-to-string ewwm-workspace)) " " ewwm-surface-state))` -- shows title, app ID, workspace number, and state. Buffer content: display informational text ("Wayland surface: <title>\nApp ID: <app-id>\nSurface ID: <id>\nWorkspace: <n>\nState: <state>\n\nThis buffer represents a Wayland surface managed by ewwm.\nUse standard Emacs buffer/window commands to manage it."). Update buffer content on title/geometry changes. Hooks: `ewwm-mode-hook` for user customization. Font-lock: highlight app-id and surface-id in buffer content. | 1 | GO: `ewwm-mode` buffer displays surface info; mode-line shows app title and workspace; `q` closes surface |
| 5.3 | **ewwm-workspace.el: workspace management.** Implement full workspace system. Data model: `ewwm-workspace--list` is a vector of workspace structs, each containing `(name surfaces current-layout)`. `(defcustom ewwm-workspace-number 4 "Number of workspaces.")`. Workspace switching: `(ewwm-workspace-switch N)` sends `:workspace-switch` IPC, compositor shows/hides surfaces, Emacs switches to frame/tab displaying that workspace's buffers. Implementation options evaluated: (a) One Emacs frame per workspace (EXWM approach -- each frame is a workspace, `exwm-workspace.el` does this with 1763 lines of X11 frame manipulation). (b) `tab-bar-mode` per workspace (modern Emacs, cleaner). (c) Window configuration per workspace (save/restore via `current-window-configuration`). Choose option (c) for initial implementation: `ewwm-workspace--configs` stores `(window-configuration)` per workspace; switching saves current config, restores target config. Surface assignment: `(ewwm-workspace-move-surface SURFACE-ID WORKSPACE-N)` sends IPC, updates buffer-local `ewwm-workspace`, moves buffer to target workspace config. Keybindings: `s-1` through `s-9` for workspace switch (registered as global key grabs via Week 4 IPC). `s-S-1` through `s-S-9` for move-surface-to-workspace. `(ewwm-workspace-switch-next)`, `(ewwm-workspace-switch-prev)` for cycling. | 2 | GO: `s-1` switches to workspace 1; `s-S-2` moves current surface to workspace 2; window configuration saved/restored per workspace |
| 5.4 | **ewwm-layout.el: tiling layout engine.** Implement layout algorithms that use Emacs window tree to tile surfaces. Core concept: each Emacs window (in the Emacs `window-tree` sense) displays one ewwm buffer; layout algorithm determines the window split structure. Layouts: (a) **Tiling (master-stack):** one master window (left 55%), stack of remaining windows (right 45%). `(split-window-right)` for master, then `(split-window-below)` for each stack window. Master ratio configurable: `(defcustom ewwm-layout-master-ratio 0.55)`. (b) **Monocle:** single window fills frame, other surfaces hidden. Buffer switching via `C-x b` effectively switches visible surface. (c) **Grid:** equal-sized grid of windows via recursive splitting. (d) **Floating:** no automatic layout; surfaces positioned by compositor at requested geometry. Layout computation: `(ewwm-layout--apply LAYOUT BUFFERS)` takes layout algorithm and list of buffers for current workspace, creates appropriate window configuration, assigns one buffer per window. Trigger: re-layout on surface create, surface destroy, workspace switch. Send geometry updates to compositor: for each window, compute pixel geometry via `(window-pixel-edges)`, send `(:type :surface-resize :id ID :geometry (:x X :y Y :w W :h H))` to compositor. `(defcustom ewwm-layout-default 'tiling)`. Cycle: `(ewwm-layout-cycle)` rotates through layouts for current workspace, bound to `s-l`. | 2 | GO: three surfaces tile in master-stack layout; `s-l` cycles to monocle; compositor positions surfaces matching Emacs window geometry |
| 5.5 | **ewwm-input.el: global key binding dispatch.** Implement the Wayland equivalent of EXWM's key handling (1215 lines of X11 grab mechanism replaced by IPC-based key grabs from Week 4). Core API: `(ewwm-input-set-key KEY COMMAND)` -- registers KEY as global grab via IPC, stores `(KEY . COMMAND)` in `ewwm-input--global-keys` alist. On `:key-pressed` IPC event from compositor: look up key in alist, call associated command via `(funcall COMMAND)`. Default bindings: `(ewwm-input-set-key (kbd "s-r") #'ewwm-reset)`, `(ewwm-input-set-key (kbd "s-&") #'ewwm-launch)` (launch app via `(async-shell-command (read-shell-command "$ "))`), `(ewwm-input-set-key (kbd "s-SPC") #'ewwm-layout-cycle)`, workspace keys `s-1` through `s-9`. **Input mode design decision:** EXWM has line-mode (keys go to Emacs) vs char-mode (keys pass through to X11 client). In our Wayland architecture, the compositor owns all input. Design: (a) **Pass-through mode** (default): compositor forwards all non-grabbed keys to focused Wayland surface. Emacs only receives grabbed keys. (b) **Intercept mode**: compositor sends ALL keys to Emacs first; Emacs decides whether to handle or forward via `(:type :key-forward :key KEY :surface-id ID)`. Pass-through is simpler and avoids latency; intercept enables EXWM char-mode/line-mode equivalent. Implement pass-through first; intercept mode as `(defcustom ewwm-input-intercept-mode nil)`. `(ewwm-input-toggle-intercept)` switches modes for current surface. | 2 | GO: `s-&` launches shell command prompt in Emacs; `s-r` resets to default state; non-grabbed keys reach Wayland client |
| 5.6 | **ewwm-manage.el: surface lifecycle management.** Handle the complete surface lifecycle from creation through destruction, analogous to EXWM's `exwm-manage.el` (833 lines). IPC event handlers: (a) `:surface-created` -> `(ewwm-manage--on-create SURFACE-DATA)`: create buffer (via ewwm-core.el), apply manage rules, assign workspace, trigger layout. Manage rules: `(defcustom ewwm-manage-rules nil "Alist of (PREDICATE . ACTIONS) for surface classification.")`. Predicate: function taking surface plist, returning t/nil. Actions plist: `(:workspace N :floating BOOL :fullscreen BOOL :geometry (:x X :y Y :w W :h H))`. Example: `((lambda (s) (string= (plist-get s :app-id) "org.keepassxc.KeePassXC")) . (:floating t :workspace 3))`. (b) `:surface-destroyed` -> `(ewwm-manage--on-destroy ID)`: clean up buffer, remove from alist, re-layout workspace. (c) `:surface-title-changed` -> update buffer name and mode-line. (d) `:surface-geometry-changed` -> update `ewwm-geometry` buffer-local. Hooks: `ewwm-manage-finish-hook` (after surface managed, like EXWM's `exwm-manage-finish-hook`), `ewwm-manage-close-hook` (before surface closed). Implement `(ewwm-surface-close &optional SURFACE-ID)` interactive: send `:surface-close` IPC. Implement `(ewwm-fullscreen-toggle)`: send `:surface-fullscreen` IPC. | 2 | GO: new surface auto-assigned to workspace via rules; surface closure cleans up buffer; manage hooks fire correctly |
| 5.7 | **ewwm-floating.el: floating window mode.** Implement floating window management for surfaces that should not be tiled (dialogs, popups, KeePassXC). Floating surfaces: not included in layout algorithm, positioned at compositor-reported geometry. Buffer displayed in a dedicated Emacs window (or child frame if available). `(ewwm-floating-toggle &optional SURFACE-ID)`: sends `:surface-float` IPC, compositor removes surface from tiling space and positions at center of output (or last known position). Updates `ewwm-surface-state` buffer-local to `floating`. Emacs side: floating buffers displayed in a popup window via `display-buffer-in-child-frame` (Emacs 29+) or `pop-to-buffer` in a side window. Floating surface list: `(ewwm-floating-list)` returns all floating surface buffers. Auto-float rules: surfaces matching manage rules with `:floating t` are floated on creation. Interactive move: `(ewwm-floating-move)` enters move mode -- compositor tracks pointer and moves surface, ESC or click confirms. Interactive resize: `(ewwm-floating-resize)` similarly. | 1 | GO: KeePassXC auto-floats per manage rule; `(ewwm-floating-toggle)` switches surface between tiled and floating |
| 5.8 | **Focus management: buffer selection drives compositor focus.** Implement bidirectional focus synchronization between Emacs and compositor. Emacs -> Compositor: hook into `buffer-list-update-hook` or `window-selection-change-functions` (Emacs 27+). When user switches to an ewwm-mode buffer (via `C-x b`, `switch-to-buffer`, clicking in window, or any buffer selection mechanism): detect the buffer has `ewwm-surface-id`, send `(:type :surface-focus :id SURFACE-ID)` to compositor. Compositor -> Emacs: on `:surface-focused` event (e.g., user clicks Wayland surface directly in compositor), switch to corresponding ewwm buffer in Emacs via `(switch-to-buffer BUFFER)`. Prevent infinite focus loop: use `ewwm-input--suppress-focus-sync` flag during programmatic buffer switches. Focus follows mouse: when compositor reports focus change from pointer enter, Emacs switches buffer. Focus follows Emacs: when Emacs buffer change detected, compositor moves keyboard focus. `(defcustom ewwm-focus-policy 'follow-emacs)` with values: `'follow-emacs`, `'follow-compositor`, `'manual` (no auto-sync). | 2 | GO: `C-x b *ewwm:foot*` focuses foot terminal in compositor; clicking foot in compositor switches Emacs to foot buffer |
| 5.9 | **ewwm-launch.el: application launcher.** Implement `(ewwm-launch COMMAND)` that starts a Wayland client with correct environment variables (`WAYLAND_DISPLAY`, `XDG_RUNTIME_DIR`). Create process via `(start-process-shell-command)`. Track launched processes in `ewwm-launch--processes` alist. Implement `(ewwm-launch-interactively)` bound to `s-&`: prompt with `(read-shell-command "Launch: ")` with completion from `$PATH`. Implement `(ewwm-launch-known APP-ID)` for quick-launch of known applications. `(defcustom ewwm-launch-favorites '("foot" "qutebrowser" "keepassxc" "emacsclient -c"))`. Favorite launcher: `(ewwm-launch-favorite)` with completing-read from favorites list. Process cleanup: on process exit, log status. Future: integrate with Week 17 Qutebrowser launch for specific URLs. | 1 | GO: `s-&` prompts for command, launches as Wayland client, surface appears and is managed |
| 5.10 | **ewwm.el init and orchestration.** Create `lisp/vr/ewwm.el` as the main entry point (analogous to `exwm.el` which requires and initializes all submodules). `(ewwm-init)`: (a) Start compositor process via `(start-process "ewwm-compositor" "*ewwm-compositor*" "ewwm-compositor" "--backend" BACKEND)`. (b) Wait for IPC socket to appear (poll with timeout). (c) Connect IPC: `(ewwm-ipc-connect)`. (d) Register key grabs for all `ewwm-input--global-keys`. (e) Query initial surface list: `(ewwm-surface-list)` and create buffers for any pre-existing surfaces. (f) Set up event handlers. (g) Apply initial layout. `(defcustom ewwm-compositor-command "ewwm-compositor")`. `(defcustom ewwm-compositor-args '("--backend" "drm"))`. `(ewwm-exit)`: close all surface buffers, disconnect IPC, kill compositor process. `(ewwm-restart)`: exit then init. Mode: `(ewwm-mode)` as global minor mode that activates ewwm when enabled. | 1 | GO: `(ewwm-init)` starts compositor, connects IPC, registers keys; `(ewwm-exit)` cleanly shuts down |
| 5.11 | **Integration testing: full Emacs + compositor workflow.** Write integration test script `test/integration/ewwm-smoke-test.sh`: (a) Start compositor in Winit backend. (b) Start Emacs with `(ewwm-init)`. (c) Launch foot terminal via `(ewwm-launch "foot")`. (d) Verify `*ewwm:foot*` buffer exists in Emacs. (e) Launch second foot. (f) Verify tiling layout applied (two windows in Emacs). (g) Switch workspace via `(ewwm-workspace-switch 2)`. (h) Verify workspace 1 surfaces hidden. (i) Switch back, verify restored. (j) Close surface via `(ewwm-surface-close)`. (k) Verify buffer killed and layout recomputed. ERT tests in `test/ewwm-test.el`: test surface-buffer alist operations, workspace switching state, layout computation (mock surfaces), manage rule matching, mode-line formatting. Target: >= 15 new ERT tests. Cumulative: >= 67 ERT tests. | 2 | GO: integration smoke test passes end-to-end; >= 67 cumulative ERT tests |
| 5.12 | **Application compatibility pre-testing.** Before Week 6 (XWayland), test native Wayland applications under compositor + ewwm: (a) `foot` terminal (native Wayland, primary test client). (b) Alacritty (native Wayland via winit). (c) `weston-terminal` (reference Wayland client). (d) Firefox (native Wayland mode via `MOZ_ENABLE_WAYLAND=1`). Document: which apps launch successfully, rendering correctness, input handling, clipboard integration (wl_data_device), any crashes or protocol errors. Record compositor log output for each app. This pre-testing de-risks Week 6 application compatibility. | 1 | GO: >= 3 native Wayland apps render correctly under compositor; input works; documented |

**Research (parallel):**
- R5.1: **Qutebrowser under Smithay compositor.** Test Qutebrowser with `QT_QPA_PLATFORM=wayland` under our compositor. Qutebrowser uses QtWebEngine (Chromium-based) which supports native Wayland. Verify: window creation, rendering, keyboard input, URL bar interaction, link clicking, scrolling, tab switching. Document any protocol incompatibilities (missing Wayland protocol extensions that Qt expects). Test both native Wayland and XWayland fallback (`QT_QPA_PLATFORM=xcb` with XWayland from Week 6). Record QtWebEngine process management behavior (multiple processes per tab). (1 agent)
- R5.2: **KeePassXC under Smithay compositor.** Test KeePassXC with `QT_QPA_PLATFORM=wayland`. KeePassXC is Qt-based and critical for Week 14 secrets integration. Verify: database unlock dialog, entry search, auto-type triggering, browser extension communication. Key concern: auto-type on Wayland -- KeePassXC auto-type uses platform-specific key injection. On Wayland, KeePassXC may need `ydotool` or compositor-level support. Document auto-type behavior and any workarounds needed. Test D-Bus Secret Service interface (`org.freedesktop.secrets`). (1 agent)
- R5.3: **EXWM user workflow survey.** Survey EXWM configurations from GitHub dotfiles and the EXWM wiki. Identify: most common keybindings, popular manage rules, workspace configurations, simulation key patterns. Extract the "80/20" set of EXWM features that cover most users' needs. Ensure ewwm.el implements these core patterns. Document commonly used hooks: `exwm-manage-finish-hook`, `exwm-update-title-hook`, `exwm-update-class-hook`, `exwm-workspace-switch-hook`. (1 agent)

**Completion Metrics:**
- [ ] Surface-as-buffer model: launching app creates ewwm-mode buffer; closing app kills buffer
- [ ] `ewwm--surface-buffer-alist` correctly tracks all managed surfaces
- [ ] Workspace switching via `s-1` through `s-9` works; window configurations saved/restored
- [ ] Tiling layout: master-stack layout positions surfaces correctly; layout recomputes on surface add/remove
- [ ] Monocle layout: single surface fills frame; buffer switching changes visible surface
- [ ] Focus sync: buffer selection in Emacs focuses compositor surface; compositor focus change updates Emacs buffer
- [ ] Global keys: `s-&` launches app, `s-r` resets, `s-SPC` cycles layout; non-grabbed keys reach client
- [ ] Surface lifecycle: manage rules classify surfaces; hooks fire on manage/unmanage
- [ ] Floating mode: KeePassXC can be floated; float toggle works
- [ ] Mode-line: shows surface title, app-id, workspace number, state
- [ ] `(ewwm-init)` starts compositor and connects; `(ewwm-exit)` cleanly shuts down
- [ ] >= 3 native Wayland apps render and accept input under compositor
- [ ] >= 67 cumulative ERT tests passing

**Gate: GO/NOGO/ASK**
- GO if basic WM operations functional: launch apps, tile them, switch workspaces, close apps, all via Emacs commands
- ASK if input mode (pass-through vs intercept) needs redesign -- EXWM's line-mode/char-mode is a core workflow; if pass-through mode insufficient, prioritize intercept mode implementation
- ASK if Emacs `window-selection-change-functions` hook is too slow for focus sync (> 50ms); consider `post-command-hook` alternative
- NOGO if surface-as-buffer model fundamentally cannot represent Wayland surface lifecycle (e.g., surface IDs are not stable across reconnections)

**Risk Table:**

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Emacs buffer creation overhead slows surface management | Low | Medium | Buffer creation is ~1ms in Emacs; 100 surfaces manageable |
| Focus sync loop (Emacs -> compositor -> Emacs -> ...) | Medium | High | Suppress flag `ewwm-input--suppress-focus-sync` during programmatic switches |
| Layout geometry mismatch between Emacs windows and compositor surfaces | Medium | Medium | Use `window-pixel-edges` (exact pixels) not `window-edges` (columns/rows) |
| Workspace window-configuration restore fails with changed surface count | Medium | Medium | Rebuild layout from scratch if restore fails; save workspace surface list alongside config |
| Native Wayland apps crash due to missing protocol extensions | Medium | Medium | Implement protocols incrementally; document which extensions each app requires |

**Composability Notes:**
- Surface-as-buffer model (5.1) is THE core abstraction consumed by every subsequent week: gaze focus (Week 12) targets buffers, wink (Week 13) switches buffers, KeePassXC (Week 14) auto-types into buffer's surface, Qutebrowser tabs (Week 17) are buffers
- Workspace system (5.3) extended in Week 19 (SSVEP workspace selection)
- Layout engine (5.4) extended in Week 8 (VR 3D layout) and Week 10 (VR window interaction)
- Input system (5.5) extended with gaze input (Week 12), wink input (Week 13), hand input (Week 18), BCI input (Week 19)
- Manage rules (5.6) extended in Week 6 (XWayland surface rules) and Week 14 (KeePassXC auto-float)

**Parallelism Opportunities:**
- Stages 5.1 (core) and 5.2 (mode) must be sequential (mode depends on core)
- Stages 5.3 (workspace), 5.4 (layout), 5.5 (input), 5.6 (manage), 5.7 (floating) can parallelize after core is done
- Stage 5.8 (focus) requires 5.1 (core) and 5.5 (input)
- Stages 5.9 (launcher) and 5.10 (init) can parallelize
- Stage 5.12 (app testing) is independent of Emacs-side development
- All 3 research agents run in parallel with build stages

**Integration Points:**
- Week 2: ewwm stubs (2.4) fleshed out into full implementations; extraction plan (2.8) guides design
- Week 4: IPC client (ewwm-ipc.el) is the communication backbone for all modules
- Week 6: XWayland surfaces enter through same `ewwm-manage--on-create` pathway
- Week 8: VR layout mode extends `ewwm-layout.el` with 3D positioning
- Week 12: gaze-based focus extends `ewwm-input.el` with gaze-driven surface selection
- Week 14: KeePassXC manage rules and auto-type target specific ewwm buffers
- Week 17: Qutebrowser tab-as-buffer extends surface-as-buffer model

---

### Week 6: XWayland & Application Compatibility

**Goal:** Full XWayland integration via Smithay's `X11Wm` type implementing the `XwmHandler` trait; X11 legacy applications render and receive input; wlr-layer-shell protocol for panels and overlays (waybar, mako, rofi); comprehensive application compatibility testing for Qutebrowser (native Wayland via QtWebEngine), KeePassXC (native Wayland + auto-type validation), Emacs pgtk (nested instance as Wayland client), Firefox (native Wayland), terminals (foot, Alacritty); clipboard integration between Wayland and X11 surfaces; layer-shell priority and exclusive zones for panels

**Dependencies:** Week 3 (compositor), Week 4 (IPC), Week 5 (ewwm.el surface management)

| Stage | Task | Agents | Gate |
|-------|------|--------|------|
| 6.1 | **XWayland integration via Smithay X11Wm.** Implement XWayland support in compositor using Smithay's `smithay::xwayland::X11Wm` and `XwmHandler` trait. Startup sequence: (a) Launch XWayland process via `smithay::xwayland::XWayland::new()` which spawns `Xwayland` binary with appropriate flags (`-rootless`, Wayland socket fd). (b) Register XWayland ready callback: when XWayland connects to our Wayland server, create `X11Wm` from the X11 connection. (c) Implement `XwmHandler` trait on `EwwmState`: `fn xwm_state(&mut self, xwm: XwmId) -> &mut X11Wm` -- return mutable reference to X11Wm. `fn new_window(&mut self, xwm: XwmId, window: X11Surface)` -- called when X11 client creates a window; create surface entry in `EwwmState.surfaces` with `is_x11: true` flag; map X11 window to Wayland surface via Smithay's internal mapping. `fn map_window_request(&mut self, xwm: XwmId, window: X11Surface)` -- X11 MapRequest equivalent; configure window geometry, send IPC event `:surface-created` with `(:x11 t)` in payload. `fn destroyed_window(&mut self, xwm: XwmId, window: X11Surface)` -- cleanup, send `:surface-destroyed`. `fn configure_request(&mut self, xwm: XwmId, window: X11Surface, x, y, w, h, ...)` -- handle geometry requests from X11 clients. Handle ICCCM/EWMH properties: `WM_NAME`, `WM_CLASS`, `_NET_WM_NAME`, `_NET_WM_WINDOW_TYPE` -- populate surface's `app_id` and `title` from X11 properties. Set `DISPLAY` environment variable for X11 clients: `DISPLAY=:N` where N is XWayland display number. | 2 | GO: X11 application (`xterm`, `xclock`) renders inside compositor; surface appears in `(ewwm-surface-list)` with `:x11 t` flag |
| 6.2 | **XWayland surface -> ewwm buffer mapping.** Extend `ewwm-manage.el` to handle XWayland surfaces. On `:surface-created` event with `:x11 t`: create ewwm-mode buffer as usual, but set additional buffer-local variables: `ewwm-x11-p t` (boolean flag), `ewwm-x11-class` (from `WM_CLASS`), `ewwm-x11-instance` (from `WM_CLASS` instance name). Mode-line extension: show `[X11]` indicator for XWayland surfaces. Manage rules: support matching on `ewwm-x11-class` for X11-specific classification: `((lambda (s) (and (plist-get s :x11) (string-match "^Firefox" (or (plist-get s :title) "")))) . (:workspace 2))`. Surface naming: prefer `_NET_WM_NAME` over `WM_NAME` (Unicode support). Handle X11 transient windows (dialogs): detect `WM_TRANSIENT_FOR` property, auto-float transient surfaces. Override-redirect windows (menus, tooltips): display without managing (no ewwm buffer created), render above other surfaces. Implement `(ewwm-surface-x11-p &optional BUFFER)` predicate. | 2 | GO: Firefox via XWayland creates `*ewwm:Firefox*` buffer with `[X11]` mode-line indicator; dialogs auto-float |
| 6.3 | **XWayland clipboard bridge.** Implement clipboard synchronization between Wayland and X11 surfaces. Smithay's `X11Wm` handles most of this automatically via `wl_data_device` <-> X11 selection protocol bridging. Verify: (a) Copy text in Wayland terminal, paste in X11 Firefox -> works. (b) Copy text in X11 Firefox, paste in Wayland terminal -> works. (c) Copy text in Emacs (kill ring), paste in X11 application -> works (Emacs pgtk uses Wayland clipboard natively). (d) Primary selection (middle-click paste) works across Wayland/X11 boundary. (e) Rich content (HTML, images) copies correctly between protocols. Debug any clipboard failures by monitoring `wl_data_source`/`wl_data_offer` protocol messages. Document: which clipboard formats are supported, any limitations with primary selection vs clipboard. | 1 | GO: text copies bidirectionally between Wayland and X11 clients; primary selection works |
| 6.4 | **Layer-shell protocol implementation.** Implement `wlr-layer-shell-unstable-v1` protocol in compositor. This protocol allows surfaces to anchor to screen edges (panels, bars, overlays) with exclusive zones (reserved screen area). Use Smithay's `WlrLayerShellState`: `WlrLayerShellState::new::<EwwmState>(&display_handle)`. Implement `WlrLayerShellHandler` trait: `fn shell_state(&mut self) -> &mut WlrLayerShellState`, `fn new_layer_surface(&mut self, surface: LayerSurface, output: Option<WlOutput>, layer: Layer, namespace: String)` -- called when client creates layer surface. Layer ordering (bottom to top): `Background`, `Bottom`, `Top`, `Overlay`. Exclusive zone: when layer surface requests exclusive zone (e.g., waybar at top, 30px), reduce usable output area for tiling layout. Configure layer surface: send size matching output width (for top/bottom) or height (for left/right). Render layer surfaces in correct Z-order: below normal surfaces (Background/Bottom) or above (Top/Overlay). Send exclusive zone information to Emacs via IPC: `(:type :event :event :output-usable-area-changed :geometry (:x 0 :y 30 :w 1920 :h 1050))` so Emacs layout engine respects panel space. | 2 | GO: waybar renders at top of screen; tiling layout respects waybar's exclusive zone; rofi overlay renders above other surfaces |
| 6.5 | **Layer-shell integration with ewwm layout.** Update `ewwm-layout.el` to account for exclusive zones from layer-shell surfaces. On `:output-usable-area-changed` IPC event: store usable area in `ewwm-layout--usable-area` variable. Layout algorithms use usable area (not full output area) when computing window geometries. This ensures tiled surfaces do not overlap with waybar or other panel surfaces. Also: layer surfaces are NOT managed as ewwm buffers (they are ephemeral overlays, not application windows). Do NOT emit `:surface-created` for layer surfaces. Exception: if user explicitly requests layer surface tracking via `(defcustom ewwm-manage-layer-surfaces nil)`. | 1 | GO: tiling layout positions surfaces below waybar; no ewwm buffer created for waybar surface |
| 6.6 | **Qutebrowser comprehensive testing.** Test Qutebrowser under compositor in both modes: (a) **Native Wayland** (`QT_QPA_PLATFORM=wayland`): launch, verify xdg_toplevel creation, test URL bar input (keyboard), test link clicking (pointer), test scrolling, test tab switching (Ctrl+Tab), test hint mode (f key), test downloads, test JavaScript alerts/prompts, test fullscreen video. Record: does Qutebrowser set correct `app_id` ("org.qutebrowser.qutebrowser")? Does title update on page navigation? (b) **XWayland fallback** (`QT_QPA_PLATFORM=xcb`): same test suite. Compare rendering quality, input latency, and feature parity. Document: FIFO IPC location for Qutebrowser command protocol (`$XDG_RUNTIME_DIR/qutebrowser/ipc-*`), used in Week 17. Test Qutebrowser's `--target window` flag for opening in specific windows. Create Qutebrowser config snippet for optimal ewwm integration: `c.window.title_format = "{current_title} - {current_url}"` (provides URL in title for auto-type URL detection in Week 14). | 1 | GO: Qutebrowser functional in native Wayland mode; all core browsing operations work; FIFO IPC location documented |
| 6.7 | **KeePassXC comprehensive testing.** Test KeePassXC under compositor: (a) **Native Wayland** (`QT_QPA_PLATFORM=wayland`): launch, unlock database, search entries, copy password (Ctrl+C with clipboard timeout), auto-type (Ctrl+Shift+A from KeePassXC, or global shortcut). (b) **Auto-type on Wayland:** KeePassXC auto-type uses `xdotool` on X11. On Wayland, KeePassXC 2.7+ attempts `wtype` or `ydotool`. Test: does auto-type work under our compositor? If not, document the failure mode. Workarounds: (i) Use ydotool backend: verify `ydotoold` daemon, `ydotool type` keystroke injection. (ii) Compositor-level key injection (Week 14, stage 14.5) as future solution. (c) **D-Bus Secret Service:** verify `(secrets-list-collections)` from Emacs returns KeePassXC collection when Secret Service integration enabled in KeePassXC settings. (d) **Browser protocol:** verify `keepassxc-proxy` socket exists, used in Week 14. Document: KeePassXC settings required for each integration path. | 1 | GO: KeePassXC unlocks, searches, copies passwords; auto-type status documented; D-Bus Secret Service accessible from Emacs |
| 6.8 | **Emacs pgtk as nested client.** Test running a second Emacs instance (pgtk build) as a Wayland client inside our compositor. This validates that Emacs can be both the WM controller AND a managed application window. Test: (a) `emacsclient -c` creates new frame managed by compositor. (b) Frame receives keyboard and pointer input. (c) Frame title updates correctly. (d) Multiple Emacs frames on different workspaces. (e) Emacs-to-Emacs clipboard (kill ring in controller Emacs -> paste in client Emacs). (f) TRAMP: open remote files from client Emacs. This "Emacs managing Emacs" pattern is a key EXWM workflow (many EXWM users run `emacsclient -c` for additional frames). Document: any pgtk-specific issues (GDK4 Wayland backend quirks), input method handling, frame parameter propagation. | 1 | GO: `emacsclient -c` creates managed Emacs frame; typing, buffer switching, and clipboard work in nested Emacs |
| 6.9 | **Additional application compatibility testing.** Test and document results for: (a) **Firefox** (`MOZ_ENABLE_WAYLAND=1`): native Wayland rendering, WebGL, video playback, downloads, printing. (b) **Alacritty**: native Wayland terminal, scrollback, font rendering, selection. (c) **mpv**: native Wayland video player, fullscreen, hardware-accelerated decode. (d) **GIMP**: native Wayland or XWayland, multi-window layout, tablet input (if applicable). (e) **LibreOffice**: native Wayland or XWayland, multi-document, printing. (f) **Steam**: XWayland (requires Proton/Pressure-Vessel for games). For each: record success/failure, rendering issues, input issues, protocol errors from compositor log. Produce `docs/app-compatibility.md` with status matrix. Classification: "Works" (no issues), "Works with caveats" (minor issues documented), "Broken" (critical issues, workaround needed), "Not tested". | 1 | GO: >= 5 applications tested; >= 3 "Works" or "Works with caveats"; compatibility matrix documented |
| 6.10 | **Foreign-toplevel management protocol.** Implement `wlr-foreign-toplevel-management-unstable-v1` protocol in compositor. This protocol allows external tools (task bars, app switchers) to query and control toplevel windows. Expose: list of toplevels with title, app_id, state (maximized, fullscreen, activated, minimized). Allow external tools to: activate (focus), close, fullscreen, maximize toplevels. This enables waybar's taskbar module and other third-party tools to interact with managed surfaces. Implementation: on surface state change, update foreign-toplevel state. Handle foreign-toplevel requests (activate, close) by delegating to the same handlers as IPC commands. | 1 | GO: waybar taskbar module shows managed surfaces; clicking taskbar entry focuses correct surface |
| 6.11 | **Popup and subsurface handling.** Implement correct handling for xdg_popup (menus, dropdowns, tooltips) and wl_subsurface (toolkit-internal child surfaces). xdg_popup: position relative to parent surface, render above parent in Z-order, grab keyboard focus temporarily, dismiss on click outside. Popups are NOT managed surfaces (no ewwm buffer created). wl_subsurface: child surface synchronized with parent, rendered as part of parent composite. Common in GTK4 and Qt6 for toolbar/statusbar separation. Verify: right-click menus in Qutebrowser/Firefox appear at correct position, dismiss correctly, do not leave ghost surfaces. Verify: Qt combo boxes (dropdown menus in KeePassXC) work correctly. | 1 | GO: right-click menus appear at correct position and dismiss on click outside; Qt combo boxes work |
| 6.12 | **Comprehensive test suite for Week 6.** ERT tests in `test/ewwm-xwayland-test.el`: (a) XWayland surface creates buffer with `ewwm-x11-p` set to t. (b) X11 class name populates `ewwm-x11-class`. (c) Transient X11 windows auto-float. (d) Layer surface does NOT create ewwm buffer. (e) Usable area correctly reduced by exclusive zone. (f) Foreign-toplevel list matches ewwm surface list. Integration test in `test/integration/app-compat-test.sh`: launch foot + one X11 app (xterm), verify both managed, switch workspace, close both, verify cleanup. Rust tests: XWayland handler correctly maps window properties, layer-shell exclusive zone computation, popup positioning. Target: >= 10 new ERT tests. Cumulative: >= 77 ERT tests. | 2 | GO: all tests pass; >= 77 cumulative ERT tests; both Wayland and XWayland surfaces tested |

**Research (parallel):**
- R6.1: **Wayland protocol extension survey.** Catalog all Wayland protocol extensions that common applications expect: `xdg-decoration` (server-side decorations, used by Firefox/Qt apps), `xdg-output-unstable-v1` (output information for multi-monitor), `viewporter` (surface scaling), `linux-dmabuf-unstable-v1` (GPU buffer import, critical for VR in Week 8), `text-input-unstable-v3` (input method, for CJK users), `idle-inhibit-unstable-v1` (prevent screen blank during video). Prioritize: which protocols must be implemented now vs can be deferred. (1 agent)
- R6.2: **KeePassXC Wayland auto-type deep-dive.** Read KeePassXC source code for auto-type on Wayland. Understand: which backends KeePassXC tries (`wtype`, `ydotool`, `xdotool` via XWayland). Determine: can we provide a compositor-level auto-type that KeePassXC can use? Research: `wlr-virtual-keyboard-unstable-v1` protocol as mechanism for third-party key injection. Document findings for Week 14 implementation. (1 agent)
- R6.3: **Server-side decoration (SSD) strategy.** Some applications expect the compositor to draw window decorations (title bar, borders). Qt apps request this via `xdg-decoration` protocol. GTK4 apps draw client-side decorations (CSD) but look different per toolkit. Evaluate: should our compositor provide SSD? If yes, what style? Minimal (thin border + title text) like niri? Or no decorations (rely on Emacs mode-line as "title bar")? Since our WM uses Emacs buffers as the primary interface, visible decorations on compositor surfaces may be redundant. (1 agent)

**Completion Metrics:**
- [ ] XWayland: X11 applications render via XWayland; surfaces managed as ewwm buffers with `[X11]` indicator
- [ ] XWayland: X11 window properties (WM_CLASS, WM_NAME) populate ewwm buffer-local variables
- [ ] XWayland: transient X11 windows auto-float; override-redirect windows render unmanaged
- [ ] Clipboard: text copies bidirectionally between Wayland and X11 clients
- [ ] Layer-shell: waybar renders at screen edge with exclusive zone; tiling respects exclusive zone
- [ ] Qutebrowser: functional in native Wayland mode; FIFO IPC documented for Week 17
- [ ] KeePassXC: database unlock, search, copy work; auto-type status documented; D-Bus Secret Service accessible
- [ ] Emacs pgtk: nested `emacsclient -c` creates managed frame with full functionality
- [ ] Firefox: native Wayland rendering works
- [ ] Foreign-toplevel: waybar taskbar shows managed surfaces
- [ ] Popups: right-click menus and combo boxes work correctly
- [ ] >= 5 applications tested with compatibility matrix documented
- [ ] >= 77 cumulative ERT tests passing

**Gate: GO/NOGO/ASK**
- GO if Qutebrowser + KeePassXC + terminal (foot) + Emacs pgtk all usable for daily work
- ASK if KeePassXC auto-type broken on Wayland (document workaround: ydotool; plan compositor-level fix for Week 14)
- ASK if specific applications require unimplemented Wayland protocol extensions (prioritize based on user impact)
- ASK if server-side decorations needed for application compatibility (implement minimal SSD if required)
- NOGO if XWayland integration fundamentally broken in Smithay (X11 apps unmanageable -- would require alternative X11 bridge)
- NOGO if layer-shell exclusive zones not respected by layout engine (panels overlap tiled windows)

**Risk Table:**

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| XWayland crashes on complex X11 applications | Medium | High | Use Smithay's maintained XWayland integration; test with simple apps first (xterm, xclock) |
| KeePassXC auto-type completely broken on Wayland | High | Medium | Auto-type deferred to Week 14 compositor-level solution; manual copy-paste works as fallback |
| Layer-shell exclusive zone calculation wrong | Medium | Medium | Test with waybar (most common layer-shell client); verify pixel-exact zone calculation |
| Clipboard content lost across protocol boundary | Low | Medium | Smithay handles most clipboard bridging; test with rich content types |
| Qt applications expect unimplemented decoration protocol | Medium | Low | Implement xdg-decoration with minimal SSD; or Qt apps fall back to CSD |

**Composability Notes:**
- XWayland surfaces enter through same ewwm-manage pipeline as native Wayland -- manage rules, workspace assignment, and layout all apply uniformly
- Layer-shell protocol reused in Week 13 (gaze zone overlay) and Week 17 (reader mode overlay)
- Foreign-toplevel protocol enables third-party tools to integrate with our WM
- App compatibility results inform Week 14 (KeePassXC auto-type strategy), Week 17 (Qutebrowser IPC path), and Week 15 (packaging dependencies)
- Clipboard bridge validates the Wayland/X11 interoperability critical for mixed application workflows

**Parallelism Opportunities:**
- Stage 6.1 (XWayland) is the critical prerequisite; most other stages depend on it
- Stages 6.3 (clipboard) and 6.4 (layer-shell) are independent of each other
- Stages 6.6 (Qutebrowser), 6.7 (KeePassXC), 6.8 (Emacs), 6.9 (other apps) are fully independent testing stages
- Stage 6.10 (foreign-toplevel) and 6.11 (popups) are independent protocol implementations
- All 3 research agents run in parallel with build stages

**Integration Points:**
- Week 3: compositor extended with XWayland, layer-shell, foreign-toplevel protocol handlers
- Week 4: IPC extended with `:x11` flag in surface events
- Week 5: ewwm-manage.el extended for XWayland surface classification and transient window handling
- Week 14: KeePassXC auto-type findings from 6.7 directly inform Week 14 implementation strategy
- Week 15: app compatibility results inform NixOS module dependencies (Qutebrowser, KeePassXC, waybar packaging)
- Week 17: Qutebrowser FIFO IPC location from 6.6 consumed by deep integration

---

## Phase 2: VR Foundation (Weeks 7-10)

### Week 7: OpenXR Runtime Integration

**Goal:** Full OpenXR integration via the `openxrs` Rust crate against the Monado runtime; complete session lifecycle management (IDLE -> READY -> SYNCHRONIZED -> VISIBLE -> FOCUSED); frame submission loop (xrWaitFrame -> xrBeginFrame -> xrEndFrame) at 90Hz; swapchain creation with appropriate format negotiation; reference space setup (LOCAL, STAGE, VIEW); headless development mode via `XRT_COMPOSITOR_FORCE_HEADLESS` environment variable; comprehensive frame timing benchmarks ensuring < 11ms per-frame budget; IPC events for VR session state changes to Emacs

**Dependencies:** Week 3 (compositor scaffold), Week 4 (IPC protocol), Week 6 (application compatibility baseline)

| Stage | Task | Agents | Gate |
|-------|------|--------|------|
| 7.1 | **Add `openxrs` crate and OpenXR loader dependency.** Add `openxrs = "0.18"` (or latest) to compositor `Cargo.toml`. The `openxrs` crate provides safe Rust bindings to the OpenXR C API via `openxr-sys`. Configure features: `openxrs/linked` for static linking against `libopenxr_loader.so` (preferred for reproducibility) or `openxrs/loaded` for runtime dynamic loading (preferred for flexibility -- allows swapping Monado for SteamVR without recompile). Add `libopenxr-loader-dev` to Nix flake `devShell` dependencies. Set `XR_RUNTIME_JSON` environment variable in devShell to point to Monado's runtime manifest: `${monado}/share/openxr/1/openxr_monado.json`. Verify `openxrs::Entry::linked()` or `openxrs::Entry::load()` succeeds. Handle loader absence gracefully: if OpenXR loader not found, compositor still starts in 2D-only mode with VR features disabled. Add `vr` feature flag to compositor crate: `[features] vr = ["openxrs"]` so VR can be compiled out entirely for headless/s390x builds (Week 16). Update justfile: `build-compositor-vr` recipe with `cargo build --features vr`. | 1 | GO: `cargo build --features vr` links against openxr-loader; `openxrs::Entry` creation succeeds |
| 7.2 | **OpenXR instance creation with required extensions.** Create `XrInstance` via `openxrs::Entry::create_instance()`. Application info: `application_name = "exwm-vr-compositor"`, `application_version = 1`, `engine_name = "smithay"`, `engine_version = 1`. Required extensions: `XR_KHR_opengl_enable` (for GLES2 texture sharing with Smithay renderer), `XR_KHR_vulkan_enable2` (for future Vulkan rendering path). Optional extensions (enable if available): `XR_EXT_eye_gaze_interaction` (Week 11 eye tracking), `XR_EXT_hand_tracking` (Week 18), `XR_FB_display_refresh_rate` (adaptive refresh for Quest), `XR_MND_headless` (Monado-specific headless extension). Log all available extensions at startup: `instance.enumerate_extensions()`. Store enabled extension set in `VrState` struct for runtime feature checks. Handle extension unavailability gracefully: if eye gaze extension missing, log info and disable gaze features. Create `VrState` struct: `pub struct VrState { instance: openxrs::Instance, system: Option<openxrs::SystemId>, session: Option<openxrs::Session<openxrs::OpenGL>>, session_state: openxrs::SessionState, frame_state: Option<openxrs::FrameState>, enabled_extensions: HashSet<String> }`. | 2 | GO: `XrInstance` created with at least `XR_KHR_opengl_enable`; available extensions logged |
| 7.3 | **System discovery and HMD enumeration.** Call `instance.system(openxrs::FormFactor::HEAD_MOUNTED_DISPLAY)` to get `SystemId`. Handle `ERROR_FORM_FACTOR_UNAVAILABLE`: no HMD connected -- fall back to headless mode (stage 7.7). Query system properties: `instance.system_properties(system_id)` returns `SystemProperties { system_name, vendor_id, graphics_properties: { max_swapchain_image_width, max_swapchain_image_height, max_layer_count }, tracking_properties: { orientation_tracking, position_tracking } }`. Log HMD identification: system name (e.g., "Monado HMD", "Valve Index", "Quest 3"), max resolution, tracking capabilities. Store in `VrState`. Emit IPC event to Emacs: `(:type :event :event :vr-system-discovered :system-name "Valve Index" :max-resolution (:w 2880 :h 1600) :orientation-tracking t :position-tracking t)`. Update `exwm-vr.el` stub to handle this event, storing HMD info in buffer-local variables accessible via `(exwm-vr-hmd-info)`. | 2 | GO: system discovery returns valid `SystemId`; HMD name and capabilities logged; IPC event received by Emacs |
| 7.4 | **OpenXR session creation with OpenGL graphics binding.** Create `XrSession` bound to the compositor's existing EGL/OpenGL context. Graphics binding: construct `openxrs::opengl::SessionCreateInfo` with EGL display (`eglGetCurrentDisplay()`), EGL config, EGL context, and EGL surface from Smithay's GLES2 renderer. Critical: the OpenGL context must be current on the thread calling `xrCreateSession`. Call `instance.create_session::<openxrs::OpenGL>(system_id, &graphics_binding)`. Session begins in `IDLE` state. Register session state change callback: poll `session.poll_event()` in event loop, handle `SessionStateChanged { state, time }`. State machine: `IDLE` (initial) -> `READY` (call `session.begin()` with `VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO`) -> `SYNCHRONIZED` (frames accepted but not displayed) -> `VISIBLE` (frames displayed, input not focused) -> `FOCUSED` (frames displayed, input focused) -> `STOPPING` (call `session.end()`) -> `IDLE` (or `EXITING`). Emit IPC events on each state transition: `(:type :event :event :vr-session-state :state :focused :timestamp 1702345678123)`. Handle `LOSS_PENDING`: runtime is about to be lost, recreate session. Handle `EXITING`: clean shutdown. | 2 | GO: session transitions through IDLE -> READY -> SYNCHRONIZED; state change events arrive in Emacs |
| 7.5 | **Swapchain creation and format negotiation.** Enumerate supported swapchain formats via `session.enumerate_swapchain_formats()`. Select optimal format: prefer `GL_SRGB8_ALPHA8` (correct color space for VR) > `GL_RGBA8` (fallback). Log all available formats. Create swapchain for each eye: `session.create_swapchain(&SwapchainCreateInfo { create_flags: SwapchainCreateFlags::EMPTY, usage_flags: SwapchainUsageFlags::COLOR_ATTACHMENT | SwapchainUsageFlags::SAMPLED, format: selected_format, sample_count: 1, width: recommended_width, height: recommended_height, face_count: 1, array_size: 1, mip_count: 1 })`. Get recommended resolution from `instance.view_configuration_views(system_id, ViewConfigurationType::PRIMARY_STEREO)` which returns per-eye `ViewConfigurationView { recommended_image_rect_width, recommended_image_rect_height, max_image_rect_width, max_image_rect_height, recommended_swapchain_sample_count }`. Typical: Valve Index = 2016x2240 per eye, Quest 3 = 2064x2208 per eye. Enumerate swapchain images: `swapchain.enumerate_images()` returns OpenGL texture IDs. Create framebuffer objects (FBOs) for each swapchain image. Store in `VrState`: `left_swapchain`, `right_swapchain`, `swapchain_images: Vec<(GLuint, GLuint)>`. | 2 | GO: swapchains created with recommended resolution; FBOs bound to swapchain textures |
| 7.6 | **Reference space creation.** Create three reference spaces for different use cases: (a) `LOCAL` space: seated experience, origin at initial head position, Y-up. `session.create_reference_space(ReferenceSpaceType::LOCAL, Posef::IDENTITY)`. Used for desktop-replacement VR (user seated at desk). (b) `STAGE` space: room-scale, origin at floor center of play area. `session.create_reference_space(ReferenceSpaceType::STAGE, Posef::IDENTITY)`. Used for walk-around VR interaction. (c) `VIEW` space: head-locked, moves with user's head. `session.create_reference_space(ReferenceSpaceType::VIEW, Posef::IDENTITY)`. Used for HUD elements (notifications, mode-line overlay). Store all three in `VrState`. Default: `LOCAL` for compositor scene. Allow switching via IPC command: `(:vr-reference-space :type :stage)`. Emit bounds if available: `session.get_reference_space_bounds_rect(stage_space)` returns play area dimensions. Emacs side: `(defcustom exwm-vr-reference-space 'local)` with values `'local`, `'stage`, `'view`. | 1 | GO: all three reference spaces created; LOCAL space provides stable seated origin |
| 7.7 | **Frame loop: xrWaitFrame -> xrBeginFrame -> xrEndFrame.** Integrate OpenXR frame loop into compositor's calloop event loop. Implementation: register a calloop timer source that fires at target refresh rate (default 90Hz = ~11.1ms). Each tick: (a) `frame_state = session.wait_frame()` -- blocks until runtime signals frame should begin; returns `FrameState { predicted_display_time, predicted_display_period, should_render }`. (b) `session.begin_frame()` -- marks frame as in-progress. (c) If `should_render`: acquire swapchain images (`swapchain.acquire_image()`, `swapchain.wait_image(Duration::from_millis(100))`), render scene to swapchain FBOs (placeholder: clear to dark gray), release images (`swapchain.release_image()`). Compose frame layers: `CompositionLayerProjection { space: local_space, views: [left_view, right_view] }` where each view has `sub_image` pointing to swapchain image and `pose`/`fov` from `session.locate_views()`. (d) `session.end_frame(predicted_display_time, &[&projection_layer])`. If `!should_render`: call `session.end_frame(predicted_display_time, &[])` (empty layers). Handle timing: log frame-to-frame interval, detect missed frames (interval > 1.5x predicted_display_period). Frame counter: track total frames, missed frames, FPS. | 2 | GO: frame submission loop running at 90Hz; `xrEndFrame` succeeds without error; missed frame rate < 1% |
| 7.8 | **Headless mode via Monado `XRT_COMPOSITOR_FORCE_HEADLESS`.** Configure Monado for headless operation (no physical HMD required). Set environment variable `XRT_COMPOSITOR_FORCE_HEADLESS=1` which tells Monado to create a simulated HMD. Monado headless HMD characteristics: configurable resolution (default 1920x1080 per eye), configurable refresh rate (default 60Hz), no real display output, no real tracking (returns identity pose). Update justfile: `just vr-mock` recipe sets `XRT_COMPOSITOR_FORCE_HEADLESS=1 XR_RUNTIME_JSON=${MONADO_RUNTIME_JSON}` and launches compositor. Verify: full OpenXR session lifecycle works in headless, frame loop runs, swapchains created, frames submitted. Enable in CI: add `vr-headless-test` CI job that runs `just vr-mock` with a timeout, verifies frame submission count > 100 in 5 seconds. Handle Monado not installed: if `XR_RUNTIME_JSON` points to nonexistent file, skip VR init with warning. | 1 | GO: `just vr-mock` launches compositor in VR mode without physical HMD; > 100 frames submitted in 5 seconds |
| 7.9 | **Session state machine robustness.** Implement comprehensive session state handling for edge cases: (a) Runtime loss (`XR_ERROR_RUNTIME_LOSS`): destroy session and instance, attempt reconnection after 1-second delay, max 3 retries. (b) Session loss (`XR_ERROR_SESSION_LOST`): destroy session, recreate with same instance. (c) Instance loss (`XR_ERROR_INSTANCE_LOST`): full restart of VR subsystem. (d) Graceful shutdown: on compositor exit, transition through STOPPING -> IDLE -> destroy session -> destroy instance. (e) Focus loss (VISIBLE but not FOCUSED): continue rendering but disable VR input processing, show "Focus lost" indicator. (f) Concurrent application: handle case where another OpenXR application steals focus. Implement `VrSessionManager` with `restart()`, `shutdown()`, `handle_state_change()` methods. Log all state transitions with timestamps. Write Rust unit tests for state machine: mock `poll_event` returning various state sequences, verify correct transitions. | 2 | GO: session recovers from simulated runtime loss within 3 seconds; graceful shutdown completes without error |
| 7.10 | **IPC integration for VR status.** Extend compositor IPC to expose VR system information and accept VR commands. New IPC events emitted to Emacs: `(:vr-session-state :state :focused)`, `(:vr-system-discovered :system-name "..." :max-resolution (:w N :h N))`, `(:vr-frame-stats :fps 90 :missed 0 :frame-time-ms 4.2)` (emitted every 5 seconds), `(:vr-reference-space-changed :type :local)`. New IPC commands from Emacs: `(:vr-set-reference-space :type :stage)`, `(:vr-get-status)` (returns current session state, frame stats, HMD info), `(:vr-restart)` (restart VR subsystem). Implement `exwm-vr.el` event handlers: `(defvar exwm-vr-session-state nil)`, `(defvar exwm-vr-hmd-name nil)`, `(defun exwm-vr-status ()` interactive command displaying VR status in minibuffer). Mode-line indicator: `[VR:FOCUSED]` or `[VR:OFF]` or `[VR:HEADLESS]`. | 1 | GO: `M-x exwm-vr-status` shows HMD name, session state, FPS; mode-line indicator updates on state change |
| 7.11 | **Frame timing benchmarks and profiling.** Implement frame timing instrumentation in compositor. Measure per-frame: (a) `xrWaitFrame` return latency (time waiting for runtime). (b) Render time (swapchain acquire -> scene render -> release). (c) `xrEndFrame` submission latency. (d) Total frame time (begin to end). Store rolling statistics: min, max, p50, p95, p99 over last 1000 frames. Expose via IPC on request: `(:vr-get-frame-timing)` returns `(:wait-p50 2.1 :render-p50 3.4 :submit-p50 0.2 :total-p50 5.7 :total-p99 9.8 :missed-pct 0.5)`. Implement `just vr-bench` recipe: run headless for 10 seconds, collect timing, print summary. Assert p99 total frame time < 11ms (for 90Hz target). Log warnings when individual frame exceeds budget. Write results to `benchmark-results.json` for CI regression tracking. Create `exwm-vr-frame-timing` Emacs command showing live timing graph via `chart.el` or text-based sparklines in dedicated buffer. | 1 | GO: p99 frame time < 11ms in headless benchmark; timing data accessible from Emacs |
| 7.12 | **Comprehensive test suite for Week 7.** Rust tests: (a) `test_openxr_entry_creation` -- verify `Entry` loads or reports clean error. (b) `test_instance_creation` -- verify instance creation with expected extensions. (c) `test_session_state_machine` -- feed mock state transitions, verify correct behavior at each state. (d) `test_frame_loop_timing` -- run 100 frames in headless, verify no panics and frame count correct. (e) `test_swapchain_format_selection` -- verify `GL_SRGB8_ALPHA8` preferred over `GL_RGBA8`. (f) `test_reference_space_creation` -- verify all three space types created. (g) `test_session_recovery` -- simulate runtime loss, verify reconnection. ERT tests: (a) `exwm-vr-status` command exists and is interactive. (b) `exwm-vr-session-state` variable exists. (c) `exwm-vr-hmd-name` variable exists. (d) VR IPC event parsing for `:vr-session-state` event. (e) Mode-line indicator format string correct. Target: >= 5 new ERT tests, >= 7 new Rust tests. Cumulative: >= 82 ERT tests. | 2 | GO: all Rust tests pass; all ERT tests pass; >= 82 cumulative ERT tests |

**Research (parallel):**
- R7.1: **KWin VR MR rendering patterns study.** Analyze the KWin VR merge request implementing Qt Quick 3D XR integration. Extract: rendering pipeline (how KWin composites 2D windows into 3D VR scene), texture sharing mechanism (how window textures are imported into VR renderer), frame timing synchronization (how KWin aligns Wayland compositor frame with OpenXR frame), input routing (how 2D Wayland pointer events are generated from 3D VR interaction). Document applicable patterns in `docs/research/kwin-vr-patterns.md`. Compare KWin approach (Qt Quick 3D) with our approach (raw OpenGL/Smithay). (2 agents)
- R7.2: **Monado HMD compatibility testing.** Test Monado with available HMDs: (a) Valve Index via USB/DisplayPort -- verify Monado `xrt_device` driver loads, tracking functional, display output correct. (b) Quest 3 via WiVRn -- install `wivrn-server`, pair Quest 3, verify Monado receives tracking and submits frames over network. (c) Pimax headsets via Monado pimax driver (if available). Document for each HMD: setup steps, Monado driver name, tracking quality, display resolution, refresh rates, any issues. Produce `docs/research/hmd-compatibility.md`. (1 agent)
- R7.3: **OpenXR extension ecosystem survey.** Catalog all OpenXR extensions relevant to our project beyond the core set. Priority extensions: `XR_FB_passthrough` (camera passthrough for AR mode), `XR_VARJO_foveated_rendering` (foveated rendering for Varjo headsets), `XR_EXT_performance_settings` (runtime performance hints), `XR_KHR_composition_layer_cylinder` (cylindrical layer for curved virtual monitors, Week 8), `XR_KHR_composition_layer_equirect` (360-degree backgrounds). For each: document which runtimes support it, whether `openxrs` crate exposes it, and which week it would be consumed. (1 agent)
- R7.4: **Frame timing analysis: Monado vs SteamVR.** Measure and compare frame submission latency between Monado and SteamVR (via Proton/OpenXR layer). Test with identical workload (empty scene, 90Hz target). Determine if Monado's open-source compositor introduces additional latency. Benchmark motion-to-photon latency if measurement hardware available. (1 agent)

**Completion Metrics:**
- [ ] `openxrs` crate links against OpenXR loader and creates `XrInstance` with required extensions
- [ ] OpenXR session lifecycle works: IDLE -> READY -> SYNCHRONIZED -> VISIBLE -> FOCUSED transitions verified
- [ ] Frame submission loop runs at target refresh rate (90Hz headless, adaptive for real HMDs)
- [ ] Swapchains created with recommended per-eye resolution and `GL_SRGB8_ALPHA8` format
- [ ] All three reference spaces (LOCAL, STAGE, VIEW) created successfully
- [ ] Headless mode works: `just vr-mock` runs full VR session without physical HMD
- [ ] CI headless test: > 100 frames submitted in 5 seconds
- [ ] Frame timing benchmark: p99 total frame time < 11ms in headless
- [ ] Session recovery: compositor recovers from simulated runtime loss within 3 seconds
- [ ] IPC: VR session state changes arrive in Emacs; `M-x exwm-vr-status` shows live info
- [ ] Mode-line indicator shows current VR session state
- [ ] Frame timing accessible from Emacs via `exwm-vr-frame-timing`
- [ ] >= 82 cumulative ERT tests passing
- [ ] >= 7 new Rust tests passing

**Gate: GO/NOGO/ASK**
- GO if frame submission stable at 90Hz in headless AND session lifecycle transitions correctly AND IPC events arrive in Emacs
- ASK if Monado headless not available on CI architecture (use pure mock -- implement fake `openxrs::Entry` that returns synthetic data)
- ASK if `openxrs` crate missing bindings for needed extensions (evaluate contributing upstream or using raw `openxr-sys` FFI)
- ASK if OpenGL graphics binding fails due to EGL context threading issues (investigate `EGL_KHR_surfaceless_context` or dedicated render thread)
- NOGO if `openxrs` crate fundamentally incompatible with Smithay's GLES2 renderer (would need to evaluate Vulkan-only path or alternative OpenXR bindings)
- NOGO if Monado cannot maintain < 20ms frame time even in headless (performance ceiling too low for VR)

**Risk Table:**

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| `openxrs` crate API breaking changes | Medium | Medium | Pin to specific version; vendor `openxrs` if upstream unstable |
| EGL context conflict between Smithay renderer and OpenXR session | Medium | High | Dedicate separate EGL context for OpenXR; share textures via EGL image export |
| Monado headless mode not representative of real HMD behavior | Low | Medium | Validate against real HMD in R7.2; headless is for CI only |
| OpenXR loader not packaged in Nix for all platforms | Low | Medium | Use `openxrs/loaded` feature for runtime loading; bundle loader in flake |
| Frame timing regression on CI runners (shared hardware) | Medium | Low | Use relative benchmarks (frame-to-frame jitter) not absolute timing in CI |

**Composability Notes:**
- `VrState` struct established here is extended in every subsequent VR week (8-12, 18)
- Swapchain images from 7.5 are the render targets for Week 8 scene rendering
- Reference spaces from 7.6 used by Week 10 (interaction), Week 11 (gaze), Week 18 (hand tracking)
- Session state IPC from 7.10 consumed by Emacs for all VR-aware UI (mode-line, status)
- Frame timing infrastructure from 7.11 feeds Week 16 per-architecture profiling and Week 20 release benchmarks
- Headless mode from 7.8 enables CI testing for all subsequent VR weeks

**Parallelism Opportunities:**
- Stages 7.1 (crate setup) and 7.2 (instance creation) are sequential prerequisites
- Stages 7.5 (swapchain) and 7.6 (reference spaces) are independent after session creation (7.4)
- Stages 7.8 (headless) and 7.9 (robustness) are independent
- Stages 7.10 (IPC) and 7.11 (benchmarks) are independent
- All 4 research agents run in parallel with build stages

**Integration Points:**
- Week 3: compositor calloop event loop extended with OpenXR frame timer source
- Week 4: IPC protocol extended with VR events and commands
- Week 8: swapchains and reference spaces consumed for scene rendering
- Week 9: session used with DRM lease for HMD display output
- Week 10: reference spaces provide coordinate system for VR interaction
- Week 11: `XR_EXT_eye_gaze_interaction` extension availability checked here, consumed there
- Week 15: Monado service configuration, `XR_RUNTIME_JSON` environment propagation
- Week 16: headless mode enables s390x and CI testing without GPU
- Week 18: OpenXR action system builds on session established here

---

### Week 8: VR Scene Rendering

**Goal:** Full DMA-BUF zero-copy texture import pipeline (Smithay `GraphicsBuffer` -> `DmaBufAttributes` -> `EGLImageKHR` -> GL texture); 3D scene graph with textured quads positioned in VR space; head-tracked camera derived from OpenXR view pose with correct projection matrices per eye; stereo rendering to left/right swapchain images; cylindrical projection for curved virtual monitors maximizing text readability; configurable pixels-per-unit (PPU) for surface sizing; multi-surface Z-ordering and layout in 3D; IPC for surface placement commands from Emacs

**Dependencies:** Week 7 (OpenXR session, swapchains, reference spaces), Week 5 (ewwm.el surface management), Week 3 (Smithay compositor with DMA-BUF support)

| Stage | Task | Agents | Gate |
|-------|------|--------|------|
| 8.1 | **DMA-BUF texture import pipeline.** Implement zero-copy texture import from Wayland surface buffers into OpenGL textures usable by the VR renderer. Pipeline: (a) Wayland client submits buffer via `wl_surface.attach` + `commit`. Smithay's `DmabufHandler` receives `linux-dmabuf-unstable-v1` buffer with `DmaBufAttributes { planes: Vec<Plane { fd, offset, stride, modifier }>, width, height, format }`. (b) Import into EGL: call `eglCreateImageKHR(display, EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, NULL, attribs)` where `attribs` encode fd, offset, stride, and DRM format modifier per plane. Handle multi-plane formats (NV12 for video surfaces). (c) Bind EGL image to GL texture: `glGenTextures(1, &tex)`, `glBindTexture(GL_TEXTURE_2D, tex)`, `glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, egl_image)`. Set texture parameters: `GL_TEXTURE_MIN_FILTER = GL_LINEAR`, `GL_TEXTURE_MAG_FILTER = GL_LINEAR`, `GL_TEXTURE_WRAP_S/T = GL_CLAMP_TO_EDGE`. (d) Store mapping: `surface_id -> GLuint texture` in `VrSceneState`. Handle buffer replacement: on new `wl_surface.commit`, destroy old EGL image and texture, import new one. Handle SHM buffers as fallback: upload via `glTexImage2D` (not zero-copy, but works for software-rendered clients). Cache textures: only re-import on `wl_surface.commit` with new buffer, not every frame. | 2 | GO: Wayland surface rendered by foot terminal visible as GL texture; zero-copy path verified via `DMA_BUF` debug log |
| 8.2 | **Scene graph data structure.** Implement `VrScene` struct containing positioned 3D elements. Core type: `SceneNode { surface_id: Option<u32>, transform: Transform3D, geometry: Geometry, texture: Option<GLuint>, children: Vec<SceneNode>, visible: bool }`. `Transform3D`: position (`Vec3`), rotation (`Quat`), scale (`Vec3`). `Geometry` enum: `Quad { width: f32, height: f32 }`, `Cylinder { radius: f32, arc_angle: f32, height: f32, segments: u32 }`, `Custom { vertices: Vec<Vertex>, indices: Vec<u16> }`. Scene root node at origin of LOCAL reference space. Default layout: surfaces arranged in a horizontal arc at 2m distance, 170-degree field. Each managed Wayland surface gets a `SceneNode` with `Quad` geometry. Surface dimensions in meters: `width_m = surface_width_px / ppu`, `height_m = surface_height_px / ppu`. Maintain scene graph traversal order for rendering: back-to-front for transparency, or use depth buffer. Implement `scene.add_surface(id, transform)`, `scene.remove_surface(id)`, `scene.update_texture(id, tex)`, `scene.set_transform(id, transform)`. | 2 | GO: scene graph holds 5+ surfaces with correct transforms; traversal produces correct render order |
| 8.3 | **Quad mesh generation and rendering.** Generate quad mesh for flat surface display: 4 vertices forming a rectangle centered at origin. Vertex format: `position: Vec3, texcoord: Vec2, normal: Vec3`. Vertices: `(-0.5w, 0.5h, 0)`, `(0.5w, 0.5h, 0)`, `(0.5w, -0.5h, 0)`, `(-0.5w, -0.5h, 0)`. Indices: `[0,1,2, 0,2,3]`. Upload to GPU: `glGenBuffers`, `glBufferData` for VBO and IBO. GLES2 shader program for textured quads: vertex shader applies `model * view * projection` matrix, fragment shader samples texture with `texture2D(surface_tex, v_texcoord)`. Shader uniform locations: `u_mvp` (mat4), `u_texture` (sampler2D), `u_alpha` (float, for transparency effects), `u_tint` (vec4, for focus indication). Render loop: for each visible `SceneNode` with `Quad` geometry, bind texture, set MVP uniform, draw quad. Handle aspect ratio: quad dimensions match surface pixel aspect ratio scaled by PPU. | 2 | GO: textured quad renders with correct aspect ratio; surface content visible on quad in VR scene |
| 8.4 | **Head-tracked camera from OpenXR view pose.** Each frame, query head pose: `session.locate_views(ViewConfigurationType::PRIMARY_STEREO, frame_state.predicted_display_time, local_space)` returns `Vec<View { pose: Posef { orientation: Quaternionf, position: Vector3f }, fov: Fovf { angle_left, angle_right, angle_up, angle_down } }>` with two entries (left eye, right eye). Convert `Posef` to view matrix: `view_matrix = inverse(pose_to_mat4(pose))`. Convert `Fovf` to asymmetric projection matrix: `proj_matrix = make_projection_fov(fov.angle_left, fov.angle_right, fov.angle_up, fov.angle_down, near=0.05, far=100.0)` using tangent-based asymmetric frustum. OpenXR uses right-handed coordinate system with Y-up, which matches OpenGL conventions. Store per-eye view and projection matrices in `VrFrameData { left_view: Mat4, left_proj: Mat4, right_view: Mat4, right_proj: Mat4, head_pose: Posef }`. Head pose also used for gaze ray origin (Week 10). Smooth tracking: OpenXR runtime handles prediction; no client-side smoothing needed. Validate: print head position on frame 1 to verify identity-ish pose in headless (Monado headless returns origin). | 2 | GO: scene rendered from correct viewpoint; head rotation changes visible perspective; translation moves through scene |
| 8.5 | **Stereo rendering to swapchain images.** Render scene twice per frame: once for left eye, once for right eye. Per eye: (a) Acquire swapchain image: `swapchain.acquire_image()` returns image index. (b) Wait for image ready: `swapchain.wait_image(timeout)`. (c) Bind corresponding FBO: `glBindFramebuffer(GL_FRAMEBUFFER, fbo[eye][image_index])`. (d) Set viewport to full swapchain resolution: `glViewport(0, 0, width, height)`. (e) Clear with background color (dark gray, configurable via `defcustom`). (f) Render scene graph with eye-specific view and projection matrices. (g) Release image: `swapchain.release_image()`. Compose `CompositionLayerProjection` with both eye views for `session.end_frame()`. Each `CompositionLayerProjectionView` has: `pose` from `locate_views`, `fov` from `locate_views`, `sub_image` referencing swapchain and image rect. Verify correct eye separation: objects at different depths should produce parallax. Performance budget: both eyes must render within ~11ms total (90Hz). Optimization: sort scene nodes front-to-back for early depth rejection; minimize state changes (batch by texture). | 1 | GO: stereoscopic rendering produces correct depth perception; IPD (inter-pupillary distance) matches OpenXR system |
| 8.6 | **Cylindrical projection for curved virtual monitors.** Implement cylindrical mesh for text-heavy surfaces (Emacs, terminals). Generate cylinder segment mesh: `segments = 64`, arc from `-arc_angle/2` to `+arc_angle/2`, radius = configurable distance (default 2.0m). Vertices: for each segment column `i` and row `j` (2 rows: top and bottom): `x = radius * sin(angle_i)`, `z = -radius * cos(angle_i)`, `y = row_height * j`. Texture coordinates: `u = i / segments`, `v = j`. Normal: pointing inward toward viewer (`-sin(angle_i), 0, cos(angle_i)`). Default arc angle: 90 degrees for single surface, up to 170 degrees for panoramic multi-surface layout. Cylindrical projection improves text readability because all text is equidistant from the viewer's eye, eliminating peripheral distortion that makes flat quads unreadable at edges. Render using same shader as flat quads (only mesh differs). `(defcustom exwm-vr-surface-projection 'cylinder)` with values `'flat`, `'cylinder`. Per-surface override via IPC: `(:vr-set-surface-projection :surface-id 42 :projection :flat)`. | 1 | GO: text on cylindrical surface equally sharp at center and edges; 14pt font readable at 2m virtual distance |
| 8.7 | **PPU (pixels per unit) configuration and surface sizing.** Define PPU as the mapping from surface pixel dimensions to VR world-space meters. Default PPU: 1000 pixels per meter (1px = 1mm in VR space). A 1920x1080 surface becomes 1.92m x 1.08m in VR -- large enough to read at 2m distance. `(defcustom exwm-vr-ppu 1000 "Pixels per unit (meter) for VR surface sizing.")`. IPC command: `(:vr-set-ppu :ppu 1500)` for higher density (smaller surfaces, sharper text if HMD resolution allows). Per-surface PPU override: `(:vr-set-surface-ppu :surface-id 42 :ppu 800)` for individual surface scaling. Calculate effective angular resolution: at 2m distance with PPU=1000, each pixel subtends `atan(0.001/2.0) = 0.0286 degrees = 1.72 arcmin`. For comparison, human visual acuity limit is ~1 arcmin, so PPU=1000 at 2m is near-readable. For comfortable text reading, target ~3 arcmin per pixel (PPU=600 at 2m or PPU=1000 at 1.2m). Document recommended PPU/distance combinations for various HMD resolutions (Valve Index: 14.5 PPD, Quest 3: 25 PPD). Emacs side: `(defun exwm-vr-zoom-in ()` increases PPU by 10%, `(defun exwm-vr-zoom-out ()` decreases PPU by 10%). | 1 | GO: changing PPU via Emacs command resizes surfaces in VR; recommended PPU produces readable text |
| 8.8 | **Multi-surface layout in 3D space.** Implement default surface arrangement strategies. Layout modes: (a) `arc` (default): surfaces placed along a horizontal arc at uniform distance, centered on viewer forward direction. Spacing: 5-degree gap between adjacent surfaces. Primary surface (Emacs) centered, secondary surfaces to sides. (b) `grid`: surfaces in a 2D grid plane at fixed distance (for many small windows). Rows and columns auto-computed from surface count. (c) `stack`: surfaces layered at same position with slight Z-offset (tab-like, switch by cycling). (d) `freeform`: user manually positions each surface (Week 10 grab/move). Store layout mode in `VrScene`. On surface add/remove, recompute layout. IPC: `(:vr-set-layout :mode :arc)`, `(:vr-set-layout :mode :grid :columns 3)`. Emacs: `(defcustom exwm-vr-layout 'arc)`. Smooth animation: on layout change, interpolate surface positions over 300ms using lerp/slerp. | 2 | GO: surfaces automatically arranged in arc; switching layout mode smoothly rearranges; new surface insertion triggers re-layout |
| 8.9 | **Surface focus indication and Z-ordering.** Visually distinguish the focused surface in VR. Focus effects: (a) Subtle glow border: render 2px border around focused surface quad using separate draw call with tint color (default: blue, `defcustom exwm-vr-focus-color "#4444ff"`). (b) Slight pull-forward: focused surface moves 0.1m closer to viewer (configurable). (c) Dim unfocused: unfocused surfaces rendered at 80% alpha (configurable via `defcustom exwm-vr-unfocus-dim 0.8`). Z-ordering: focused surface always renders last (on top) in depth-disabled pass, or use stencil buffer for correct occlusion. Handle focus change from Emacs: on `(:surface-focused :surface-id 42)` IPC event, update `VrScene` focus state, trigger animation (300ms transition of pull-forward and dimming). Handle focus change from VR (Week 10 head-gaze): send `(:vr-focus-request :surface-id 42)` to Emacs, Emacs confirms with `(:surface-focused)`. | 1 | GO: focused surface visually distinct from unfocused; focus change animates smoothly |
| 8.10 | **VR background environment.** Render a background behind all surfaces. Options: (a) Solid color: configurable via `(defcustom exwm-vr-background-color "#1a1a2e")`. (b) Gradient: top-to-bottom or radial gradient. (c) Grid floor: infinite grid plane at Y=0 for spatial reference (like a holodeck). (d) Passthrough: camera feed from HMD passthrough cameras (requires `XR_FB_passthrough`, future). Default: dark solid color matching Emacs theme background. Grid floor implementation: render large quad at Y=-1m with grid shader (fragment shader computes grid lines from world-space XZ coordinates, anti-aliased). Grid helps users orient in 3D space and judge surface distances. `(defcustom exwm-vr-background 'dark)` with values `'dark`, `'gradient`, `'grid`, `'passthrough`. | 1 | GO: background renders behind all surfaces; grid floor provides spatial reference |
| 8.11 | **IPC commands for scene manipulation.** Extend IPC with scene control commands from Emacs. New commands: `(:vr-set-surface-transform :surface-id 42 :position (:x 0.0 :y 1.5 :z -2.0) :rotation (:yaw 0.0 :pitch 0.0 :roll 0.0))`, `(:vr-set-surface-projection :surface-id 42 :projection :cylinder :arc-angle 90)`, `(:vr-set-surface-ppu :surface-id 42 :ppu 1200)`, `(:vr-set-layout :mode :arc)`, `(:vr-set-background :type :grid)`, `(:vr-get-scene)` (returns full scene state: all surface positions, projections, sizes). Emacs side: implement `ewwm-vr-scene.el` with commands `(exwm-vr-surface-position SURFACE-ID X Y Z)`, `(exwm-vr-surface-rotate SURFACE-ID YAW PITCH ROLL)`, `(exwm-vr-scene-dump)` (displays scene state in a dedicated buffer). Save/restore scene layouts: `(exwm-vr-scene-save NAME)` writes to `~/.config/exwm-vr/scenes/NAME.el`, `(exwm-vr-scene-restore NAME)` reloads positions. | 1 | GO: Emacs commands reposition surfaces in VR; scene save/restore round-trips correctly |
| 8.12 | **Performance optimization for multi-surface rendering.** Profile rendering with 5+ active surfaces. Optimizations: (a) Texture atlas: if multiple small surfaces, pack textures into atlas to reduce bind calls (deferred -- complexity vs benefit). (b) Frustum culling: skip rendering surfaces outside the current eye frustum. Compute surface bounding sphere, test against frustum planes. (c) LOD: for distant surfaces, render at reduced resolution (mipmap). (d) Render order: sort opaque surfaces front-to-back (early Z rejection), transparent surfaces back-to-front. (e) Batch state changes: group surfaces by shader, then by texture. (f) Skip unchanged surfaces: if surface content hasn't changed since last frame (no `wl_surface.commit`), reuse previous texture without re-import. Benchmark: measure frame time with 1, 5, 10, 20 surfaces. Target: p99 < 11ms with 10 active surfaces on AMD radeonsi. Log frame time breakdown: texture import time, scene traversal time, draw call time, swap time. | 2 | GO: p99 frame time < 11ms with 10 active surfaces; frustum culling reduces draw calls by > 30% for off-screen surfaces |
| 8.13 | **Test suite for Week 8.** Rust tests: (a) `test_dma_buf_import` -- mock DMA-BUF attributes, verify EGL image creation path (or skip on headless with clear error). (b) `test_scene_graph_add_remove` -- add 5 surfaces, remove 2, verify graph integrity. (c) `test_quad_mesh_generation` -- verify vertex positions and UVs for known dimensions. (d) `test_cylinder_mesh_generation` -- verify vertex count matches segment count, normals point inward. (e) `test_layout_arc` -- verify 3 surfaces placed with correct angular spacing. (f) `test_layout_grid` -- verify grid dimensions match surface count and column config. (g) `test_ppu_calculation` -- verify 1920px surface at PPU=1000 produces 1.92m quad. (h) `test_frustum_culling` -- surface behind camera not in render list. ERT tests: (a) `exwm-vr-ppu` defcustom exists with default 1000. (b) `exwm-vr-layout` defcustom exists. (c) `exwm-vr-surface-projection` defcustom exists. (d) VR scene IPC command parsing. (e) Scene save/restore file format. Target: >= 8 new Rust tests, >= 5 new ERT tests. Cumulative: >= 87 ERT tests. | 2 | GO: all tests pass; >= 87 cumulative ERT tests |

**Research (parallel):**
- R8.1: **Text readability benchmark at various PPU/distance combinations.** Systematically test text readability in VR with variables: font size (10pt, 12pt, 14pt, 16pt, 18pt), PPU (600, 800, 1000, 1200, 1500), distance (1.0m, 1.5m, 2.0m, 2.5m, 3.0m), HMD resolution (simulated Index at 14.5 PPD, Quest 3 at 25 PPD). Metric: minimum font size at which randomly selected lowercase letters are correctly identified > 95% of the time. Compute effective angular size for each combination. Produce recommendation matrix: for each HMD, recommended PPU and distance for "coding" (small font, many characters) and "reading" (larger font, flowing text) use cases. (2 agents)
- R8.2: **Foveated rendering research for future eye-tracking optimization.** Study fixed foveated rendering (render center at full resolution, periphery at reduced resolution) and eye-tracked foveated rendering (render at full resolution only where user is looking). Techniques: multi-resolution shading (NVIDIA VRS), radial density masking, reconstruction filters. Assess Monado/OpenXR support: `XR_VARJO_foveated_rendering`, `XR_FB_foveation`. Estimate performance savings: typical 30-50% reduction in fragment shader work. Plan integration point: Week 11 eye tracking provides gaze direction, foveated rendering uses it to set high-resolution region. Document in `docs/research/foveated-rendering.md`. (1 agent)
- R8.3: **DMA-BUF format compatibility survey.** Test which DRM formats and modifiers work for EGL import across GPU drivers: `DRM_FORMAT_ARGB8888`, `DRM_FORMAT_XRGB8888`, `DRM_FORMAT_NV12` (video), `DRM_FORMAT_ABGR8888` (some Wayland clients). Test modifiers: `DRM_FORMAT_MOD_LINEAR`, `DRM_FORMAT_MOD_INVALID` (implicit modifier), vendor-specific tiled formats (Intel Y-tiled, AMD DCC). Document which format/modifier combinations work on AMD radeonsi, Intel iris, NVIDIA. Identify formats that require format conversion (performance penalty). (1 agent)
- R8.4: **Cylindrical vs spherical vs equirectangular projection comparison.** Compare projection types for virtual monitor readability: (a) Flat plane -- simplest, distortion at edges. (b) Cylindrical -- equal horizontal distance, vertical remains flat. (c) Spherical -- equal distance in all directions, but vertical curvature may be disorienting. (d) Equirectangular -- 360-degree wrap, overkill for single surface. Assess visual comfort, text readability, and implementation complexity for each. Recommendation: cylinder is standard in Immersed, Virtual Desktop, Meta Horizon Workrooms. (1 agent)

**Completion Metrics:**
- [ ] DMA-BUF zero-copy texture import: Wayland surfaces visible as textured quads in VR scene
- [ ] SHM fallback: software-rendered clients (legacy apps) also visible via texture upload
- [ ] Scene graph: surfaces correctly positioned with transforms, add/remove works
- [ ] Head tracking: scene rendered from correct viewpoint for both eyes
- [ ] Stereo rendering: correct depth perception with IPD from OpenXR system
- [ ] Cylindrical projection: text equally sharp at center and edges of curved surface
- [ ] Text readable at 14pt font at default distance with recommended PPU
- [ ] PPU configurable from Emacs; zoom in/out commands work
- [ ] Multi-surface layout: arc, grid, stack modes functional
- [ ] Focus indication: focused surface visually distinct with glow and pull-forward
- [ ] Background: dark solid and grid floor modes rendering
- [ ] Scene manipulation: Emacs commands reposition surfaces; scene save/restore works
- [ ] Performance: p99 frame time < 11ms with 10 active surfaces
- [ ] >= 87 cumulative ERT tests passing
- [ ] >= 8 new Rust tests passing

**Gate: GO/NOGO/ASK**
- GO if text readable at 14pt AND frame timing met with 10 surfaces AND stereo rendering produces correct depth
- ASK if DMA-BUF import fails on specific GPU driver (implement SHM upload fallback for that driver; document as known limitation)
- ASK if GPU performance insufficient for 10 surfaces (try reducing resolution, implementing LOD, or bringing foveated rendering forward from future work)
- ASK if cylindrical projection causes motion sickness in user testing (offer flat projection as default with cylinder opt-in)
- NOGO if DMA-BUF import fails on ALL target GPUs (fundamental blocker for zero-copy rendering pipeline)
- NOGO if stereo rendering produces incorrect IPD causing eye strain (investigate OpenXR view pose accuracy)

**Risk Table:**

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| DMA-BUF format/modifier incompatibility across GPUs | Medium | High | Implement format negotiation; fall back to SHM upload; test on multiple GPU drivers (R8.3) |
| Cylindrical mesh UV mapping produces text distortion | Low | Medium | Use equidistant UV mapping; verify with character recognition test |
| Frame time exceeds budget with many surfaces | Medium | Medium | Frustum culling, skip unchanged textures, LOD for distant surfaces |
| EGL image sharing between Smithay GL context and VR GL context | Medium | High | Use shared EGL context or `EGL_KHR_image_base` cross-context sharing |
| Stereo rendering doubles render cost beyond budget | Low | Medium | Single-pass stereo via instanced rendering or multiview extension (`GL_OVR_multiview2`) |

**Composability Notes:**
- DMA-BUF texture pipeline from 8.1 is the foundation for ALL subsequent VR rendering (weeks 9-12, 17, 18)
- Scene graph from 8.2 extended in Week 10 (interactive surface movement), Week 13 (gaze zone overlays), Week 18 (hand/controller rendering)
- Cylindrical projection from 8.6 reused in Week 17 (reader mode VR rendering)
- PPU configuration from 8.7 affects Week 11 (gaze accuracy relative to pixel density) and Week 12 (dwell target size)
- Layout modes from 8.8 driven by Emacs workspace logic from Week 5
- Scene save/restore from 8.11 integrates with home-manager config (Week 15)

**Parallelism Opportunities:**
- Stage 8.1 (DMA-BUF import) is the critical prerequisite; 8.2 and 8.3 depend on it
- Stages 8.3 (quad mesh) and 8.6 (cylindrical mesh) are independent geometry tasks
- Stages 8.4 (head tracking) and 8.5 (stereo) are sequential
- Stages 8.7 (PPU), 8.8 (layout), 8.9 (focus), 8.10 (background) are largely independent
- Stages 8.11 (IPC) and 8.12 (optimization) are independent
- All 4 research agents run in parallel with build stages

**Integration Points:**
- Week 7: OpenXR swapchains are render targets; view poses provide camera matrices
- Week 5: ewwm.el surface list drives which surfaces appear in scene graph
- Week 9: DRM lease provides HMD display output for the rendered scene
- Week 10: scene graph surfaces are the interaction targets for head-gaze ray
- Week 11: gaze data overlaid on scene; foveated rendering uses gaze for LOD
- Week 13: gaze zone overlays rendered as additional scene nodes
- Week 15: PPU and layout preferences stored in home-manager config
- Week 17: qutebrowser reader mode uses cylindrical projection

---

### Week 9: DRM Lease & HMD Display

**Goal:** Full `wp_drm_lease_v1` Wayland protocol implementation enabling the compositor to advertise non-desktop DRM connectors (HMD displays) for lease to OpenXR runtimes; complete lease lifecycle management (advertise -> request -> grant -> revoke); Valve Index tethered HMD via Monado's native driver; Quest 3 wireless VR via WiVRn network streaming; desktop monitor fallback rendering for development without HMD; robust hotplug handling for HMD connect/disconnect; DRM connector enumeration and non-desktop detection; IPC events for HMD state changes to Emacs

**Dependencies:** Week 7 (OpenXR session), Week 8 (VR scene rendering), Week 3 (compositor DRM backend)

| Stage | Task | Agents | Gate |
|-------|------|--------|------|
| 9.1 | **Enumerate DRM connectors and identify non-desktop outputs.** Extend compositor's DRM backend to detect VR headset connectors. DRM connectors with the `non-desktop` property set to `1` are VR/AR headsets that should NOT be used as regular monitor outputs. Enumeration: iterate `DrmDevice::connectors()`, for each connector check `connector.property_value("non-desktop")`. Typical non-desktop connectors: Valve Index appears as `DP-N` with `non-desktop=1`, HTC Vive as `HDMI-N` with `non-desktop=1`. Store non-desktop connectors in `VrState::hmd_connectors: Vec<DrmConnector>` with metadata: connector id, connector type (DP/HDMI/USB-C), display mode list (resolution/refresh combos), EDID info (manufacturer, model, serial). Log discovery: `"Found non-desktop output: DP-3 (Valve Index, 2880x1600@144Hz)"`. Filter desktop connectors separately for normal compositor output. Handle multi-HMD: if multiple non-desktop connectors found, select primary based on preferred mode resolution (highest = primary). Emit IPC: `(:type :event :event :hmd-detected :connector "DP-3" :name "Valve Index" :resolution (:w 2880 :h 1600) :refresh-rates (90 120 144))`. | 2 | GO: non-desktop connectors correctly identified and separated from desktop outputs; HMD metadata logged |
| 9.2 | **Implement `wp_drm_lease_v1` protocol -- lease device and connector advertisement.** Implement the `wp_drm_lease_device_v1` global in compositor using Smithay's DRM lease support or manual Wayland protocol implementation. Protocol flow: (a) Compositor creates `wp_drm_lease_device_v1` global. (b) On client bind, send `drm_fd` event with the DRM device file descriptor. (c) For each non-desktop connector, send `connector` event creating a `wp_drm_lease_connector_v1` resource with connector id and description. (d) Send `done` event to signal end of connector list. Monado (the OpenXR runtime) acts as the lease client: it binds to `wp_drm_lease_device_v1`, receives the DRM fd, discovers available HMD connectors, and requests a lease. Implementation details: the compositor must open the DRM device with `O_RDWR` and pass the fd to the lease client via `wayland_server::Resource::send_event`. Handle multiple lease devices (multi-GPU systems): advertise lease device per DRM device that has non-desktop connectors. | 2 | GO: Monado binds to lease device; receives DRM fd and connector list; connector description matches actual HMD |
| 9.3 | **Implement lease request/grant lifecycle.** Handle the full lease lifecycle: (a) Client (Monado) creates `wp_drm_lease_request_v1` via `wp_drm_lease_device_v1.create_lease_request()`. (b) Client calls `request.request_connector(connector)` for each desired connector. (c) Client calls `request.submit()` to finalize the lease request. (d) Compositor evaluates request: if connector is available (not already leased), grant the lease. Create DRM lease via `drmModeCreateLease(drm_fd, &[connector_id, crtc_id, plane_id], object_count, flags)` which returns a `lessee_id` and a new DRM fd restricted to the leased objects. Send `wp_drm_lease_v1.lease_fd(leased_fd)` to client. (e) If connector unavailable, send `wp_drm_lease_v1.finished()` to deny. (f) Revocation: compositor can revoke lease at any time via `wp_drm_lease_v1.finished()` (e.g., on HMD unplug or compositor shutdown). (g) Client-initiated release: client destroys `wp_drm_lease_v1` resource. Track lease state: `LeaseState { connector_id, lessee_id, client_pid, granted_at }` in `VrState`. Only one active lease per connector. Log all lifecycle events with timestamps. | 2 | GO: Monado acquires DRM lease; `drmModeCreateLease` succeeds; Monado receives valid DRM fd for HMD |
| 9.4 | **Monado DRM lease consumer integration.** Configure Monado to use DRM lease from our compositor instead of directly opening the DRM device. Monado configuration: set `XRT_COMPOSITOR_FORCE_WAYLAND_DIRECT=1` or configure `monado.toml` to prefer Wayland DRM lease. Monado's Wayland direct mode: connects to compositor's Wayland socket, binds `wp_drm_lease_device_v1`, requests lease on HMD connector, uses leased DRM fd for direct mode display (bypassing compositor for VR frames -- lowest latency). Verify: Monado's `xrt_compositor_native` receives the leased fd and initializes direct mode rendering. Frame submission from our compositor's OpenXR session (Week 7) now outputs to the actual HMD display. Measure motion-to-photon latency: target < 20ms for DRM lease direct mode. Debug: if lease fails, check that CRTC and plane IDs are included in lease object set (common error: forgetting plane). | 2 | GO: Monado renders to HMD via DRM lease; VR scene from Week 8 visible in headset |
| 9.5 | **Valve Index tethered HMD testing.** Comprehensive testing with Valve Index connected via DisplayPort + USB. Test matrix: (a) Compositor startup with Index connected: verify non-desktop detection, lease advertisement, Monado lease acquisition, VR scene rendering. (b) Display modes: test 90Hz, 120Hz, 144Hz refresh rates. Verify frame timing adapts to selected refresh rate (`predicted_display_period` from `xrWaitFrame` changes accordingly). (c) Tracking: verify 6DoF tracking (position + orientation) from Index's lighthouse-based tracking. (d) Per-eye resolution: 1440x1600 per eye at 100% supersampling. (e) IPD: verify physical IPD adjustment reflected in OpenXR view poses. (f) Audio: Index has built-in speakers; verify PipeWire/PulseAudio routes audio to Index. (g) Microphone: Index has built-in mic; verify PipeWire input routing. (h) Long-running stability: 30-minute session without frame drops or tracking loss. Document all results in `docs/hmd-testing/valve-index.md`. | 1 | GO: Index displays VR scene at 90Hz+; 6DoF tracking functional; 30-minute session stable |
| 9.6 | **Quest 3 wireless VR via WiVRn.** Configure WiVRn for wireless streaming from compositor to Quest 3. Setup: (a) Install `wivrn-server` in compositor environment (NixOS: add to flake; Rocky: package separately). (b) WiVRn server creates a virtual HMD in Monado, receives rendered frames via OpenXR, encodes to H.264/H.265/AV1 via VA-API hardware encoder, streams to Quest 3 over Wi-Fi. (c) Quest 3 runs WiVRn client app (sideloaded APK), decodes and displays frames, sends tracking data back. (d) Network requirements: 5GHz Wi-Fi, preferably Wi-Fi 6E on dedicated access point for < 30ms round-trip. Test: verify frame streaming at 72Hz/90Hz/120Hz Quest 3 display rates. Measure end-to-end latency: target < 40ms motion-to-photon (higher than wired due to encode/network/decode). Test tracking quality: Quest 3 inside-out tracking relayed to Monado. Test hand tracking: Quest 3 optical hand tracking forwarded to OpenXR (consumed in Week 18). `(defcustom exwm-vr-wivrn-bitrate 100)` Mbps. `(defcustom exwm-vr-wivrn-codec "h265")`. | 1 | GO: Quest 3 displays VR scene wirelessly; latency < 50ms; tracking functional |
| 9.7 | **Desktop fallback: VR scene on monitor (no HMD mode).** Implement "preview" mode: render the VR scene to a regular desktop window when no HMD is connected or for development. Use Smithay's Winit backend (window-based) to create a preview window. Render mono (single-eye) view of the VR scene to this window at desktop refresh rate (60Hz). Camera controlled by: mouse drag for rotation, scroll wheel for zoom, WASD for movement (when preview window focused). This allows developing and testing VR layout, surface placement, and interaction without any HMD hardware. Activate: `just vr-preview` recipe sets `EXWM_VR_MODE=preview`. Or auto-detect: if no non-desktop connectors found and no Monado headless, start in preview mode. IPC: `(:vr-mode :mode :preview)` or `(:vr-mode :mode :headset)` or `(:vr-mode :mode :headless)`. Emacs: `(defcustom exwm-vr-mode 'auto)` with values `'auto`, `'headset`, `'preview`, `'headless`, `'off`. | 1 | GO: `just vr-preview` opens window showing VR scene; mouse controls camera; surfaces visible and interactive |
| 9.8 | **HMD hotplug handling.** Handle HMD connect/disconnect without compositor crash or session corruption. Hotplug events arrive via DRM connector status change (udev or DRM event). On HMD connect: (a) Detect new non-desktop connector. (b) Update `VrState::hmd_connectors`. (c) Advertise new connector via `wp_drm_lease_device_v1.connector()` + `done()`. (d) If in preview/headless mode, offer to switch to headset mode. (e) Emit IPC: `(:hmd-connected :connector "DP-3" :name "Valve Index")`. On HMD disconnect: (a) If active lease exists, revoke: `wp_drm_lease_v1.finished()` + `drmModeRevokeLease(drm_fd, lessee_id)`. (b) Monado receives lease revocation, handles gracefully (enters STOPPING state). (c) Compositor transitions to fallback mode (preview or headless). (d) Emit IPC: `(:hmd-disconnected :connector "DP-3")`. (e) All VR scene state preserved (surface positions, layouts) for when HMD reconnects. Emacs: on disconnect, show `(message "HMD disconnected. Switched to preview mode.")`. On reconnect, prompt: `"HMD reconnected. Switch to VR mode? (y/n)"`. Debounce: ignore connect/disconnect events within 500ms of each other (cable jiggle). | 2 | GO: HMD unplug during active session transitions to preview without crash; replug restores VR within 5 seconds |
| 9.9 | **Multi-HMD awareness and selection.** Handle systems with multiple non-desktop connectors (e.g., Index + Quest Link + development HMD). Enumerate all: display list to user. Selection: `(defcustom exwm-vr-preferred-hmd nil "Preferred HMD connector name or nil for auto.")`. Auto-selection: prefer highest-resolution HMD. Manual selection via Emacs: `(exwm-vr-select-hmd)` shows `completing-read` with available HMDs. IPC: `(:vr-select-hmd :connector "DP-3")`. Only one HMD active at a time (single lease). Switching: revoke current lease, grant new lease to different connector. Future: multi-HMD for asymmetric rendering (one HMD for user, another for observer). | 1 | GO: multiple HMDs enumerated; user can select preferred; switching works without session loss |
| 9.10 | **WayVR and Stardust XR overlay fallback.** If DRM lease is unavailable (GPU driver doesn't support `drmModeCreateLease`, or compositor runs nested under another compositor), fall back to overlay rendering. WayVR approach: render VR scene as an OpenXR overlay layer (using `XR_EXTX_overlay` if available, or SteamVR overlay API). Stardust XR approach: export scene graph to Stardust XR's spatial shell protocol. Implementation: detect DRM lease failure, log warning, attempt overlay path. `(defcustom exwm-vr-fallback-mode 'wayvr)` with values `'wayvr`, `'stardust`, `'preview`, `'none`. Document each fallback path's limitations: overlay = limited to single rectangle or predefined region, no full scene graph; preview = desktop window only. Mark WayVR and Stardust integration as experimental with clear API boundaries for future expansion. | 1 | GO: when DRM lease fails, compositor falls back to preview mode gracefully; overlay path documented for future |
| 9.11 | **Display mode negotiation and refresh rate management.** Implement intelligent display mode selection for leased HMD output. Query available modes: from DRM connector mode list, filter for modes matching HMD native resolution. Select refresh rate based on user preference and system capability: `(defcustom exwm-vr-target-refresh-rate 90)`. If target rate unavailable, select closest available (e.g., request 90Hz on Quest 3 which supports 72/90/120Hz). Update OpenXR frame timing: `predicted_display_period` from `xrWaitFrame` reflects actual HMD refresh rate. Dynamic refresh rate: if `XR_FB_display_refresh_rate` extension available (Quest), allow runtime switching: `(:vr-set-refresh-rate :hz 120)` IPC command. Display performance stats: `(:vr-display-info :refresh-rate 90 :resolution (:w 2880 :h 1600) :mode "direct")` emitted on mode change. | 1 | GO: HMD runs at requested refresh rate; dynamic refresh rate switching works on Quest 3 |
| 9.12 | **Test suite for Week 9.** Rust tests: (a) `test_non_desktop_detection` -- mock DRM connector with `non-desktop=1`, verify it's classified as HMD. (b) `test_lease_grant_revoke` -- mock lease request, verify fd creation and revocation. (c) `test_hotplug_connect` -- simulate connector status change, verify advertisement update. (d) `test_hotplug_disconnect` -- simulate removal during active lease, verify revocation. (e) `test_fallback_mode_selection` -- verify correct fallback when no HMD present. (f) `test_multi_hmd_selection` -- two non-desktop connectors, verify selection logic. (g) `test_refresh_rate_negotiation` -- verify closest rate selected when exact not available. ERT tests: (a) `exwm-vr-mode` defcustom exists with value `'auto`. (b) `exwm-vr-preferred-hmd` defcustom exists. (c) `exwm-vr-target-refresh-rate` defcustom exists with default 90. (d) HMD IPC event parsing (`:hmd-detected`, `:hmd-connected`, `:hmd-disconnected`). (e) `exwm-vr-select-hmd` command exists. Target: >= 7 new Rust tests, >= 5 new ERT tests. Cumulative: >= 92 ERT tests. | 2 | GO: all tests pass; >= 92 cumulative ERT tests |

**Research (parallel):**
- R9.1: **DRM lease implementation survey.** Study how other compositors implement `wp_drm_lease_v1`: (a) Sway/wlroots: `wlr_drm_lease_v1_manager`, lease request handling. (b) KWin: DRM lease for SteamVR. (c) Niri: if DRM lease is supported. (d) Gamescope: DRM lease for VR overlays. Extract common implementation patterns, pitfalls (missing CRTC/plane in lease object set), and testing strategies. Document in `docs/research/drm-lease-survey.md`. (1 agent)
- R9.2: **WiVRn latency profiling.** Measure WiVRn streaming pipeline latency breakdown: (a) Frame capture (DMA-BUF export from compositor), (b) Hardware encode (VA-API H.265), (c) Network transmission (Wi-Fi 6), (d) Decode (Quest 3 hardware decoder), (e) Display (Quest 3 compositor). Profile each stage independently. Determine: is 30ms motion-to-photon achievable on Wi-Fi 6E? What is the minimum viable bitrate for readable text? Compare H.264 vs H.265 vs AV1 for text-heavy content (Emacs/terminal). (1 agent)
- R9.3: **Alternative HMD connection paths.** Research non-standard HMD connections: (a) USB-C DisplayPort alt mode (Quest Link, Pimax Crystal). (b) DisplayPort over Thunderbolt (eGPU scenarios). (c) Virtual Display (software HMDs for testing: Monado simulated, xrgears). (d) Cloud VR rendering (render on server, stream to headset). Document which paths require DRM lease vs other mechanisms. (1 agent)
- R9.4: **Aspirational HMD research: Somnium VR1, Pimax Crystal SLAM, Beyond 2E.** Track development status of next-generation HMDs. Somnium VR1: SteamVR-based, check Monado driver availability. Pimax Crystal SLAM: inside-out tracking, Monado compatibility unknown. Beyond 2E: eye tracking built-in, potential for integrated `XR_EXT_eye_gaze_interaction`. For each: document expected availability, Linux driver status, relevant OpenXR extensions. (1 agent)

**Completion Metrics:**
- [ ] Non-desktop DRM connectors correctly identified and advertised via `wp_drm_lease_v1`
- [ ] DRM lease lifecycle: grant, active use, revocation all functional
- [ ] Monado acquires lease and renders to HMD via direct mode
- [ ] At least one HMD displays the VR scene from Week 8
- [ ] Valve Index: functional at 90Hz+ with 6DoF tracking (if hardware available)
- [ ] Quest 3: wireless streaming via WiVRn functional (if hardware available)
- [ ] Desktop preview mode: VR scene viewable without any HMD
- [ ] Hotplug: HMD disconnect during session transitions gracefully; reconnect resumes VR
- [ ] Multi-HMD: enumeration and selection works
- [ ] Refresh rate: configurable and correctly applied to HMD display mode
- [ ] Fallback: graceful degradation when DRM lease unavailable
- [ ] >= 92 cumulative ERT tests passing
- [ ] >= 7 new Rust tests passing

**Gate: GO/NOGO/ASK**
- GO if at least one HMD path functional (tethered or wireless) AND desktop fallback works AND hotplug doesn't crash
- ASK user which HMD hardware to prioritize if no hardware available for testing (use Monado headless + preview mode)
- ASK if DRM lease implementation differs significantly between GPU drivers (test AMD first, then Intel)
- ASK if WiVRn latency too high for text readability (increase bitrate, try AV1, or recommend wired Index)
- NOGO if DRM lease crashes the DRM backend for all tested GPU drivers (fall back to WayVR overlay approach)
- NOGO if Monado cannot consume DRM lease from non-wlroots compositor (investigate Monado Wayland direct mode code)

**Risk Table:**

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| DRM lease `drmModeCreateLease` fails on specific GPU driver | Medium | High | Test on AMD (best Wayland support) first; NVIDIA may need proprietary lease path |
| Monado expects wlroots-specific lease behavior | Medium | Medium | Study Monado's `comp_window_direct_wayland.c`; match expected protocol sequence |
| HMD hotplug triggers DRM device reset | Low | High | Debounce events; save/restore compositor DRM state across reset |
| WiVRn encode latency too high for text readability | Medium | Medium | Tune bitrate (150+ Mbps), use AV1 with better text preservation; recommend wired for coding |
| Quest 3 tracking data laggy over network | Medium | Low | WiVRn uses prediction; latency visible but usable; wired recommended for precision work |

**Composability Notes:**
- DRM lease mechanism from 9.1-9.3 is the hardware display path for ALL subsequent VR rendering
- Desktop fallback from 9.7 enables development for all subsequent VR weeks without HMD
- Hotplug handling from 9.8 ensures robustness for daily-driver use (Week 20 release quality)
- WiVRn configuration from 9.6 reused in Week 15 (NixOS/Rocky packaging)
- Multi-HMD selection from 9.9 enables future multi-user or observer modes

**Parallelism Opportunities:**
- Stages 9.1 (connector detection) and 9.2 (protocol implementation) are sequential prerequisites
- Stage 9.3 (lease lifecycle) depends on 9.1 + 9.2
- Stages 9.4 (Monado integration) and 9.7 (desktop fallback) are independent after 9.3
- Stages 9.5 (Index testing) and 9.6 (Quest 3 testing) are independent hardware tests
- Stages 9.8 (hotplug), 9.9 (multi-HMD), 9.10 (overlay fallback), 9.11 (refresh rate) are largely independent
- All 4 research agents run in parallel with build stages

**Integration Points:**
- Week 3: DRM backend extended with lease support
- Week 7: OpenXR session now renders to real HMD via leased display
- Week 8: VR scene rendering output directed to HMD via lease
- Week 10: VR interaction testing requires HMD or preview mode from this week
- Week 15: WiVRn server packaged; HMD udev rules added; display manager handles HMD detection
- Week 16: DRM lease tested across GPU driver matrix
- Week 18: Quest 3 hand tracking arrives via WiVRn relay established here

---

### Week 10: VR Window Interaction

**Goal:** Full head-gaze interaction system following the KWin VR MR "Xray" pattern (ray origin offset: 15cm right, 10cm down, 5cm forward from head pose for ergonomic aiming); ray-surface intersection with sub-pixel accuracy for pointer event generation; `wl_pointer` event mapping from 3D ray hits to 2D surface-local coordinates; window grab/move in 3D space via controller grip or keyboard shortcut; depth adjustment (pull closer/push away); follow mode keeping windows within field of view; head-tilt scrolling; comprehensive IPC forwarding of all VR pointer state to Emacs; `ewwm-vr-input.el` Emacs module for VR input handling

**Dependencies:** Week 7 (OpenXR session, reference spaces), Week 8 (VR scene graph, surface quads), Week 9 (HMD display or preview mode), Week 5 (ewwm.el surface management)

| Stage | Task | Agents | Gate |
|-------|------|--------|------|
| 10.1 | **Head-gaze ray implementation (Xray pattern).** Implement the head-gaze ray following the KWin VR MR "Xray" pattern. The ray does NOT originate from between the eyes (which causes neck strain from constant precise head aiming). Instead, the ray origin is offset from the head pose: 15cm to the right (`+X` in OpenXR right-handed coordinates), 10cm downward (`-Y`), and 5cm forward (`-Z`). This places the effective ray origin roughly at the user's dominant hand position when seated, making the gaze feel natural and reducing fatigue. Ray direction: from offset origin toward the point where the user's forward gaze intersects a conceptual plane 5m ahead. Compute per frame: (a) Get head pose from `session.locate_views()` or `space.locate(view_space, time)`. (b) Apply offset in head-local coordinates: `ray_origin = head_pos + head_rot * Vec3(0.15, -0.10, -0.05)`. (c) Ray direction: `head_rot * Vec3(0, 0, -1)` (forward in head space). Render ray as a thin line (1px wide in screen space) from origin extending 10m forward, with color gradient: white at origin fading to transparent. `(defcustom exwm-vr-gaze-ray-offset '(0.15 -0.10 -0.05) "Head-gaze ray origin offset (x y z) in meters from head pose.")`. Allow left-handed offset: `(-0.15 -0.10 -0.05)`. | 2 | GO: ray visible in VR scene; ray direction follows head rotation; offset makes aiming comfortable |
| 10.2 | **Ray-surface intersection calculation.** Implement ray-vs-quad and ray-vs-cylinder intersection for all scene graph surfaces. For flat quads: (a) Transform ray into surface-local space: `local_ray = inverse(surface_transform) * world_ray`. (b) Ray-plane intersection: `t = -dot(plane_normal, ray_origin - plane_point) / dot(plane_normal, ray_dir)`. (c) Check `t > 0` (intersection ahead of ray). (d) Compute hit point in plane: `hit = ray_origin + t * ray_dir`. (e) Check hit point within quad bounds: `-w/2 <= hit.x <= w/2`, `-h/2 <= hit.y <= h/2`. (f) Convert to surface-local UV: `u = (hit.x + w/2) / w`, `v = (h/2 - hit.y) / h` (Y-flip for screen coordinates). For cylindrical surfaces: parametric ray-cylinder intersection, solve quadratic for `t`, then check arc angle bounds and height bounds. For multiple intersections: select closest (smallest `t`). Store result: `RayHit { surface_id, t: f32, uv: Vec2, world_point: Vec3 }` or `None` if no surface hit. Update every frame. Performance: iterate all visible surfaces (typically < 20); intersection is O(n) which is fast. | 2 | GO: ray correctly identifies which surface it points at; UV coordinates accurate to within 2 pixels |
| 10.3 | **Surface-local coordinate conversion for pointer events.** Convert ray intersection UV to surface pixel coordinates for Wayland pointer events. Mapping: `pixel_x = uv.x * surface_width_px`, `pixel_y = uv.y * surface_height_px`. Handle surface scaling: if compositor applies output scaling (e.g., 2x for HiDPI), convert to buffer coordinates. Handle subsurfaces: if hit point falls within a child subsurface, compute coordinates relative to the subsurface. Store per-surface pointer state: `SurfacePointerState { surface_id, pixel_x, pixel_y, entered: bool }`. On pointer enter (ray first hits surface): store as active pointer target. On pointer move (ray moves within same surface): update pixel coordinates. On pointer leave (ray moves to different surface or no surface): clear active target. Throttle coordinate updates: send at most one update per frame (90Hz) to avoid flooding Wayland clients with events. | 2 | GO: surface-local coordinates accurately map to actual pixel positions; verified by hovering over known UI elements |
| 10.4 | **Map ray intersection to `wl_pointer` events for Wayland clients.** Generate Wayland pointer events from VR ray intersection, making VR gaze indistinguishable from a physical mouse to Wayland clients. Event sequence: (a) When ray enters a surface: send `wl_pointer.enter(surface, x, y)` with `wl_fixed_from_double(pixel_x)`. (b) While ray is on surface: send `wl_pointer.motion(time, x, y)` each frame with updated coordinates. (c) When ray leaves surface: send `wl_pointer.leave(surface)`. (d) On click action (trigger press, keyboard Enter, or wink confirm in future): send `wl_pointer.button(time, BTN_LEFT, WL_POINTER_BUTTON_STATE_PRESSED)` then `wl_pointer.button(time, BTN_LEFT, WL_POINTER_BUTTON_STATE_RELEASED)`. (e) Frame event: send `wl_pointer.frame()` after each batch of pointer events. Handle `wl_pointer.set_cursor()`: when Wayland client sets cursor shape, apply cursor change to VR ray endpoint visualization (e.g., hand cursor for links, text cursor for input fields). Implementation: use Smithay's `PointerHandle` to inject synthetic events into the seat's pointer state machine. | 2 | GO: clicking on Qutebrowser link via VR ray opens the link; text cursor appears over input fields |
| 10.5 | **Click, double-click, and right-click from VR.** Implement multiple click types mapped from VR inputs. (a) Left click: keyboard Enter (when no physical mouse), VR controller trigger (Week 18), or wink (Week 13). (b) Right click: keyboard Shift+Enter, controller grip button, or double-wink. (c) Double-click: two rapid Enter presses (< 300ms apart), or controller trigger double-tap. (d) Middle click: keyboard Ctrl+Enter, or controller thumbstick click. IPC from Emacs to compositor: `(:vr-click :button :left :surface-id 42)`, `(:vr-click :button :right)` (uses current ray target). Implement `ewwm-vr-input.el` command `(exwm-vr-click &optional BUTTON)` with BUTTON defaulting to `'left`. Keybinding: `(define-key exwm-vr-input-map (kbd "RET") #'exwm-vr-click)`, `(define-key exwm-vr-input-map (kbd "S-RET") (lambda () (interactive) (exwm-vr-click 'right)))`. | 1 | GO: left-click opens links; right-click opens context menus; double-click selects words in text |
| 10.6 | **Scroll events from VR.** Implement scroll event generation from VR inputs. Sources: (a) Head tilt: tilt head down (pitch < -5 degrees from neutral) generates scroll-down events; tilt up (pitch > 5 degrees) generates scroll-up. Angular velocity maps to scroll speed: gentle tilt = 1 line/frame, strong tilt = 10 lines/frame. Linear interpolation in 5-15 degree range. Dead zone: +/- 5 degrees from neutral (no scroll). (b) Controller thumbstick Y-axis (Week 18): direct mapping to scroll events. (c) Keyboard: standard scroll keys (Page Up/Down, mouse wheel passthrough). Send `wl_pointer.axis(time, WL_POINTER_AXIS_VERTICAL_SCROLL, value)` with `wl_pointer.axis_source(WL_POINTER_AXIS_SOURCE_WHEEL)` and `wl_pointer.frame()`. Smooth scrolling: emit axis events at frame rate (90Hz) with fractional pixel values. `(defcustom exwm-vr-head-scroll-enable t)`. `(defcustom exwm-vr-head-scroll-deadzone 5.0 "Degrees of head tilt before scroll begins.")`. `(defcustom exwm-vr-head-scroll-speed 3.0 "Scroll speed multiplier.")`. | 1 | GO: head tilt scrolls Qutebrowser page; scroll speed proportional to tilt angle; dead zone prevents accidental scroll |
| 10.7 | **Window grab and move in 3D space.** Implement grabbing a surface and repositioning it in VR space. Grab initiation: (a) Keyboard: press and hold a designated key (default: `Super+g`) while ray points at surface. (b) Controller: grip button press (Week 18). (c) IPC: `(:vr-grab :surface-id 42)`. While grabbed: surface follows ray endpoint, maintaining the relative offset from grab point. Move calculation: `new_position = ray_hit_point + grab_offset` where `grab_offset = surface_position - initial_hit_point` (computed at grab start). Grab release: release key/button. Surface snaps to new position. Send IPC to Emacs: `(:surface-moved :surface-id 42 :position (:x 1.2 :y 1.5 :z -1.8))`. Optional snap-to-grid: `(defcustom exwm-vr-snap-grid 0.1 "Grid spacing for surface placement, in meters. nil to disable.")`. Visual feedback during grab: surface border changes to yellow; slight transparency (alpha 0.8). Constraint: during grab, surface cannot move behind the user (Z > 0 in head space). | 1 | GO: grab + move repositions surface; release places it at new location; IPC notifies Emacs of new position |
| 10.8 | **Depth adjustment (pull closer / push away).** Implement Z-axis movement for individual surfaces without full grab/move. Interaction: (a) While ray points at a surface, scroll wheel (or head-tilt if not consumed by content scroll) adjusts distance. (b) Keyboard: `Super+=` pulls 0.2m closer, `Super+-` pushes 0.2m away. (c) IPC: `(:vr-adjust-depth :surface-id 42 :delta -0.2)` (negative = closer). Range constraints: minimum distance 0.3m (prevents surface clipping into camera), maximum distance 5.0m (prevents surfaces from disappearing). Visual feedback: distance indicator appears briefly showing current distance in meters ("1.8m"). Emacs commands: `(exwm-vr-pull-closer &optional DISTANCE)`, `(exwm-vr-push-away &optional DISTANCE)`. `(defcustom exwm-vr-depth-step 0.2 "Distance in meters per depth adjustment step.")`. Store per-surface depth adjustment in scene graph; persist across layout recalculations. | 1 | GO: surface moves along Z-axis; distance indicator shows; constraints prevent clipping and disappearing |
| 10.9 | **Follow mode for content visibility.** Implement "follow mode" that keeps important surfaces within the user's field of view as they turn their head. Behavior: if the user turns their head more than 60 degrees (configurable) from the direction to a followed surface, that surface smoothly animates to re-enter the user's FOV at the nearest visible edge. Follow modes per surface: (a) `'none` (default): surface stays at fixed position, disappears from view when head turns away. (b) `'lazy`: surface follows if out of FOV for > 2 seconds, slow animation (1 second to reach visible position). (c) `'sticky`: surface always within FOV, immediate follow (200ms). (d) `'locked`: surface locked to head pose (HUD-like, stays in same visual position regardless of head rotation). Assignment: `(:vr-set-follow :surface-id 42 :mode :lazy)`. Emacs: `(defcustom exwm-vr-emacs-follow-mode 'lazy "Follow mode for the primary Emacs surface.")`. Follow animation: use exponential decay (`lerp(current, target, 0.05)` per frame) for smooth motion. Avoid snapping. | 1 | GO: followed surface re-enters FOV when head turns away; animation is smooth and not nauseating |
| 10.10 | **Forward VR pointer state to Emacs via IPC.** Comprehensive IPC forwarding of all VR interaction state to Emacs. Events emitted every frame (throttled to 30Hz for IPC bandwidth): `(:vr-pointer :surface-id 42 :x 523 :y 187 :distance 1.8)` -- current ray target and surface-local coordinates. Events emitted on state change: `(:vr-focus-changed :surface-id 42 :prev-surface-id 37)` -- ray moved to new surface. `(:vr-grab-started :surface-id 42)`, `(:vr-grab-ended :surface-id 42 :position (:x 1.2 :y 1.5 :z -1.8))`. `(:vr-click :button :left :surface-id 42 :x 523 :y 187)`. Implement `ewwm-vr-input.el`: define `exwm-vr-input-mode` minor mode. Variables: `(defvar exwm-vr-pointer-surface nil "Surface ID currently under VR ray.")`, `(defvar exwm-vr-pointer-position nil "Cons of (x . y) pixel coordinates on current surface.")`. Hooks: `exwm-vr-focus-change-hook` (functions receive `(surface-id prev-surface-id)`), `exwm-vr-click-hook` (functions receive `(button surface-id x y)`). Mode-line segment: show current VR target surface name. | 1 | GO: Emacs receives real-time VR pointer state; focus change hook fires; mode-line shows target surface |
| 10.11 | **VR pointer visualization and cursor rendering.** Render visual feedback for the VR pointer beyond the ray line. (a) Hit point indicator: small circle (5mm radius) rendered on the surface at the intersection point, using a billboard quad or surface-aligned decal. Color: white with 50% alpha (subtle). (b) Cursor shape: mirror the `wl_pointer.set_cursor` shape from the focused Wayland client. Render cursor texture at the hit point. Handle cursor scaling for VR (physical mouse cursors are tiny; scale up 3x for VR readability). (c) Ray color indicates state: white = idle/hovering, green = surface under ray, blue = grabbing, red = no surface hit. (d) When ray hits no surface: show endpoint dot at 5m distance (visual reference). `(defcustom exwm-vr-show-ray t "Show VR gaze ray line.")`. `(defcustom exwm-vr-show-hit-point t "Show intersection point indicator.")`. `(defcustom exwm-vr-cursor-scale 3.0 "Scale factor for cursor in VR.")`. | 1 | GO: hit point indicator visible on surface; cursor shape matches Wayland client cursor; ray color changes with state |
| 10.12 | **Head-gaze offset calibration.** Provide interactive calibration for the head-gaze ray offset to match individual user ergonomics. Calibration procedure: (a) Display 5 target points at known positions in VR scene (center, top-left, top-right, bottom-left, bottom-right of a calibration surface at 2m). (b) User turns head to aim ray at each target and confirms (Enter key). (c) Record head pose at each confirmation. (d) Compute optimal ray offset that minimizes angular error between ray-target direction and head-forward direction across all 5 points. (e) Store calibration in `~/.config/exwm-vr/gaze-calibration.json`. Implement `exwm-vr-calibrate-gaze` interactive Emacs command that opens calibration mode. Calibration quality score: RMS error in degrees (target: < 2 degrees). If calibration produces worse results than defaults, warn user and offer to keep defaults. | 1 | GO: calibration procedure completes; stored offset improves pointing accuracy by >= 20% over defaults |
| 10.13 | **Test suite for Week 10.** Rust tests: (a) `test_ray_quad_intersection` -- known ray and quad, verify hit point and UV. (b) `test_ray_cylinder_intersection` -- verify hit on curved surface. (c) `test_ray_miss` -- ray pointing away from all surfaces returns None. (d) `test_closest_intersection` -- two overlapping surfaces, verify closest returned. (e) `test_uv_to_pixel` -- verify UV-to-pixel conversion with known surface dimensions. (f) `test_follow_mode_lazy` -- surface outside FOV for > 2s triggers re-entry animation. (g) `test_grab_constraints` -- verify surface cannot move behind camera. (h) `test_depth_clamp` -- verify distance stays within 0.3m-5.0m range. ERT tests: (a) `exwm-vr-input-mode` exists and activates. (b) `exwm-vr-pointer-surface` variable exists. (c) `exwm-vr-click` command exists with default binding. (d) `exwm-vr-pull-closer`/`push-away` commands exist. (e) VR pointer IPC event parsing. Target: >= 8 new Rust tests, >= 5 new ERT tests. Cumulative: >= 97 ERT tests. | 2 | GO: all tests pass; >= 97 cumulative ERT tests |

**Research (parallel):**
- R10.1: **Apple Vision Pro "look and tap" UX pattern analysis.** Study Apple's spatial interaction model: (a) Eye tracking identifies target (replaces our head-gaze ray for users with eye tracking in Week 11). (b) Pinch gesture confirms selection (replaces our keyboard Enter). (c) Two-finger pinch for scrolling. (d) Wrist rotation for fine adjustment. Extract: target acquisition time (Apple claims < 200ms), error rates, fatigue characteristics. Compare against our head-gaze model. Document adaptation strategy: head-gaze is our "eyes" equivalent for users without eye tracking; eye tracking (Week 11) replaces head-gaze as primary targeting. (1 agent)
- R10.2: **Head-tilt scrolling ergonomics study.** Research head-tilt-to-scroll implementations: (a) Meta Quest home environment scrolling. (b) Apple Vision Pro scroll gesture. (c) Academic papers on head-based scrolling (Fitts' law applications to head input). Determine: optimal dead zone angle, acceleration curve, maximum scroll speed. Assess neck fatigue for extended scrolling. Alternative: dedicated scroll surface zone (look at bottom edge = scroll, from Week 17) may be less fatiguing. (1 agent)
- R10.3: **Wayland pointer constraint protocols.** Research `zwp_pointer_constraints_unstable_v1` (lock/confine pointer to region) and `zwp_relative_pointer_unstable_v1` (raw pointer motion for FPS games). Determine if our VR pointer needs to support these protocols. Use cases: games running under XWayland, drawing applications. Implementation impact: pointer lock means ray stays fixed on one surface regardless of head movement. (1 agent)
- R10.4: **VR interaction latency measurement.** Measure end-to-end latency from head movement to pointer event delivery at Wayland client. Pipeline: head pose update (OpenXR runtime, ~2ms) -> ray intersection (compositor, ~0.1ms) -> coordinate conversion (~0.01ms) -> Wayland event dispatch (~0.1ms) -> client processing (application-dependent). Target: < 5ms from pose to event dispatch. Identify bottlenecks. Compare against KWin VR MR measured latencies. (1 agent)

**Completion Metrics:**
- [ ] Head-gaze ray visible in VR scene with configurable offset
- [ ] Ray correctly identifies target surface with sub-pixel UV accuracy
- [ ] `wl_pointer` events (enter, motion, leave, button, axis) delivered to Wayland clients
- [ ] Left-click, right-click, and double-click functional via keyboard in VR
- [ ] Head-tilt scrolling works in Qutebrowser and terminal applications
- [ ] Window grab and move: surfaces relocatable in 3D space with visual feedback
- [ ] Depth adjustment: surfaces movable along Z-axis with distance constraints
- [ ] Follow mode: lazy-followed surface re-enters FOV within 3 seconds of head turn
- [ ] IPC: all VR pointer state forwarded to Emacs at 30Hz
- [ ] `ewwm-vr-input.el`: minor mode functional, hooks fire, mode-line shows target
- [ ] Pointer visualization: hit point indicator, cursor shape mirroring, ray color states
- [ ] Calibration: interactive 5-point calibration improves accuracy by >= 20%
- [ ] End-to-end interaction latency: < 5ms from head pose to Wayland event dispatch
- [ ] >= 97 cumulative ERT tests passing
- [ ] >= 8 new Rust tests passing

**Gate: GO/NOGO/ASK**
- GO if head-gaze ray correctly targets surfaces AND pointer events work in Qutebrowser + terminal AND grab/move functional
- ASK if head-gaze accuracy insufficient for small UI elements (< 10px targets) -- add configurable ray smoothing or bring eye tracking forward from Week 11
- ASK if head-tilt scrolling causes neck fatigue in 15-minute test -- disable by default, offer as opt-in
- ASK if Wayland pointer constraints needed for specific applications (evaluate effort vs application coverage)
- NOGO if ray-surface intersection fundamentally inaccurate (> 20px error) making VR unusable for desktop interaction
- NOGO if pointer event injection via Smithay PointerHandle causes seat state machine corruption

**Risk Table:**

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Head-gaze offset causes inconsistent aiming across users | Medium | Medium | Interactive calibration (10.12); per-user profiles; offer standard center-gaze as fallback |
| Ray-cylinder intersection math errors | Low | Medium | Unit test with known analytical solutions; visualize intersection for debugging |
| Pointer event flooding overwhelms Wayland clients | Low | Medium | Throttle to 90Hz max (one update per frame); batch events with frame delimiter |
| Grab/move causes surfaces to overlap unpredictably | Medium | Low | Snap-to-grid; collision avoidance (push neighboring surfaces apart); undo via IPC |
| Follow mode animation causes motion sickness | Medium | Medium | Slow exponential decay; user testing; disable option; avoid sudden jumps |

**Composability Notes:**
- Head-gaze ray from 10.1 is the primary interaction before eye tracking (Week 11) and hand tracking (Week 18)
- Ray-surface intersection from 10.2 reused by Week 11 (gaze-surface intersection) and Week 13 (gaze zone detection)
- Pointer event mapping from 10.4 is the foundation for ALL VR-to-Wayland input (gaze click, hand pinch, controller trigger)
- Grab/move from 10.7 extended in Week 18 with hand-based grab gestures
- Follow mode from 10.9 composes with workspace switching (followed surfaces track across workspaces)
- IPC forwarding from 10.10 consumed by all Emacs-side VR features (weeks 11-14, 17-19)

**Parallelism Opportunities:**
- Stages 10.1 (ray) and 10.2 (intersection) are sequential prerequisites
- Stages 10.3 (coordinate conversion) and 10.4 (pointer events) are sequential
- Stages 10.5 (click types) and 10.6 (scroll) are independent after 10.4
- Stages 10.7 (grab), 10.8 (depth), 10.9 (follow) are largely independent
- Stages 10.10 (IPC), 10.11 (visualization), 10.12 (calibration) are independent
- All 4 research agents run in parallel with build stages

**Integration Points:**
- Week 7: OpenXR view poses provide head position for ray origin
- Week 8: scene graph surfaces are the intersection targets; focus indication triggered by ray
- Week 9: VR interaction tested on HMD or preview mode
- Week 11: eye tracking replaces head-gaze ray as primary targeting (ray becomes fallback)
- Week 12: gaze-to-focus builds on the focus-change infrastructure from 10.10
- Week 13: gaze zones use surface-local coordinates from 10.3
- Week 17: gaze-based link following uses ray-surface intersection
- Week 18: hand tracking provides alternative to keyboard for click/grab/scroll

---

## Phase 3: Eye Tracking (Weeks 11-14)

### Week 11: Eye Tracking Hardware Integration

**Goal:** Full eye tracking pipeline from hardware to compositor: OpenXR `XR_EXT_eye_gaze_interaction` extension for HMD-integrated eye trackers (Valve Index + Eye addon, Quest Pro, Pimax Crystal) via action set and pose binding; Pupil Labs ZMQ client (REQ-REP handshake on port 50020, SUB socket for `gaze` and `fixation` topics, msgpack deserialization) for external eye trackers (Pupil Core, Pupil Neon); unified gaze data model abstracting over both sources; uinput virtual pointer device for desktop fallback; gaze visualization overlay in VR scene; gaze-surface intersection reusing Week 10 ray intersection infrastructure; 5-point calibration UI via Emacs buffer; IPC forwarding of gaze data to Emacs

**Dependencies:** Week 7 (OpenXR session with `XR_EXT_eye_gaze_interaction` extension), Week 8 (VR scene for visualization), Week 10 (ray-surface intersection infrastructure)

| Stage | Task | Agents | Gate |
|-------|------|--------|------|
| 11.1 | **OpenXR eye gaze extension: action set and pose setup.** Implement `XR_EXT_eye_gaze_interaction` via the `openxrs` crate. Check extension availability: `VrState.enabled_extensions.contains("XR_EXT_eye_gaze_interaction")` (from Week 7, stage 7.2). Create dedicated action set: `instance.create_action_set("eye-tracking", "Eye Tracking", 0)`. Create gaze pose action: `action_set.create_action::<Posef>("gaze_pose", "Eye Gaze Pose", &[])` with type `XR_ACTION_TYPE_POSE_INPUT`. Suggest interaction profile binding: `instance.suggest_interaction_profile_bindings(Path("/interaction_profiles/ext/eye_gaze_interaction"), &[Binding { action: gaze_pose, path: Path("/user/eyes_ext/input/gaze_ext/pose") }])`. Attach action set to session: `session.attach_action_sets(&[&action_set])`. Create action space: `gaze_pose.create_space(session, Path("/user/eyes_ext/input/gaze_ext/pose"), Posef::IDENTITY)`. Each frame: sync action set, locate gaze space relative to LOCAL reference space: `gaze_space.locate(local_space, predicted_display_time)` returns `SpaceLocation { pose, velocity_flags }`. The pose orientation represents the gaze direction (forward vector = direction user is looking). Extract gaze ray: origin = `pose.position`, direction = `pose.orientation * Vec3(0,0,-1)`. Store in `GazeState { source: GazeSource::OpenXR, ray: Ray, timestamp: f64, confidence: f32 }`. | 2 | GO: gaze pose received at >= 60Hz; gaze ray direction matches eye movement in VR headset |
| 11.2 | **Pupil Labs ZMQ client: connection and handshake.** Implement ZMQ client in compositor Rust code using the `zeromq` or `zmq` crate. Connection to Pupil Capture IPC Backbone: (a) REQ socket connects to `tcp://127.0.0.1:50020` (Pupil Capture IPC port, configurable). (b) Send handshake: `b"SUB_PORT"` via REQ. (c) Receive response: SUB port number as UTF-8 string (e.g., `"50021"`). (d) Create SUB socket, connect to `tcp://127.0.0.1:{sub_port}`. (e) Subscribe to topics: `sub.subscribe("gaze.")` for gaze data, `sub.subscribe("fixations")` for fixation events, `sub.subscribe("blinks")` for blink detection (consumed in Week 13). ZMQ message format: multipart message, first part = topic string (e.g., `"gaze.3d.01."`), second part = msgpack-encoded datum. Implement msgpack deserialization using `rmp-serde` crate. Gaze datum fields: `{"topic": "gaze.3d.01.", "confidence": 0.95, "timestamp": 1702345678.123, "gaze_point_3d": [x, y, z], "eye_centers_3d": {"0": [x,y,z], "1": [x,y,z]}, "gaze_normals_3d": {"0": [nx,ny,nz], "1": [nx,ny,nz]}, "base_data": [...]}`. Parse `gaze_point_3d` as world-space gaze target (if calibrated) or `gaze_normals_3d` as per-eye gaze direction. Register SUB socket as calloop event source: poll for messages on each event loop iteration. Handle disconnection: reconnect with exponential backoff (1s, 2s, 4s, max 30s). | 2 | GO: SUB socket receives gaze data at >= 120Hz from Pupil Capture; msgpack parsing succeeds |
| 11.3 | **Unified gaze data model.** Abstract over OpenXR and Pupil Labs gaze sources with a common interface. Define `GazeData { source: GazeSource, ray: Ray3D, confidence: f32, timestamp_s: f64, per_eye: Option<PerEyeGaze> }` where `GazeSource` enum: `OpenXR`, `PupilLabs`, `Simulated`. `PerEyeGaze { left_direction: Vec3, right_direction: Vec3, left_openness: Option<f32>, right_openness: Option<f32> }`. Conversion from OpenXR: gaze pose -> ray (stage 11.1). Conversion from Pupil Labs: `gaze_normals_3d` -> ray in Pupil's coordinate system -> transform to compositor/VR coordinate system (rotation matrix based on Pupil camera mount position, calibrated in 11.10). Source priority: `(defcustom exwm-vr-gaze-source 'auto)` where `'auto` prefers OpenXR (lower latency, already in VR coordinate system) and falls back to Pupil Labs. Source switching at runtime: if OpenXR gaze becomes unavailable (HMD removed), transparently switch to Pupil Labs if connected. Emit unified gaze data at consistent rate: resample to 90Hz (matching frame rate) via linear interpolation if source rate differs. Ring buffer: store last 500 gaze samples (~5.5 seconds at 90Hz) for analysis by downstream consumers (dwell detection, saccade filtering). | 2 | GO: unified `GazeData` produced at 90Hz regardless of source; source switching works transparently |
| 11.4 | **Uinput virtual pointer device for desktop fallback.** For non-VR mode (desktop monitor, no HMD), create a virtual pointer device driven by gaze data. Use Linux `uinput` kernel interface: open `/dev/uinput`, configure device with `UI_SET_EVBIT` for `EV_REL` (relative pointer) and `EV_ABS` (absolute pointer). Set absolute axis ranges to match primary monitor resolution. Map gaze direction to screen coordinates: project gaze ray onto monitor plane, convert to pixel coordinates. Write `input_event` structs: `EV_ABS, ABS_X, pixel_x` and `EV_ABS, ABS_Y, pixel_y` followed by `EV_SYN, SYN_REPORT, 0`. Gaze smoothing for desktop mode: apply exponential moving average (EMA) filter with `alpha = 0.3` to reduce jitter (eye trackers have ~0.5-1 degree noise). `(defcustom exwm-vr-gaze-smoothing 0.3 "EMA alpha for gaze smoothing. 0=max smooth, 1=no smooth.")`. Implement in compositor as optional module: `--features uinput` (requires `CAP_UINPUT` or `/dev/uinput` write permission; configure via udev rule). Desktop gaze pointer coexists with physical mouse: physical mouse events take priority, gaze pointer resumes after 2 seconds of mouse inactivity. | 1 | GO: gaze data drives system cursor on desktop monitor; cursor follows eye movement; physical mouse overrides |
| 11.5 | **Gaze-surface intersection in VR.** Reuse the ray-surface intersection infrastructure from Week 10 (stage 10.2) but with the gaze ray instead of the head-gaze ray. Each frame: if eye tracking active, compute `gaze_hit = intersect_scene(gaze_data.ray, scene)`. Result: `GazeSurfaceHit { surface_id, pixel_x, pixel_y, distance, confidence }`. When both head-gaze ray and eye-gaze ray are available: use eye-gaze for surface identification (more precise, ~1 degree accuracy vs head-gaze ~5 degree accuracy). Compositor state: `active_gaze_target: Option<GazeSurfaceHit>` updated every frame. Handle low-confidence gaze: if `confidence < 0.5`, do not update gaze target (maintain last known). Handle gaze between surfaces: if gaze ray hits no surface, set `active_gaze_target = None`. For cylindrical surfaces: use the same ray-cylinder intersection from 10.2. IPC: `(:gaze-target :surface-id 42 :x 523 :y 187 :confidence 0.92)` emitted at 30Hz (throttled from 90Hz). IPC: `(:gaze-target-changed :surface-id 42 :prev-surface-id 37)` on surface change. | 1 | GO: gaze ray correctly identifies target surface; accuracy within 2 degrees of actual gaze point |
| 11.6 | **Gaze visualization overlay.** Render a visual indicator showing where the user is looking in the VR scene. Default visualization: small translucent circle (8mm radius in world space) at the gaze-surface intersection point, rendered as a billboard quad with circular alpha mask. Color: soft yellow (#ffdd44) at 40% alpha. When gaze is between surfaces (no hit): show a small dot at 3m distance along gaze ray. Visualization modes: (a) `'dot` -- simple circle at hit point. (b) `'crosshair` -- thin crosshair lines extending 2cm from hit point. (c) `'spotlight` -- larger area (5cm radius) with gaussian falloff, like a flashlight. (d) `'none` -- no visualization (for users who find it distracting). `(defcustom exwm-vr-gaze-visualization 'dot)`. Visualization responds to confidence: lower confidence = larger, more transparent indicator (conveying uncertainty). Render in separate pass after scene surfaces (always on top). Disable during secure input mode (Week 14 dependency). Animation: smooth indicator movement with slight lag (EMA filter, alpha=0.5) to reduce visual noise from microsaccades. | 1 | GO: gaze dot visible at correct position on surface; visualization follows eye movement smoothly |
| 11.7 | **Gaze data IPC and Emacs integration.** Forward processed gaze data to Emacs via IPC. Events: `(:gaze-data :surface-id 42 :x 523 :y 187 :confidence 0.92 :source :openxr)` at 30Hz. `(:gaze-target-changed :surface-id 42 :prev-surface-id 37)` on change. `(:gaze-fixation :surface-id 42 :x 523 :y 187 :duration-ms 450)` when Pupil Labs reports fixation (or computed from raw gaze). `(:gaze-saccade :from (:surface-id 37 :x 200 :y 100) :to (:surface-id 42 :x 523 :y 187) :velocity 450.0)` on detected saccade. Implement `exwm-vr-gaze.el` (extending the stub from Week 2): `(defvar exwm-vr-gaze-surface nil)`, `(defvar exwm-vr-gaze-position nil "Cons of (x . y)")`, `(defvar exwm-vr-gaze-confidence 0.0)`. Hooks: `exwm-vr-gaze-target-change-hook`, `exwm-vr-gaze-fixation-hook`. `(defun exwm-vr-gaze-at-point-p () "Return t if gaze is on the current buffer's surface.")`. Mode-line segment: `[Gaze: *surface-name*]` showing where user is looking. | 1 | GO: Emacs receives gaze data; `exwm-vr-gaze-surface` updates in real-time; hooks fire on target change |
| 11.8 | **Pupil Labs coordinate system calibration.** Pupil Labs gaze data is in Pupil's own coordinate system (camera-relative), which must be mapped to VR/compositor world coordinates. For HMD-mounted Pupil: calibrate offset and rotation between Pupil camera frame and HMD frame. Calibration procedure: (a) Display target point in VR scene at known world position. (b) User fixates on target. (c) Record Pupil gaze direction simultaneously with known target direction. (d) Repeat for 5 points (center + corners). (e) Compute rotation matrix `R` that transforms Pupil gaze vectors to VR world vectors: least-squares fit using SVD (`nalgebra::SVD::new(matrix).solve(target)`). (f) Store `R` in `~/.config/exwm-vr/pupil-calibration.json`. For desktop Pupil (no HMD): calibrate gaze-to-screen mapping. Display calibration targets on screen, record gaze for each, compute homography matrix. Apply calibration transform on every gaze sample before intersection. Implement `exwm-vr-calibrate-pupil` interactive Emacs command. Validate calibration: after calibration, show 5 validation targets, report average error in degrees and pixels. Target: < 2 degrees post-calibration error. | 2 | GO: Pupil Labs gaze mapped to VR coordinates with < 2 degree error after calibration |
| 11.9 | **5-point calibration UI via Emacs buffer.** Implement calibration as a dedicated Emacs buffer with compositor coordination. `M-x exwm-vr-calibrate-eyes` opens `*EyeCalibration*` buffer. Buffer displays instructions: "Look at each target as it appears. Hold your gaze steady for 1 second." In VR mode: compositor renders calibration targets as bright circles on a dark background, one at a time, at known scene positions. In desktop mode: Emacs renders targets as colored dots in the buffer at known screen positions. Protocol: Emacs sends `(:calibration-start :points 5)` to compositor. Compositor presents target 1, waits 1500ms (settle + record), sends `(:calibration-point :index 0 :gaze-avg (:x 0.12 :y 0.05 :z -0.98) :target (:x 0.0 :y 0.0 :z -2.0))` to Emacs. Repeat for all 5 points. On completion: compositor computes and applies calibration transform. Sends `(:calibration-complete :error-deg 1.4 :quality :good)`. Emacs displays results: "Calibration complete. Average error: 1.4 degrees (Good)." Quality levels: `< 1.5 deg` = excellent, `1.5-2.5 deg` = good, `2.5-4.0 deg` = fair, `> 4.0 deg` = poor (recommend recalibration). Store calibration with timestamp; re-prompt after 7 days. | 1 | GO: 5-point calibration completes; error reported; stored calibration applied automatically on next session |
| 11.10 | **Gaze source health monitoring.** Implement continuous monitoring of eye tracking data quality. Metrics: (a) Sample rate: expected >= 60Hz for Pupil, >= 90Hz for OpenXR. Alert if drops below 80% of expected rate. (b) Confidence: rolling average over 1 second. Alert if average confidence < 0.5 for > 5 seconds (possible tracker occlusion, wrong IPD, or glasses interference). (c) Tracking loss: count consecutive frames with `isValid = false` (OpenXR) or `confidence < 0.1` (Pupil). If > 30 consecutive frames (~330ms), emit `(:gaze-tracking-lost :source :openxr :duration-ms 330)`. (d) Calibration drift: periodically (every 10 minutes) check if gaze-surface mapping is still accurate by comparing gaze target with focused surface (if user is likely looking at the focused window, gaze should be on it). Drift > 3 degrees triggers `(:gaze-calibration-drift :error-deg 3.5)` -> Emacs can prompt recalibration. Emacs: `exwm-vr-gaze-health` command shows health dashboard (sample rate, confidence, tracking status, last calibration time). | 1 | GO: health monitoring detects simulated tracking loss within 500ms; drift detection triggers after artificial offset |
| 11.11 | **Simulated eye tracking for development.** Implement simulated gaze source for testing without eye tracking hardware. Modes: (a) Mouse-follows-gaze: use mouse position as gaze target (only in preview mode / desktop). (b) Scripted: replay a recorded gaze trace from JSON file (`[{"t": 0.0, "x": 0.1, "y": 0.0, "z": -0.98}, ...]`). (c) Random walk: gaze wanders randomly with saccade-like jumps every 2-3 seconds and fixation-like stability between jumps. (d) Pattern: cycle through surfaces in order, dwelling 2 seconds each (for automated testing). Select via `(defcustom exwm-vr-gaze-simulate nil "Simulated gaze mode for development.")` with values `nil`, `'mouse`, `'scripted`, `'random-walk`, `'pattern`. Simulated gaze produces identical `GazeData` as real trackers, enabling all downstream features (dwell, focus, zones) to be tested without hardware. Record real gaze traces: `exwm-vr-gaze-record` command saves current gaze stream to JSON for later replay. | 1 | GO: `exwm-vr-gaze-simulate 'mouse` makes mouse position drive gaze pipeline; dwell detection works with simulated data |
| 11.12 | **Test suite for Week 11.** Rust tests: (a) `test_openxr_gaze_pose_to_ray` -- known pose, verify ray direction. (b) `test_pupil_zmq_message_parse` -- synthetic msgpack gaze datum, verify field extraction. (c) `test_unified_gaze_model` -- both sources produce compatible `GazeData`. (d) `test_gaze_confidence_filter` -- low confidence samples rejected. (e) `test_gaze_surface_intersection` -- gaze ray hits correct surface. (f) `test_ema_smoothing` -- verify smoothing reduces jitter by expected factor. (g) `test_calibration_rotation_fit` -- known point correspondences, verify rotation matrix. (h) `test_simulated_gaze_random_walk` -- verify output rate and range. ERT tests: (a) `exwm-vr-gaze-source` defcustom exists. (b) `exwm-vr-gaze-surface` variable exists. (c) `exwm-vr-gaze-visualization` defcustom with correct values. (d) `exwm-vr-calibrate-eyes` command exists. (e) `exwm-vr-gaze-smoothing` defcustom with default 0.3. (f) Gaze IPC event parsing. (g) Gaze health dashboard command exists. Target: >= 8 new Rust tests, >= 7 new ERT tests. Cumulative: >= 105 ERT tests (note: corrected from compact plan's incorrect >=60 figure). | 2 | GO: all tests pass; >= 105 cumulative ERT tests (note: total exceeds compact plan projections due to full expansion) |

**Research (parallel):**
- R11.1: **Gaze-to-surface accuracy benchmark with different trackers.** If multiple eye trackers available, compare accuracy: (a) OpenXR via Quest Pro (integrated eye tracking, ~1.5 degree accuracy). (b) Pupil Core (binocular, 200Hz, ~0.6 degree accuracy with surface calibration). (c) Pupil Neon (lightweight, ~1.5 degree accuracy). (d) Tobii (if available via OpenXR extension). Benchmark protocol: 9-point validation grid, report per-point error in degrees and pixels for each tracker. Determine minimum viable accuracy for each interaction type: surface identification (5 degree sufficient), text line identification (2 degree needed), character-level targeting (< 1 degree needed). Document in `docs/research/eye-tracker-benchmark.md`. (2 agents)
- R11.2: **Midas touch mitigation strategies survey.** "Midas touch" = unintended activation when user merely looks at something without intending to interact. Research strategies: (a) Dwell threshold (200-500ms gaze on target before activation). (b) Gaze + confirm (look + wink/pinch/key, Apple Vision Pro model). (c) DualGaze (use both eye directions for disambiguation; crossed gaze = intentional). (d) Velocity thresholding (only stable fixations activate, saccades do not). (e) Context-aware (suppress activation during reading, activate only on explicit targets like buttons). (f) Probabilistic (machine learning model predicting intention from gaze patterns). Rank by: implementation complexity, user fatigue, false positive rate, false negative rate. Recommend primary strategy for Week 12. (1 agent)
- R11.3: **Pupil Labs LSL (Lab Streaming Layer) integration evaluation.** Pupil Labs offers LSL relay for standardized data streaming. Evaluate: does LSL reduce latency vs direct ZMQ? Does LSL provide synchronized timestamps across devices (EEG + eye tracking)? LSL is used by BrainFlow (Week 19) for EEG -- using LSL for both gaze and EEG enables hardware-synchronized multimodal data. Implementation: `liblsl` C library + Rust FFI. Compare latency: ZMQ direct vs LSL relay. Recommend approach for multimodal synchronization. (1 agent)
- R11.4: **Eye tracking on upcoming HMDs.** Research eye tracking capabilities of aspirational HMDs: Somnium VR1 (rumored Tobii integration), Pimax Crystal SLAM (Tobii eye tracking confirmed), Beyond 2E (proprietary eye tracking). For each: determine if gaze data is accessible via OpenXR `XR_EXT_eye_gaze_interaction`, or if vendor-specific extensions needed. Document expected data rates and accuracy specifications. (1 agent)

**Completion Metrics:**
- [ ] OpenXR eye gaze: `XR_EXT_eye_gaze_interaction` action set created, gaze pose received at >= 60Hz
- [ ] Pupil Labs ZMQ: client connects, subscribes to gaze topic, parses msgpack at >= 120Hz
- [ ] Unified gaze model: both sources produce compatible `GazeData`; source switching transparent
- [ ] Uinput virtual pointer: gaze drives system cursor on desktop (non-VR mode)
- [ ] Gaze visualization: dot/crosshair/spotlight visible at gaze intersection point in VR
- [ ] Gaze-surface intersection: correct surface identified from gaze direction
- [ ] Calibration: 5-point calibration completes with error < 2 degrees for at least one tracker
- [ ] Pupil coordinate calibration: Pupil gaze mapped to VR coordinates with < 2 degree error
- [ ] Health monitoring: tracking loss detected within 500ms; calibration drift detected
- [ ] Simulated gaze: mouse-as-gaze works for development; scripted replay works for automated tests
- [ ] IPC: gaze data arrives in Emacs at 30Hz; target change hooks fire
- [ ] >= 105 cumulative ERT tests passing
- [ ] >= 8 new Rust tests passing

**Gate: GO/NOGO/ASK**
- GO if gaze-to-surface mapping works with < 3 degree accuracy from at least one source AND calibration UI functional AND IPC integration working
- ASK user which eye tracker hardware to prioritize if multiple available (recommend Pupil Core for highest accuracy, OpenXR for lowest latency)
- ASK if Pupil Labs ZMQ port conflicts with other services (make port configurable)
- ASK if uinput virtual pointer requires elevated privileges (configure udev rule or use `CAP_UINPUT`)
- NOGO if no eye tracker achieves < 5 degree accuracy after calibration (insufficient for surface identification; revisit tracker mounting or switch hardware)
- NOGO if Pupil Labs ZMQ client cannot maintain stable connection (investigate alternative: Pupil LSL relay from R11.3)

**Risk Table:**

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| `XR_EXT_eye_gaze_interaction` not supported by Monado for target HMD | Medium | High | Fall back to Pupil Labs; Monado support is HMD-driver dependent |
| Pupil Labs ZMQ message format changes between versions | Low | Medium | Pin Pupil Capture version in Nix; implement format version detection |
| Eye tracking accuracy insufficient for text-line targeting | Medium | Medium | Use gaze for surface-level targeting only; fall back to head-gaze for fine targeting |
| Coordinate system mismatch between Pupil and VR scene | Certain | Medium | Explicit calibration step (11.8); document coordinate conventions thoroughly |
| Uinput device creation requires root/capability | Medium | Low | Document udev rule; provide fallback via compositor-level cursor injection |

**Composability Notes:**
- Unified gaze data model from 11.3 is consumed by ALL subsequent gaze features (Weeks 12-14, 17)
- Gaze-surface intersection from 11.5 reuses and extends Week 10 ray intersection
- Calibration infrastructure from 11.8-11.9 reused for Week 13 wink calibration pattern
- Gaze visualization from 11.6 disabled during secure input mode (Week 14)
- Simulated gaze from 11.11 enables automated testing of Weeks 12-14 without eye tracking hardware
- Health monitoring from 11.10 feeds into Week 13 fatigue monitoring subsystem

**Parallelism Opportunities:**
- Stages 11.1 (OpenXR gaze) and 11.2 (Pupil Labs ZMQ) are fully independent hardware paths
- Stage 11.3 (unified model) depends on both 11.1 and 11.2
- Stages 11.4 (uinput) and 11.5 (surface intersection) are independent after 11.3
- Stages 11.6 (visualization) and 11.7 (IPC) are independent
- Stages 11.8 (Pupil calibration) and 11.9 (calibration UI) are sequential but independent of 11.4-11.7
- Stages 11.10 (health) and 11.11 (simulation) are independent utilities
- All 4 research agents run in parallel with build stages

**Integration Points:**
- Week 7: OpenXR session and extension enumeration provide eye gaze capability check
- Week 8: VR scene provides rendering context for gaze visualization
- Week 10: ray-surface intersection infrastructure reused for gaze targeting
- Week 12: gaze data consumed for dwell detection and focus switching
- Week 13: blink/wink detection uses Pupil ZMQ blink topic and per-eye openness
- Week 14: gaze paused during secure input mode; gaze-away detection uses gaze target
- Week 15: Pupil Capture packaged; ZMQ port configured via NixOS module
- Week 17: gaze-based link following uses gaze-surface intersection
- Week 19: LSL synchronization between eye tracking and EEG (if R11.3 recommends LSL)

---

### Week 12: Gaze-Based Window Focus

**Goal:** Complete gaze-to-focus pipeline with robust Midas touch protection: gaze dwell detection with configurable 200ms threshold; gaze-to-focus mapping (dwell on surface -> focus surface -> notify Emacs); `exwm-vr-eye.el` Emacs module implementing gaze event handling, focus policy configuration, and per-surface gaze behavior; saccade filtering (velocity threshold > 300 deg/s suppresses focus changes during rapid eye movements); cooldown periods preventing rapid successive focus switches; reading detection that suppresses focus changes during within-surface eye movement; comprehensive `defcustom` configuration for all gaze-focus parameters; integration with existing ewwm focus infrastructure

**Dependencies:** Week 11 (eye tracking data pipeline, gaze-surface intersection), Week 10 (VR interaction, focus change IPC), Week 5 (ewwm.el focus management)

| Stage | Task | Agents | Gate |
|-------|------|--------|------|
| 12.1 | **Gaze dwell detection algorithm.** Implement dwell detection in compositor's gaze processing pipeline. A "dwell" occurs when the user's gaze remains on the same surface for a configurable duration. Algorithm: (a) Each frame, check `current_gaze_target.surface_id` against `dwell_state.surface_id`. (b) If same surface: increment `dwell_state.elapsed += frame_dt`. (c) If different surface: reset `dwell_state = DwellState { surface_id: new_id, elapsed: 0.0, pixel_x: gaze_x, pixel_y: gaze_y, jitter_radius: 0.0 }`. (d) Track gaze jitter during dwell: compute distance from dwell center `(pixel_x, pixel_y)` to current gaze position. Update `jitter_radius` as rolling max over dwell period. (e) When `elapsed >= dwell_threshold`: emit dwell event if `jitter_radius < max_jitter_px` (ensures gaze is stable, not scanning). Default dwell threshold: 200ms. Default max jitter: 50px (scales with PPU). Dwell state machine: `Idle` -> `Dwelling(surface_id, elapsed)` -> `Confirmed(surface_id)` -> `Cooldown`. On dwell confirmed: emit `(:gaze-dwell :surface-id 42 :x 523 :y 187 :duration-ms 205 :jitter-px 12)` to Emacs. `DwellConfig { threshold_ms: 200, max_jitter_px: 50, require_confidence: 0.6 }` -- only count dwell frames where gaze confidence > threshold. | 2 | GO: dwell events fire reliably when gaze rests on surface for >= 200ms; no dwell when gaze is scanning |
| 12.2 | **Saccade detection and filtering.** Implement saccade detection to suppress focus changes during rapid eye movements. Saccades are fast ballistic eye movements (300-700 deg/s) that occur when shifting gaze between targets. Detection: (a) Compute gaze angular velocity each frame: `angular_velocity = acos(dot(gaze_dir_prev, gaze_dir_current)) / frame_dt`. (b) If `angular_velocity > saccade_threshold` (default: 300 deg/s), classify current frame as "saccade." (c) During saccade: pause dwell accumulation, do not update gaze target surface. (d) Saccade ends when velocity drops below `saccade_end_threshold` (default: 50 deg/s) for >= 3 consecutive frames. This prevents focus thrashing during the 30-100ms saccade duration where gaze sweeps across multiple surfaces. Additionally: suppress microsaccades (tiny involuntary saccades, < 1 degree, 10-40 deg/s) which cause jitter but should not reset dwell. Microsaccade filter: if movement < 1.5 degrees and duration < 30ms, do not reset dwell state. `(defcustom exwm-vr-saccade-threshold 300 "Angular velocity in deg/s above which gaze is classified as saccade.")`. | 1 | GO: saccade during cross-surface gaze shift does NOT trigger intermediate focus changes; dwell resumes after saccade ends |
| 12.3 | **Gaze-to-focus: dwell confirmation triggers focus switch.** Connect dwell detection to compositor focus management. On dwell confirmed for surface `S`: (a) If `S` is already focused: no action (user is looking at focused window). (b) If `S` is different from focused surface: request focus change. Send `(:gaze-focus-request :surface-id S :dwell-ms 205)` to Emacs. (c) Emacs-side policy decides whether to honor the request (see 12.4). (d) If Emacs approves: compositor sends `wl_keyboard.enter(S)` to transfer keyboard focus to surface `S`. Send `(:surface-focused :surface-id S :method :gaze)` confirmation. (e) Visual feedback: brief highlight flash on newly focused surface (200ms bright border, fading). (f) Handle edge case: if gaze moves away during the focus-change processing latency (IPC round-trip ~1-2ms), cancel the focus change. (g) Handle multiple rapid dwells: if user gazes at A, then B, then A within 1 second, the cooldown (12.6) prevents thrashing. Focus source tracking: `(defvar ewwm-last-focus-method nil)` with values `'gaze`, `'keyboard`, `'mouse`, `'controller` -- enables Emacs to know how focus was last changed. | 2 | GO: looking at a window for 200ms focuses it; keyboard input goes to the newly focused window |
| 12.4 | **Emacs-side gaze focus policy in `exwm-vr-eye.el`.** Implement `exwm-vr-eye-mode` global minor mode that manages gaze-based focus. Focus policies: (a) `'gaze-only`: gaze dwell is the sole focus method (pure eye-tracking mode, no keyboard/mouse focus switching). (b) `'gaze-primary`: gaze dwell switches focus, but keyboard shortcuts (e.g., `C-x o`) and mouse clicks also work. (c) `'gaze-assist`: gaze highlights the target but requires confirmation (Enter key, wink, or pinch) to actually switch focus. (d) `'disabled`: traditional focus only, gaze has no effect on focus. `(defcustom exwm-vr-eye-focus-policy 'gaze-primary)`. Per-surface gaze behavior: `(defcustom exwm-vr-eye-focus-exceptions nil "Alist of (PREDICATE . POLICY) for per-surface overrides.")`. Example: `'((ewwm-qutebrowser-p . gaze-assist) (ewwm-minibuffer-p . disabled))` -- require confirmation for browser (prevent accidental clicks), disable gaze focus for minibuffer (prevent focus leaving minibuffer during completion). Implement `(exwm-vr-eye--should-focus-p surface-id)` predicate checking policy and exceptions. Hook into `exwm-vr-gaze-dwell-hook` from 12.1 to process dwell events. | 2 | GO: `(exwm-vr-eye-mode 1)` activates; `gaze-primary` policy switches focus on dwell; exceptions block focus for minibuffer |
| 12.5 | **Reading detection: suppress focus during within-surface scanning.** When reading text (e.g., in Emacs or Qutebrowser), eyes make rapid horizontal saccades (line scanning) and return sweeps (moving to next line). These should NOT trigger focus changes even though gaze moves around the surface. Detection: if gaze stays within the same surface but moves more than `max_jitter_px`, classify as "reading" (within-surface scanning) rather than "dwelling for focus." Specifically: (a) Track gaze movement pattern within current surface. (b) If gaze has visited > 50% of the surface's horizontal extent within 3 seconds, classify as "reading mode." (c) In reading mode: suppress dwell-triggered focus changes for this surface. Focus changes only occur when gaze moves to a DIFFERENT surface and dwells there. (d) Reading mode expires after gaze leaves the surface or after 30 seconds of no horizontal scanning. This is a critical Midas touch mitigation: users read one window while wanting to keep another focused (e.g., reading docs while code window has focus for editing). `(defcustom exwm-vr-eye-reading-detection t "Detect reading patterns to prevent false focus changes.")`. | 1 | GO: reading text in a non-focused window does NOT steal focus; only deliberate surface change triggers focus |
| 12.6 | **Gaze cooldown and focus hysteresis.** Implement cooldown period after each gaze-triggered focus change to prevent rapid oscillation. Behavior: after focus switches via gaze, no further gaze-triggered focus changes for `cooldown_ms` (default: 500ms). During cooldown: gaze target still tracked and visualized, but dwell timer frozen. Cooldown indicator: subtle dimming of gaze visualization dot during cooldown period. Additional hysteresis: if user's gaze alternates between surfaces A and B within 5 seconds (ping-pong pattern), automatically increase dwell threshold by 100ms for those two surfaces (makes it harder to trigger focus switch, reducing oscillation). Hysteresis resets after 10 seconds of stable focus. `(defcustom exwm-vr-eye-cooldown-ms 500 "Minimum time between gaze-triggered focus changes.")`. `(defcustom exwm-vr-eye-hysteresis t "Automatically increase dwell threshold for ping-pong patterns.")`. IPC: `(:gaze-cooldown-active t :remaining-ms 300)` so Emacs can display cooldown status. | 1 | GO: rapid gaze alternation between two windows does NOT cause focus thrashing; cooldown prevents switches within 500ms |
| 12.7 | **Gaze-aware mode-line and visual indicators.** Extend Emacs mode-line to show gaze focus state. Mode-line segment: `[Eye: surface-name (200ms)]` showing current gaze target and dwell progress. When dwell is accumulating toward threshold: show progress bar `[Eye: =====>____ *Firefox*]` (10 chars, filling as dwell approaches threshold). When cooldown active: `[Eye: COOL 300ms]`. When saccade detected: `[Eye: >>>]` (briefly). When gaze tracking lost: `[Eye: LOST]` in red. Implement `exwm-vr-eye-mode-line-format` customizable format string. Also: in VR scene, render a subtle progress ring around gaze dot during dwell accumulation (ring fills clockwise from 0% to 100% over dwell duration). Ring disappears on dwell cancel (gaze moved away) or dwell confirm (focus switches). `(defcustom exwm-vr-eye-show-dwell-progress t)`. | 1 | GO: mode-line shows live gaze target and dwell progress; VR dwell ring animates correctly |
| 12.8 | **Focus change integration with ewwm workspace system.** Integrate gaze focus with the workspace management system from Week 5. Rules: (a) Gaze can only focus surfaces on the current workspace. If gaze points at a surface on a different workspace (shouldn't happen unless surfaces span workspaces), ignore the dwell. (b) Workspace switching via gaze: when gaze points at a workspace indicator or edge zone (if configured), dwell triggers workspace switch rather than surface focus. (c) Focus history: maintain `exwm-vr-eye-focus-ring` (ring buffer of last 10 gaze-focused surfaces) for `(exwm-vr-eye-focus-back)` command (return to previously gaze-focused surface). (d) IPC workspace awareness: `(:gaze-focus-request :surface-id S :workspace 2)` includes workspace for validation. (e) Multi-workspace layouts in VR (surfaces from different workspaces visible at different depths): gaze focus switches workspace if targeting a surface from non-current workspace. `(defcustom exwm-vr-eye-cross-workspace-focus nil "Allow gaze to focus surfaces on other workspaces, switching workspace automatically.")`. | 1 | GO: gaze focus respects workspace boundaries; focus history enables returning to previous gaze target |
| 12.9 | **Defcustom configuration interface.** Centralize all gaze-focus configuration with comprehensive `defcustom` variables and a configuration buffer. Variables: `(defcustom exwm-vr-eye-enable t "Master switch for gaze-based focus.")`, `(defcustom exwm-vr-eye-dwell-ms 200 "Milliseconds of stable gaze before focus switch.")`, `(defcustom exwm-vr-eye-cooldown-ms 500 "Cooldown between gaze focus switches.")`, `(defcustom exwm-vr-eye-saccade-threshold 300 "Saccade detection threshold in deg/s.")`, `(defcustom exwm-vr-eye-max-jitter-px 50 "Maximum gaze jitter in pixels during dwell.")`, `(defcustom exwm-vr-eye-focus-policy 'gaze-primary)`, `(defcustom exwm-vr-eye-reading-detection t)`, `(defcustom exwm-vr-eye-hysteresis t)`, `(defcustom exwm-vr-eye-show-dwell-progress t)`, `(defcustom exwm-vr-eye-focus-exceptions nil)`, `(defcustom exwm-vr-eye-cross-workspace-focus nil)`, `(defcustom exwm-vr-eye-confidence-min 0.6 "Minimum gaze confidence for dwell accumulation.")`. All defcustoms push updated values to compositor via IPC: `(add-variable-watcher 'exwm-vr-eye-dwell-ms (lambda (sym val op where) (ewwm-ipc-send (list :set-config :dwell-ms val))))`. Implement `M-x exwm-vr-eye-configure` command opening a widget buffer for interactive parameter tuning with live preview (changes take effect immediately). | 1 | GO: all defcustoms exist with documented defaults; changing dwell-ms immediately affects focus behavior |
| 12.10 | **Gaze focus analytics and logging.** Implement optional analytics for gaze focus patterns to help users understand and optimize their gaze interaction. Track: (a) Focus switches per minute (target: 5-15/min during active work). (b) False positive rate: focus switches immediately undone by keyboard focus change (user correcting unwanted gaze focus). (c) Dwell time distribution: histogram of successful dwell durations. (d) Most-focused surfaces: sorted list of surfaces by total gaze-focus duration. (e) Saccade suppression count: how many focus changes were prevented by saccade filtering. Log to `~/.local/share/exwm-vr/gaze-focus-log.csv` with columns: timestamp, event_type (focus/cancel/cooldown/saccade_suppressed), surface_id, dwell_ms, confidence. Implement `M-x exwm-vr-eye-analytics` command showing summary dashboard in Emacs buffer: text-based histogram, focus rate chart (sparklines via `spark.el` or Unicode block characters), recommendations ("Your false positive rate is 8%. Consider increasing dwell threshold to 250ms."). `(defcustom exwm-vr-eye-analytics-enable t "Log gaze focus analytics.")`. | 1 | GO: analytics logged during session; dashboard shows meaningful statistics; false positive rate measurable |
| 12.11 | **Graceful degradation and fallback chain.** Implement robust fallback behavior when gaze focus encounters issues. Fallback chain: (a) Eye tracking available + calibrated: full gaze-to-focus as designed. (b) Eye tracking available but uncalibrated: prompt for calibration on first dwell attempt, disable gaze focus until calibration done. (c) Eye tracking lost mid-session (tracking health from 11.10): automatically disable gaze focus, switch to keyboard-only focus, show warning. Re-enable when tracking resumes. (d) Eye tracking unavailable at startup: `exwm-vr-eye-mode` activates but uses head-gaze ray from Week 10 as fallback targeting (less precise but functional). (e) No VR and no eye tracking: `exwm-vr-eye-mode` does nothing gracefully (focus by keyboard/mouse only). Handle transitions smoothly: if eye tracking recovers mid-session, ask user before re-enabling gaze focus (avoid surprise). `(defcustom exwm-vr-eye-fallback 'head-gaze "Fallback when eye tracking unavailable.")` with values `'head-gaze`, `'disabled`. | 1 | GO: eye tracking loss during session gracefully switches to head-gaze fallback; recovery prompts user |
| 12.12 | **Test suite for Week 12.** Rust tests: (a) `test_dwell_detection_basic` -- synthetic gaze on single surface for 250ms, verify dwell event. (b) `test_dwell_reset_on_surface_change` -- gaze moves to new surface, dwell timer resets. (c) `test_saccade_suppression` -- inject 400 deg/s gaze velocity, verify no dwell accumulation. (d) `test_microsaccade_ignored` -- inject 20 deg/s movement < 1 degree, verify dwell continues. (e) `test_cooldown_blocks_rapid_focus` -- two dwells within 300ms, verify second blocked. (f) `test_hysteresis_increases_threshold` -- A-B-A-B pattern, verify dwell threshold increased. (g) `test_jitter_exceeds_max` -- gaze with 80px jitter, verify no dwell. (h) `test_confidence_filter` -- low confidence frames, verify not counted toward dwell. ERT tests: (a) `exwm-vr-eye-mode` exists and toggles. (b) All defcustoms exist with correct types and defaults. (c) Focus policy `'gaze-primary` is default. (d) Focus exceptions list initially nil. (e) `exwm-vr-eye-focus-back` command exists. (f) Dwell IPC event parsing. (g) Focus request IPC event parsing. (h) Mode-line format produces valid string. (i) Analytics log file path computation. (j) Fallback to head-gaze when eye tracking source nil. Target: >= 8 new Rust tests, >= 10 new ERT tests. Cumulative: >= 115 ERT tests. | 2 | GO: all tests pass; >= 115 cumulative ERT tests |

**Research (parallel):**
- R12.1: **Dwell threshold optimization study.** Research optimal dwell threshold across published literature and existing products: Apple Vision Pro (~200ms reported), Tobii gaze interaction (~300ms default), academic studies (range 150-500ms depending on task). Factors: shorter threshold = faster interaction but more false positives; longer threshold = fewer errors but slower. Determine if adaptive threshold (start long, shorten as user proficiency increases) would improve experience. Test with simulated gaze data at thresholds 100, 150, 200, 250, 300, 400, 500ms measuring false positive rate and task completion time for a surface-switching task. (2 agents)
- R12.2: **Gaze focus in multi-monitor vs VR comparison.** Study how gaze-to-focus differs between 2D multi-monitor setup (surfaces on flat screens) and VR setup (surfaces in 3D space). In VR, surfaces at different depths add parallax complexity -- gaze at depth A may produce incorrect surface targeting at depth B. Research depth-of-field effects on gaze accuracy. Determine if depth-dependent dwell thresholds (surfaces further away need longer dwell) would improve accuracy. (1 agent)
- R12.3: **Alternative focus models survey.** Beyond simple dwell, research: (a) "Gaze + Click" (Apple Vision Pro primary model: gaze selects, pinch confirms). (b) "Gaze switches, keyboard confirms" (gaze focus is tentative until first keypress confirms it). (c) "Predictive focus" (ML model predicts intended focus from gaze trajectory before fixation). (d) "Priority-based" (some surfaces are harder to focus via gaze -- e.g., minibuffer requires keyboard). Evaluate each model's suitability for a code-editing workflow where precise focus control matters. (1 agent)
- R12.4: **Midas touch false positive measurement methodology.** Design a reproducible benchmark for measuring false positive rate. Protocol: user performs a structured 10-minute task (read document in window A while editing in window B). Count: intended focus switches (user deliberately looks at B to type), unintended focus switches (focus moves to A while user glances at reference). Require >= 3 participants for statistical validity. This methodology will be used in Week 13 (user testing) and Week 20 (release validation). (1 agent)

**Completion Metrics:**
- [ ] Gaze dwell detection: fires within 20ms of threshold crossing; no false fires during saccades
- [ ] Gaze-to-focus: dwell on surface switches keyboard focus; new surface receives keystrokes
- [ ] `exwm-vr-eye-mode`: activates cleanly, deactivates cleanly, respects focus policy
- [ ] Saccade filtering: cross-surface saccade does NOT trigger intermediate focus changes
- [ ] Cooldown: prevents focus switching within 500ms of last switch
- [ ] Hysteresis: ping-pong pattern automatically increases effective dwell threshold
- [ ] Reading detection: scanning text in unfocused window does NOT steal focus
- [ ] Focus policy: `gaze-primary` allows both gaze and keyboard focus; exceptions override per surface
- [ ] Mode-line: shows gaze target, dwell progress, cooldown status in real-time
- [ ] Workspace integration: gaze focus respects workspace boundaries
- [ ] All defcustoms: documented, type-checked, push changes to compositor via IPC
- [ ] Analytics: focus switch rate, false positive rate, and dwell distribution logged and displayable
- [ ] Fallback: graceful degradation when eye tracking lost or unavailable
- [ ] Gaze focus switching > 90% correct (gaze at intended window -> focus moves to it)
- [ ] False positive rate < 5% during 10-minute structured reading+editing task
- [ ] >= 115 cumulative ERT tests passing
- [ ] >= 8 new Rust tests passing

**Gate: GO/NOGO/ASK**
- GO if gaze-to-focus works with > 85% accuracy AND false positive rate < 8% AND saccade filtering prevents thrashing
- ASK if dwell threshold of 200ms produces too many false positives (increase to 300ms and re-test)
- ASK if reading detection suppresses too many intentional focus changes (tune horizontal extent threshold)
- ASK if accuracy borderline at 80-85% (bring calibration improvements from 11.8 or adjust PPU for larger surface targets)
- NOGO if false positive rate > 15% even with 500ms dwell threshold and all mitigations active (gaze-to-focus fundamentally unsuitable; switch default to gaze-assist requiring explicit confirmation)

**Risk Table:**

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Midas touch false positives during reading | High | High | Reading detection (12.5); cooldown (12.6); gaze-assist policy as escape hatch |
| Saccade filtering too aggressive (blocks intentional fast focus switches) | Medium | Medium | Tune saccade threshold per user; allow "fast switch" override via keyboard |
| Dwell threshold too long for power users | Low | Medium | Adaptive threshold that decreases with user proficiency; per-surface thresholds |
| Gaze focus conflicts with Emacs minibuffer/completion | Medium | Medium | Disable gaze focus for minibuffer via exceptions; test with vertico/consult |
| Focus analytics logging impacts performance | Low | Low | Log asynchronously; disable if frame budget exceeded |

**Composability Notes:**
- Gaze-to-focus from 12.3 is the primary input method enhanced by Week 13 (wink as confirmation) and Week 14 (gaze-aware security)
- Saccade filtering from 12.2 reused by Week 13 for saccade-vs-fixation classification
- Focus policy from 12.4 extended in Week 14 (disable gaze focus during password entry)
- Reading detection from 12.5 informs Week 13 fatigue monitoring (excessive reading without breaks)
- Analytics from 12.10 feed into Week 20 release quality metrics
- Defcustom infrastructure from 12.9 pattern reused for all subsequent feature configuration (Weeks 13-19)

**Parallelism Opportunities:**
- Stages 12.1 (dwell detection) and 12.2 (saccade filtering) are independent algorithms
- Stage 12.3 (gaze-to-focus) depends on both 12.1 and 12.2
- Stages 12.4 (Emacs policy) and 12.5 (reading detection) are independent
- Stages 12.6 (cooldown) and 12.7 (mode-line) are independent
- Stages 12.8 (workspace), 12.9 (defcustom), 12.10 (analytics) are independent
- All 4 research agents run in parallel with build stages

**Integration Points:**
- Week 11: gaze data pipeline provides gaze-surface intersection consumed here
- Week 10: head-gaze ray serves as fallback targeting when eye tracking unavailable
- Week 5: ewwm focus management infrastructure (keyboard focus, surface activation) extended with gaze source
- Week 13: blink/wink detection builds on gaze data; wink can confirm gaze focus (gaze-assist policy)
- Week 14: gaze focus disabled during secure input mode; gaze-away detection uses focus state
- Week 17: gaze-based link following uses surface-level gaze targeting established here
- Week 19: BCI attention state could modulate gaze focus sensitivity (high attention = shorter dwell)
- Week 20: analytics from 12.10 contribute to release quality metrics

---

### Week 13: Blink/Wink Detection & Gaze Modifiers

**Goal:** Robust blink/wink discrimination pipeline; gaze zone modifier system; P300/SSVEP alternative confirmation; fatigue monitoring subsystem

**Dependencies:** Week 11 (eye tracking hardware), Week 12 (gaze-based focus)

| Stage | Task | Agents | Gate |
|-------|------|--------|------|
| 13.1 | **Pupil Labs blink detection pipeline.** Subscribe to Pupil Capture `notify.blink` topic via ZMQ SUB socket. Parse blink datum: `{"topic": "blink", "confidence": 0.87, "timestamp": 1702345678.123, "onset_timestamp": ..., "offset_timestamp": ..., "duration": 0.15, "type": "onset"/"offset", "base_data": [...]}`. Store ring buffer of last 50 blinks in compositor for pattern analysis. Filter by confidence threshold (`defcustom exwm-vr-blink-confidence-min 0.7`). Emit IPC event `(:blink :eye :both :duration 0.15 :confidence 0.87 :timestamp 1702345678.123)` to Emacs. | 2 | GO: blink events arrive in Emacs with < 50ms latency from Pupil offset |
| 13.2 | **OpenXR eye openness blink detection fallback.** For HMDs with `XR_EXT_eye_gaze_interaction` but no explicit blink API: monitor `XrEyeGazeSampleTimeEXT` validity. When `isValid` transitions from `XR_TRUE` to `XR_FALSE` for > 80ms, classify as blink onset. When validity returns, classify as offset. Compute duration = offset_time - onset_time. For HMDs reporting per-eye validity (Varjo, Pimax), extract individual eye status. For HMDs reporting combined gaze only (Quest Pro), infer from gaze validity gaps. Store in same ring buffer as 13.1. | 2 | GO: blinks detected from OpenXR with > 80% agreement against Pupil Labs ground truth |
| 13.3 | **Wink discrimination algorithm.** Implement `WinkClassifier` in compositor Rust code. State machine with states: `Idle`, `LeftEyeClosing`, `RightEyeClosing`, `BothEyesClosing`, `LeftWinkConfirmed`, `RightWinkConfirmed`, `NaturalBlink`. Decision logic: (a) If only left eye closes AND right eye remains open for > 300ms AND < 600ms = left wink. (b) If only right eye closes AND left eye remains open for > 300ms AND < 600ms = right wink. (c) If both eyes close within 50ms of each other = natural blink, ignore. (d) If single eye closure < 100ms = noise/involuntary, ignore. (e) If single eye closure > 600ms = extended closure, not wink, trigger fatigue alert. Duration thresholds stored in `WinkConfig { min_duration_ms: 300, max_duration_ms: 600, both_eye_tolerance_ms: 50, noise_floor_ms: 100 }`. Per-user calibration: run 20-trial calibration sequence ("wink left now", "wink right now", "blink naturally") to compute personalized thresholds. Store calibration in `~/.config/exwm-vr/wink-calibration.json`. | 2 | GO: > 92% wink classification accuracy on calibration holdout set |
| 13.4 | **Wink-to-buffer mapping in exwm-vr-wink.el.** Implement `exwm-vr-wink-mode` minor mode. Defcustom bindings: `(defcustom exwm-vr-wink-left-action #'previous-buffer)`, `(defcustom exwm-vr-wink-right-action #'next-buffer)`, `(defcustom exwm-vr-wink-double-left-action #'switch-to-last-buffer)`, `(defcustom exwm-vr-wink-double-right-action #'delete-window)`. Double-wink detection: two winks of same eye within 800ms. Custom wink sequences for power users: `(defcustom exwm-vr-wink-sequences '((:left :right :left . consult-buffer) (:right :left :right . execute-extended-command)))`. Sequence timeout: 1500ms between winks. Visual feedback: brief flash in mode-line showing detected wink. | 2 | GO: `left-wink -> previous-buffer` works; `double-left-wink -> switch-to-last-buffer` works |
| 13.5 | **Gaze zone modifier system -- compositor side.** Divide each Wayland surface into 9 regions: 4 corners, 4 edges, 1 center. Corner zones occupy configurable percentage of surface dimensions (default: 15% width x 15% height). Edge zones: 15% depth, remaining width/height. Center: everything else. When gaze dwells in a corner zone for > 200ms (configurable via `defcustom exwm-vr-gaze-zone-dwell-ms 200`), emit IPC modifier event. Zone mapping: top-left = `C-x` prefix, top-right = `M-x` prefix, bottom-left = `C-` modifier, bottom-right = `M-` modifier. Edge zones: top-edge = scroll-up, bottom-edge = scroll-down, left-edge = `C-b` (backward-char), right-edge = `C-f` (forward-char). Zone activation locks for 500ms to prevent rapid toggling. Emit `(:gaze-zone :zone :top-left :modifier "C-x" :surface-id 42 :timestamp ...)` to Emacs. | 2 | GO: gaze in top-left corner for 200ms sends `C-x` modifier to Emacs |
| 13.6 | **Gaze zone modifier system -- Emacs side.** Implement `exwm-vr-gaze-zone.el`. On receiving `:gaze-zone` event, push modifier into `unread-command-events` as if user pressed the key. For `C-x` prefix: push `?\C-x` so Emacs enters `C-x` prefix map, then next keystroke completes the command. For `M-x`: directly invoke `execute-extended-command`. For `C-` and `M-` modifiers: set transient modifier state that applies to next keypress. `(defcustom exwm-vr-gaze-zone-layout 'default)` with presets: `'default`, `'vim-like`, `'spacemacs`, `'custom`. Custom layout via `(defcustom exwm-vr-gaze-zone-custom-map '((:top-left . "C-x") (:top-right . "M-x") ...))`. Works in both VR (3D gaze ray intersection mapped to surface-local coordinates) and flat-screen mode (2D gaze point on monitor). | 1 | GO: gaze-zone + keystroke produces correct Emacs command |
| 13.7 | **Visual feedback for zone activation.** Compositor renders semi-transparent colored overlay on active zone. Colors: top-left = blue tint (C-x), top-right = green tint (M-x), bottom-left = orange tint (C-), bottom-right = purple tint (M-). Overlay alpha: `defcustom exwm-vr-gaze-zone-overlay-alpha 0.15` (subtle, not distracting). In VR mode: overlay rendered as additional quad composited over the surface texture. In flat-screen mode: overlay rendered via Wayland subsurface or compositor-side shader. Animation: zone highlights fade in over 100ms on dwell start, fade out over 200ms on gaze departure. Active zone shows pulsing border (1px, matching zone color, 2Hz pulse). | 1 | GO: visual feedback visible but not distracting in 30-minute user test |
| 13.8 | **P300 event-related potential confirmation (OpenBCI alternative to wink).** When user has OpenBCI Cyton connected, offer P300-based confirmation as alternative to wink. Implementation: flash candidate UI elements in rapid sequence (200ms per flash, 5-element oddball paradigm). Record EEG at Pz electrode (channel index depends on cap montage -- default channel 6 for Cyton 8-channel with standard 10-20 placement). BrainFlow `DataFilter.perform_bandpass(data, 250, 0.5, 15.0, 4, FilterTypes.BUTTERWORTH)` to isolate P300 band. Detect positive deflection 250-500ms post-stimulus with amplitude > 5uV above baseline. Communicate result via BrainFlow daemon -> Unix socket -> compositor -> Emacs IPC: `(:bci-p300 :confirmed t :target-id 3 :latency-ms 340 :amplitude-uv 7.2)`. Accuracy target: > 80% with 3-trial averaging. | 2 | GO: P300 confirmation selects correct target in > 75% of 4-choice trials |
| 13.9 | **SSVEP flicker zones (OpenBCI alternative to dwell zones).** Instead of dwell-time-based zone activation, render each corner zone with a unique flicker frequency: top-left = 12Hz, top-right = 15Hz, bottom-left = 20Hz, bottom-right = 24Hz. Frequencies chosen to avoid harmonics overlap and stay within monitor/HMD refresh rate capability (all divide evenly into 120Hz). EEG at O1/O2 electrodes (occipital cortex, channels 7-8 on Cyton 8-channel). BrainFlow processing: `DataFilter.perform_fft(data, WindowOperations.HANNING)`, extract power at target frequencies +/- 0.5Hz. Dominant frequency = user's attended zone. Selection latency: 2-3 seconds for reliable classification. Compositor renders flicker via alternating quad alpha (full opacity / zero opacity at target frequency). `(defcustom exwm-vr-ssvep-frequencies '((top-left . 12.0) (top-right . 15.0) (bottom-left . 20.0) (bottom-right . 24.0)))`. SSVEP mode toggled explicitly -- not always-on due to flicker being visually distracting. | 2 | GO: SSVEP zone selection > 85% accuracy in 4-class offline test with 3-second windows |
| 13.10 | **Fatigue monitoring subsystem.** Track blink rate from ring buffer (rolling 60-second window). Normal range: 15-20 blinks/minute. Elevated: 20-25/min (mild fatigue). High: > 25/min (significant fatigue). Track saccade jitter: compute standard deviation of gaze velocity during fixations (from Pupil Labs `fixations` topic or computed from raw gaze). Jittery fixations (stddev > 2 deg/s) indicate fatigue. Track PERCLOS (percentage of eye closure over 1-minute window): > 15% indicates drowsiness. Implement `exwm-vr-fatigue.el`: subscribe to fatigue events from compositor. On mild fatigue: `(message "EXWM-VR: Elevated blink rate detected. Consider a break.")`. On significant fatigue: `(notifications-notify :title "Eye Fatigue Alert" :body "Blink rate %.0f/min. Take a 5-minute break." :urgency 'critical)`. Log all fatigue metrics to `~/.local/share/exwm-vr/fatigue-log.csv` with columns: timestamp, blink_rate, saccade_jitter, perclos, session_duration_min. `(defcustom exwm-vr-fatigue-alert-threshold 25)` blinks/min. `(defcustom exwm-vr-fatigue-log-enabled t)`. | 1 | GO: fatigue alert fires when simulated blink rate exceeds threshold |
| 13.11 | **Per-user wink calibration wizard in Emacs.** Implement `exwm-vr-wink-calibrate` interactive command. Opens dedicated buffer with instructions. Phase 1 (10 trials): "Please wink your LEFT eye now" with 3-second intervals. Record onset/offset/duration for each. Phase 2 (10 trials): same for right eye. Phase 3 (10 trials): "Please blink naturally." Compute per-user thresholds: left_wink_min = mean(left_durations) - 2*stddev, left_wink_max = mean(left_durations) + 2*stddev, similarly for right. Natural blink range computed same way. Reject calibration if left_wink and natural_blink ranges overlap by > 30% (user may need practice). Save to `~/.config/exwm-vr/wink-calibration.json`. Show accuracy estimate: "Based on calibration data, estimated wink accuracy: 94% (left), 91% (right)." | 1 | GO: calibration wizard completes; saved thresholds improve wink accuracy by >= 10% over defaults |
| 13.12 | **Integration tests and ERT suite for Week 13.** Test cases: (a) synthetic blink stream -> verify blink events arrive in Emacs, (b) synthetic wink pattern -> verify correct buffer switch, (c) synthetic gaze coordinates in corner zone for 200ms -> verify modifier event, (d) zone + keystroke -> verify correct command execution, (e) fatigue threshold crossing -> verify notification, (f) calibration data load/save roundtrip, (g) SSVEP frequency extraction from synthetic EEG, (h) P300 detection from synthetic ERP waveform. Mock Pupil Labs ZMQ with `zmq-tests.el` fixture. Mock BrainFlow with synthetic numpy arrays via Python subprocess. Target: >= 15 new ERT tests this week. | 2 | GO: all 15+ tests pass; >= 85 cumulative ERT tests |

**Research (parallel):**
- R13.1: User fatigue testing for wink-based interaction -- recruit 3 testers, 30-minute sessions, measure blink rate increase, subjective discomfort (Likert scale), wink accuracy degradation over time. Document results in `docs/research/wink-fatigue-study.md`. (2 agents)
- R13.2: Evaluate EMG wristband alternatives for modifier input -- research Myo armband (discontinued but available used), Ctrl-Labs approach (acquired by Meta), FOSS EMG projects on Hackaday. Assess whether EMG wristband could replace gaze zones for modifier activation with lower fatigue. (1 agent)
- R13.3: Survey existing blink/wink detection literature -- PubMed search for "voluntary wink detection EEG eye tracking" and "blink artifact rejection BCI". Extract optimal duration thresholds from published studies. Compare our thresholds against literature consensus. (1 agent)
- R13.4: Benchmark SSVEP classification accuracy vs. number of channels -- test with 2 channels (O1/O2 only), 4 channels (O1/O2/P3/P4), 8 channels (full Cyton). Determine minimum viable channel count for 4-class SSVEP. (1 agent)
- R13.5: Investigate Apple Vision Pro "look and pinch" latency characteristics from teardown analyses and developer documentation. Extract target latency budgets for our gaze+confirm pipeline. (1 agent)

**Completion Metrics:**
- [ ] Blink detection from Pupil Labs: > 95% true positive rate, < 3% false positive rate
- [ ] Blink detection from OpenXR: > 80% agreement with Pupil Labs ground truth
- [ ] Wink discrimination: > 92% accuracy (left vs right vs natural blink) post-calibration
- [ ] Wink discrimination: > 85% accuracy with default thresholds (no calibration)
- [ ] Buffer switching via wink: < 100ms from wink offset to buffer change visible
- [ ] Gaze zones activate correct modifier in > 95% of intentional activations
- [ ] Gaze zone false activation rate < 2% during normal (non-zone-targeting) use
- [ ] Visual feedback visible at arm's length in VR; not distracting during focused work
- [ ] P300 confirmation: > 75% accuracy in 4-choice paradigm (3-trial average)
- [ ] SSVEP zone selection: > 85% accuracy in 4-class offline test
- [ ] Fatigue monitoring: alert fires within 60 seconds of threshold crossing
- [ ] Per-user calibration improves wink accuracy by >= 10% over defaults
- [ ] User can use wink-based interaction for 30 minutes without significant discomfort
- [ ] >= 85 cumulative ERT tests passing

**Gate: GO/NOGO/ASK**
- GO if wink detection > 90% accurate post-calibration AND gaze zones functional AND fatigue monitoring operational
- ASK if wink causes fatigue after < 15 min in user study (consider switching default to gaze + keyboard confirm, keeping wink as opt-in)
- ASK if P300/SSVEP accuracy below 70% (may need more EEG channels or different paradigm)
- NOGO if blink detection fundamentally unreliable on target eye trackers (revisit hardware requirements)

**Composability Notes:**
- Wink detection composes with gaze zones: wink while looking at a zone = zone modifier + wink action (e.g., look at C-x zone + left wink = `C-x b` for switch-buffer)
- P300 confirmation can replace wink for users with OpenBCI but no reliable wink discrimination
- SSVEP zones can replace dwell zones for users preferring EEG over eye tracking timing
- Fatigue monitoring feeds into Week 19 (full BCI harness) attention state pipeline

**Parallelism Opportunities:**
- Stages 13.1 and 13.2 (Pupil blink vs OpenXR blink) are fully independent
- Stages 13.5 and 13.6 (compositor vs Emacs side of gaze zones) are independent until integration
- Stages 13.8 and 13.9 (P300 vs SSVEP) are independent BCI tracks
- All 6 research agents run in parallel with build stages

**Integration Points:**
- Week 11: eye tracking hardware provides raw gaze data consumed here
- Week 12: gaze focus mechanism provides the surface-identification layer used by zone system
- Week 14: gaze-aware security (disable wink/zone tracking during password entry)
- Week 17: qutebrowser gaze link following can use wink-to-confirm instead of dwell
- Week 18: hand tracking pinch competes with wink as confirmation gesture (user chooses)
- Week 19: full BCI harness subsumes the P300/SSVEP work started here

---

### Week 14: KeePassXC & Secrets Integration

**Goal:** Full secrets management pipeline via KeePassXC with three auto-type backends; gaze-aware security that pauses all biometric data streams during credential entry; TOTP and passkey support; D-Bus Secret Service provider

**Dependencies:** Week 6 (Qutebrowser under compositor), Week 12 (gaze focus), Week 13 (wink detection for gaze-away)

| Stage | Task | Agents | Gate |
|-------|------|--------|------|
| 14.1 | **secrets.el + keepassxc-shim.el integration.** Implement `exwm-secrets.el` wrapping Emacs built-in `secrets.el` (D-Bus `org.freedesktop.secrets` API). Register KeePassXC as Secret Service provider via `keepassxc-shim.el`: configure KeePassXC to expose its database over D-Bus Secret Service interface. Verify `(secrets-list-collections)` returns KeePassXC collections. Implement `(exwm-secrets-get ENTRY-PATH)` which calls `(secrets-get-secret "KeePassXC" ENTRY-PATH)`. Handle locked database: prompt for master password via `read-passwd` in minibuffer (with gaze security active -- see 14.7). Auth-source backend: `(auth-source-backend-parse 'exwm-secrets)` so `auth-source-search :host "github.com"` queries KeePassXC. `(defcustom exwm-secrets-default-collection "KeePassXC")`. | 2 | GO: `(auth-source-search :host "example.com")` returns credentials from KeePassXC database |
| 14.2 | **KeePassXC browser protocol (NaCl encrypted JSON).** Implement `exwm-keepassxc-browser.el` speaking the KeePassXC Browser Protocol. Handshake: generate X25519 keypair via Emacs `gnutls` or external `libsodium` FFI. Send `{"action": "change-public-keys", "publicKey": "base64...", "nonce": "base64...", "clientID": "exwm-vr"}` to KeePassXC via `keepassxc-proxy` Unix socket (default: `$XDG_RUNTIME_DIR/kpxc_server`). Receive server public key. All subsequent messages encrypted with NaCl `crypto_box` (X25519-XSalsa20-Poly1305). Implement message types: `get-logins` (query by URL), `set-login` (save new credential), `lock-database`, `get-database-hash`. Store association key in `~/.config/exwm-vr/keepassxc-association.json`. | 2 | GO: encrypted `get-logins` query returns credentials for test URL |
| 14.3 | **Auto-type backend 1: keepassxc-proxy protocol.** Send `{"action": "get-logins", "url": "https://example.com", ...}` via encrypted browser protocol. Receive `{"entries": [{"login": "user", "password": "pass", "name": "Example"}]}`. Parse response, select entry (if multiple: present `completing-read` in Emacs). Type credentials using backend 14.4 or 14.5. Implement `(exwm-secrets-autotype &optional URL)` interactive command. Auto-detect URL from: (a) Qutebrowser FIFO query `":url"`, (b) focused surface title regex matching `https?://`, (c) manual entry via minibuffer. | 1 | GO: `exwm-secrets-autotype` retrieves correct credentials for focused Qutebrowser page |
| 14.4 | **Auto-type backend 2: ydotool (Wayland fallback).** When compositor-level key injection unavailable, fall back to `ydotool`. Verify `ydotoold` socket exists at `/tmp/.ydotool_socket`. Implement `(exwm-secrets--ydotool-type STRING)`: shell out to `ydotool type --clearmodifiers -- "STRING"`. Handle special characters: Tab between username/password fields (`ydotool key Tab`), Enter to submit (`ydotool key Return`). Rate-limit typing to 50ms/char to avoid dropped keystrokes. Security: STRING passed via stdin pipe, never as command-line argument (visible in /proc). Clear STRING from Emacs memory after typing via `(clear-string password)`. | 1 | GO: ydotool types credentials into focused Wayland client correctly |
| 14.5 | **Auto-type backend 3: direct wl_keyboard injection from compositor.** Preferred backend -- zero external dependencies. Compositor implements synthetic `wl_keyboard.key` event injection via IPC command `(:autotype :text "username\tpassword\n" :surface-id 42)`. Compositor converts string to sequence of `wl_keyboard.key` events using xkbcommon keymap lookup: `xkb_state_key_get_utf8()` in reverse (find keycodes producing desired characters). Handle Shift for uppercase, AltGr for special symbols. Inject events at 10ms intervals (configurable: `defcustom exwm-vr-autotype-delay-ms 10`). Verify target surface-id matches currently focused surface (prevent injection into wrong window). Return `(:autotype-complete :surface-id 42 :chars-typed 24)` to Emacs. | 2 | GO: compositor injects credential string into Qutebrowser input field; form submits successfully |
| 14.6 | **Auto-type backend selection and fallback chain.** `(defcustom exwm-secrets-autotype-backend 'auto)` with values: `'compositor` (14.5), `'ydotool` (14.4), `'auto` (try compositor first, fall back to ydotool). Implement `(exwm-secrets--autotype-dispatch STRING)` that tries backends in order. On compositor backend failure (IPC timeout, surface mismatch): log warning, try ydotool. On ydotool failure (ydotoold not running): error with actionable message. Timeout for compositor response: 2000ms. | 1 | GO: auto backend selects compositor when available, falls back to ydotool when compositor returns error |
| 14.7 | **Gaze-aware security: biometric data stream suspension.** When password entry begins (auto-type initiated OR `read-passwd` active in minibuffer), compositor enters "secure input mode." Actions: (a) Pause all gaze data forwarding to Emacs (compositor queues but does not transmit gaze events). (b) Disable gaze visualization overlay (hide dot/cursor showing where user looks -- prevents shoulder-surfing of which password characters user tracks). (c) Pause gaze data recording/logging (fatigue log, gaze heatmaps). (d) If OpenBCI connected, pause EEG data logging (prevent ERP analysis revealing typed characters). (e) Suspend wink detection (prevent accidental buffer switch during password entry). IPC protocol: `(:secure-input-mode :enable t :reason "password-entry" :surface-id 42)` and `(:secure-input-mode :enable nil)`. Compositor visually indicates secure mode: thin red border around active surface. Emacs side: `exwm-vr-secure-input-mode` variable; hooks `exwm-vr-secure-input-mode-enter-hook` and `exwm-vr-secure-input-mode-exit-hook`. Auto-exit after 30 seconds (configurable) as safety net. | 2 | GO: during `read-passwd`, gaze visualization disappears; gaze events stop arriving in Emacs; red border visible |
| 14.8 | **Gaze-away detection for auto-type security.** During auto-type sequence, compositor monitors gaze target surface. If user's gaze leaves the target surface for > 500ms during typing, pause auto-type injection immediately. Emit `(:autotype-paused :reason :gaze-away :surface-id 42 :chars-remaining 12)` to Emacs. Emacs displays `(message "Auto-type paused: gaze left target. Look back to resume, C-g to cancel.")`. When gaze returns to target surface for > 300ms, resume: `(:autotype-resumed :surface-id 42)`. If gaze away for > 5 seconds, abort entirely and clear remaining characters. Future extension: if face detection available (camera-based, not gaze tracker), abort if second person detected in frame. `(defcustom exwm-secrets-gaze-away-pause-ms 500)`. `(defcustom exwm-secrets-gaze-away-abort-ms 5000)`. | 1 | GO: auto-type pauses within 600ms of gaze departure; resumes when gaze returns |
| 14.9 | **TOTP integration.** Implement `(exwm-secrets-totp ENTRY-PATH)` via KeePassXC browser protocol `{"action": "get-totp", "uuid": "..."}`. KeePassXC computes TOTP from stored seed, returns 6-digit code. Auto-type TOTP into focused field. Implement `exwm-secrets-autotype-with-totp`: fills username, Tab, password, Tab (or waits for 2FA page), TOTP, Enter. Handle timing: some sites load 2FA page after password submission. `(defcustom exwm-secrets-totp-delay-ms 2000)` -- wait for 2FA page before typing TOTP. Display countdown in mode-line showing TOTP validity remaining (30-second window). | 1 | GO: full login flow including TOTP completes on test site |
| 14.10 | **Passkeys/WebAuthn support.** Implement `exwm-secrets-passkey.el` for FIDO2/WebAuthn via KeePassXC browser protocol: `{"action": "passkeys-get", "publicKey": {...}}` and `{"action": "passkeys-register", "publicKey": {...}}`. KeePassXC 2.8+ supports passkey storage. Bridge between Qutebrowser WebAuthn requests and KeePassXC: intercept `navigator.credentials.get()` / `navigator.credentials.create()` via Qutebrowser userscript that posts to Emacs IPC, Emacs forwards to KeePassXC, response returned to browser. `(defcustom exwm-secrets-passkeys-enabled t)`. Note: this is complex browser-compositor-Emacs-KeePassXC pipeline; mark as experimental. | 1 | GO: passkey registration on test WebAuthn site succeeds (experimental; ASK gate acceptable) |
| 14.11 | **D-Bus Secret Service provider integration.** Ensure compositor environment propagates `DBUS_SESSION_BUS_ADDRESS` correctly to all clients. Test that KeePassXC registers on session bus as `org.freedesktop.secrets`. Verify Emacs `secrets.el` connects. Test that SSH agent (`ssh-add`) can use KeePassXC for SSH key passphrase via Secret Service. Test that `git credential-libsecret` works. Document: environment variables needed, KeePassXC settings (Settings -> Secret Service Integration -> Enable), systemd unit ordering. | 1 | GO: `secret-tool lookup service ssh` returns data from KeePassXC; `git push` authenticates via libsecret |
| 14.12 | **End-to-end testing: Qutebrowser + KeePassXC full flow.** Test scenario: (a) Launch compositor + Emacs + KeePassXC + Qutebrowser. (b) Navigate to login page via gaze-based link following (Week 17 dependency; use keyboard for now). (c) `M-x exwm-secrets-autotype` detects URL from Qutebrowser. (d) Queries KeePassXC for matching credentials. (e) Auto-types username + Tab + password via compositor injection. (f) Gaze-away detection tested: look away mid-type -> verify pause. (g) TOTP auto-typed after 2FA page loads. (h) Secure input mode verified: no gaze data leaked during entire flow. Write as ERT integration test with mock KeePassXC (pre-populated test database). Target: >= 12 new ERT tests. | 2 | GO: full flow completes in automated test; >= 97 cumulative ERT tests |

**Research (parallel):**
- R14.1: Audit KeePassXC browser protocol for cryptographic soundness -- verify X25519-XSalsa20-Poly1305 implementation, check for replay attacks, verify nonce handling. Document any concerns. (1 agent)
- R14.2: Research Wayland input method security -- investigate whether compositor-level key injection bypasses IME (input method editor), whether injected events are distinguishable from physical keypresses by clients. (1 agent)
- R14.3: Survey alternative password managers with D-Bus Secret Service support -- Bitwarden CLI, `pass` (password-store), GNOME Keyring, KWallet. Assess whether `exwm-secrets.el` abstraction layer should support multiple backends. (1 agent)
- R14.4: Evaluate WebAuthn/FIDO2 passkey ecosystem maturity in Linux -- test sites (webauthn.io, passkeys.dev), browser support in QtWebEngine, KeePassXC passkey implementation completeness. (1 agent)

**Completion Metrics:**
- [ ] KeePassXC credentials accessible via `auth-source-search` (secrets.el backend)
- [ ] KeePassXC credentials accessible via browser protocol (NaCl encrypted)
- [ ] Auto-type via compositor injection: works on Qutebrowser, Firefox, terminal
- [ ] Auto-type via ydotool fallback: works when compositor injection unavailable
- [ ] Secure input mode: gaze visualization hidden during password entry
- [ ] Secure input mode: gaze events not forwarded to Emacs during password entry
- [ ] Secure input mode: EEG data logging paused during password entry
- [ ] Gaze-away detection: auto-type pauses within 600ms of gaze departure
- [ ] Gaze-away detection: auto-type aborts after 5 seconds of sustained gaze departure
- [ ] TOTP retrieval and auto-type: < 2s from request to code typed
- [ ] Passkey registration: succeeds on webauthn.io (experimental)
- [ ] D-Bus Secret Service: `secret-tool`, `git credential-libsecret`, `ssh-add` all work
- [ ] End-to-end login flow: < 5 seconds from command invocation to form submission
- [ ] >= 97 cumulative ERT tests passing

**Gate: GO/NOGO/ASK**
- GO if auto-type works via at least one backend AND secure input mode functional
- ASK if Wayland auto-type broken on all backends (investigate wtype as additional fallback)
- ASK if passkey support too fragile (mark experimental, defer to post-v0.1.0)
- NOGO if KeePassXC browser protocol handshake fails (verify KeePassXC version >= 2.7.0)

**Composability Notes:**
- Secure input mode (14.7) composes with ALL biometric inputs: gaze, wink, EEG, hand tracking all paused
- Auto-type target surface verified by gaze (eyes must be on the target surface)
- Wink could serve as "confirm auto-type" gesture (look at login form + wink = initiate)
- Future: BCI P300 confirmation for high-security operations (two-factor: gaze + brain)

**Parallelism Opportunities:**
- Stages 14.1 and 14.2 (D-Bus secrets.el vs browser protocol) are independent paths
- Stages 14.4 and 14.5 (ydotool vs compositor injection) are independent backends
- Stages 14.9 and 14.10 (TOTP vs passkeys) are independent features
- All 4 research agents run in parallel with build stages

**Integration Points:**
- Week 6: Qutebrowser + KeePassXC compatibility validated
- Week 12: gaze focus provides surface identification for auto-type targeting
- Week 13: wink detection paused during secure input mode
- Week 15: NixOS module must package KeePassXC, ydotool, and configure D-Bus
- Week 17: Qutebrowser deep integration adds URL detection for auto-type
- Week 19: OpenBCI EEG logging paused during secure input mode

---

## Phase 4: Enterprise & Platform (Weeks 15-17)

### Week 15: NixOS Module & Rocky Linux RPM

**Goal:** Production-quality NixOS module with `services.exwm-vr`; home-manager user configuration module; Cachix binary cache with Attic-style greedy caching; RPM spec for Rocky 9/10 with SELinux policy; complete first-boot experience on both platforms

**Dependencies:** Week 3 (compositor), Week 4 (IPC), Week 7 (Monado/OpenXR)

| Stage | Task | Agents | Gate |
|-------|------|--------|------|
| 15.1 | **NixOS module: `services.exwm-vr`.** Create `nix/modules/exwm-vr.nix` with full NixOS module interface. Options: `services.exwm-vr.enable = true;` (master switch), `services.exwm-vr.compositor.package` (override compositor derivation), `services.exwm-vr.emacs.package` (default: emacs-pgtk from emacs-overlay), `services.exwm-vr.emacs.extraPackages` (epkgs: list for bundled Elisp), `services.exwm-vr.vr.enable = true;` (OpenXR/Monado subsystem), `services.exwm-vr.vr.runtime = "monado";` (future: SteamVR), `services.exwm-vr.eyeTracking.enable = false;`, `services.exwm-vr.eyeTracking.backend = "pupil";` (or `"openxr"`), `services.exwm-vr.bci.enable = false;`, `services.exwm-vr.bci.device = "cyton";` (or `"cyton-daisy"`, `"synthetic"`). Module configures: systemd services, environment variables, udev rules for OpenBCI serial (`/dev/ttyUSB*`), user groups (video, input, plugdev). Assertions: if `vr.enable` then GPU must be detected; if `bci.enable` then BrainFlow must be in path. | 2 | GO: `nix eval .#nixosConfigurations.test.config.services.exwm-vr` succeeds with no evaluation errors |
| 15.2 | **NixOS module: Monado service.** Create `services.monado.enable` option (separate module, consumed by exwm-vr). Systemd user service `monado.service` with `Type=simple`, `ExecStart=${monado}/bin/monado-service`, environment: `XR_RUNTIME_JSON=${monado}/share/openxr/1/openxr_monado.json`. Socket activation: `monado.socket` listening on `$XDG_RUNTIME_DIR/monado_comp_ipc`. Dependencies: `After=graphical-session.target`. Config file generation: `/etc/xdg/openxr/1/active_runtime.json` pointing to Monado. Hardware-specific options: `services.monado.headset = "auto";` (or `"simulated"`, `"valve-index"`, `"quest3-wivrn"`). WiVRn integration: if headset is Quest 3, also start `wivrn-server.service`. | 2 | GO: `systemctl --user start monado.service` succeeds; `XR_RUNTIME_JSON` points to correct path |
| 15.3 | **Home-manager module.** Create `nix/home-manager/exwm-vr.nix`. User-level configuration: `programs.exwm-vr.enable = true;`, `programs.exwm-vr.config` (attrset mapped to `~/.config/exwm-vr/config.el`), `programs.exwm-vr.winkCalibration` (path to calibration JSON), `programs.exwm-vr.gazeZoneLayout = "default";`, `programs.exwm-vr.keepassxc.enable = true;`, `programs.exwm-vr.keepassxc.databasePath = "~/Passwords.kdbx";`, `programs.exwm-vr.theme = "modus-vivendi";` (generates Qutebrowser theme sync). Generate `~/.config/exwm-vr/config.el` from Nix attrset: convert Nix booleans to `t`/`nil`, strings to Elisp strings, integers to Elisp integers. Generate `~/.config/qutebrowser/exwm-vr-theme.py` from Emacs theme selection. | 1 | GO: `home-manager switch` produces correct `config.el` and Qutebrowser theme |
| 15.4 | **Cachix binary cache with Attic-style greedy caching.** Set up Cachix cache `exwm-vr` (or self-hosted Attic instance for GloriousFlywheel pattern). CI pushes: compositor binary (Rust, ~50MB), Emacs with bundled Elisp packages, Monado, BrainFlow Python environment, Pupil Capture. Cache key includes: Nixpkgs commit, Rust toolchain version, Emacs version. Greedy caching: push ALL build-time dependencies to cache (not just final outputs) so that partial rebuilds after Nixpkgs bump hit cache for unchanged deps. Configure `cachix watch-exec` in CI. Expected cache size: ~2GB for x86_64, ~2GB for aarch64. Cache retention: 90 days for non-latest, indefinite for tagged releases. GitHub Actions secret: `CACHIX_AUTH_TOKEN`. | 1 | GO: `nix build` on fresh machine completes in < 5 minutes (all cache hits) |
| 15.5 | **RPM spec for Rocky Linux 9/10.** Create `packaging/rpm/exwm-vr.spec`. BuildRequires: `rust-toolchain >= 1.75`, `emacs-pgtk >= 29.1`, `libwayland-devel`, `mesa-libEGL-devel`, `mesa-libgbm-devel`, `libinput-devel`, `libxkbcommon-devel`, `systemd-devel`, `openxr-devel`. Subpackages: `exwm-vr-compositor` (Rust binary), `exwm-vr-elisp` (Elisp files in `/usr/share/emacs/site-lisp/exwm-vr/`), `exwm-vr-monado` (Monado integration), `exwm-vr-bci` (BrainFlow + Python deps), `exwm-vr-selinux` (SELinux policy module). `%post` scriptlet: compile Elisp (`emacs --batch -f batch-byte-compile`), install SELinux module (`semodule -i`), reload udev rules. `%check`: run ERT tests in headless Emacs. Rocky 9: require EPEL for some deps. Rocky 10: most deps in base repos. | 2 | GO: `rpmbuild -ba exwm-vr.spec` succeeds on Rocky 10 mock build |
| 15.6 | **SELinux policy module.** Create `packaging/selinux/exwm_vr.te` (type enforcement), `exwm_vr.if` (interface), `exwm_vr.fc` (file contexts). Types: `exwm_vr_compositor_t` (compositor process), `exwm_vr_monado_t` (Monado), `exwm_vr_brainflow_t` (BrainFlow Python daemon). Allow rules: compositor needs `drm_device_t` (DRM), `input_device_t` (libinput), `user_tmp_t` (Wayland socket in `$XDG_RUNTIME_DIR`), `gpu_device_t` (GPU access). Monado needs `drm_device_t`, `usb_device_t` (HMD USB). BrainFlow needs `tty_device_t` (`/dev/ttyUSB0` for OpenBCI serial), `user_tmp_t` (Unix socket). Deny: network access for compositor (no outbound connections), file write outside designated dirs. Test with `semanage`, `audit2allow`, `sesearch`. | 2 | GO: compositor + Monado + BrainFlow start without SELinux denials in `enforcing` mode |
| 15.7 | **FIPS 140-3 considerations.** Document which cryptographic operations exist in the stack: (a) KeePassXC browser protocol uses X25519 + XSalsa20-Poly1305 (NaCl, NOT FIPS-approved). (b) WiVRn streaming uses DTLS (FIPS-approved ciphers available). (c) IPC uses Unix sockets (no crypto needed, local only). (d) Gaze/EEG data: local only, no crypto. Mitigation for FIPS environments: disable KeePassXC browser protocol, use D-Bus Secret Service instead (local IPC, no crypto). Document in `docs/fips-compliance.md`. Mark KeePassXC browser protocol as non-FIPS. Ensure OpenSSL in compositor links against FIPS-validated module if `OPENSSL_FIPS=1` set. | 1 | GO: documentation complete; FIPS-mode-compatible code path identified |
| 15.8 | **Systemd service files.** Create `packaging/systemd/exwm-vr-compositor.service` (user service): `Type=notify`, `ExecStart=/usr/bin/exwm-vr-compositor --wayland-socket $WAYLAND_DISPLAY`, `NotifyAccess=main`, `Restart=on-failure`, `Environment=WLR_RENDERER=gles2 XR_RUNTIME_JSON=/etc/xdg/openxr/1/active_runtime.json WAYLAND_DISPLAY=wayland-1`. Create `exwm-vr-emacs.service`: `Type=simple`, `ExecStart=/usr/bin/emacs --fg-daemon=exwm-vr`, `After=exwm-vr-compositor.service`, `BindsTo=exwm-vr-compositor.service`. Create `exwm-vr-brainflow.service`: `Type=simple`, `ExecStart=/usr/bin/exwm-vr-brainflow-daemon`, `After=exwm-vr-compositor.service`. Create `exwm-vr.target` that groups all services. | 1 | GO: `systemctl --user start exwm-vr.target` brings up compositor + Emacs + optional Monado |
| 15.9 | **Display manager integration.** Create desktop entry `packaging/desktop/exwm-vr.desktop` for display managers: `[Desktop Entry]\nName=EXWM-VR\nComment=VR-First Emacs Window Manager\nExec=exwm-vr-session\nType=Application\nDesktopNames=EXWM-VR`. Create `exwm-vr-session` wrapper script: sets environment variables (`WAYLAND_DISPLAY`, `XR_RUNTIME_JSON`, `XDG_CURRENT_DESKTOP=EXWM-VR`), starts `exwm-vr.target` via systemd, or direct-launches compositor + Emacs if systemd user session unavailable. Test with greetd (preferred for Wayland), SDDM (Qt-based), GDM (GNOME). Document login flow for each display manager. | 1 | GO: greetd shows EXWM-VR session option; selecting it boots to functional desktop |
| 15.10 | **Environment variables documentation and validation.** Document all required environment variables: `XR_RUNTIME_JSON` (path to active OpenXR runtime JSON), `WLR_RENDERER=gles2` (or `vulkan` for VR passthrough), `WAYLAND_DISPLAY` (socket name), `XDG_RUNTIME_DIR` (required by Wayland), `LIBINPUT_DEFAULT_KEYBOARD_LAYOUT` (optional), `DBUS_SESSION_BUS_ADDRESS` (for KeePassXC Secret Service), `EXWM_VR_CONFIG_DIR` (default `~/.config/exwm-vr`), `BRAINFLOW_BOARD_ID` (OpenBCI Cyton=0, Cyton+Daisy=2, Synthetic=-1). Implement `exwm-vr-check-environment` Elisp command that validates all required variables are set and paths exist. | 1 | GO: `M-x exwm-vr-check-environment` reports all green on correctly configured system |
| 15.11 | **OpenBCI/BrainFlow packaging.** For NixOS: create BrainFlow Nix derivation wrapping the Python package (`brainflow==5.x`) in a virtualenv or via `python3Packages.buildPythonPackage`. Include `numpy`, `scipy`, `numpysocket`. Pin BrainFlow version. For Rocky: create `exwm-vr-bci` RPM subpackage that installs a Python virtualenv to `/opt/exwm-vr/bci-venv/` with pinned pip packages. Udev rule for OpenBCI Cyton USB serial: `SUBSYSTEM=="tty", ATTRS{idVendor}=="0403", ATTRS{idProduct}=="6015", MODE="0666", GROUP="plugdev", SYMLINK+="openbci"`. Verify BrainFlow `BoardShim(0, params)` connects to `/dev/openbci`. | 1 | GO: `python3 -c "from brainflow.board_shim import BoardShim; print('OK')"` succeeds in packaged environment |
| 15.12 | **Pupil Labs packaging.** Pupil Capture ships as AppImage (not easily packaged). NixOS approach: wrap AppImage via `appimageTools.wrapType2`. Alternatively: package Pupil Labs from source (Python + OpenCV + pyglui). For Rocky: include AppImage in `/opt/exwm-vr/pupil/` with wrapper script. Neon headset: uses Pupil Cloud or Pupil Invisible Companion app -- document setup separately. Core headset: Pupil Capture runs locally, exposes ZMQ on `tcp://127.0.0.1:50020` (configurable via `(defcustom exwm-vr-pupil-zmq-address "tcp://127.0.0.1:50020")`). Package `pupil-labs-lsl-relay` for LSL (Lab Streaming Layer) integration if user prefers LSL over raw ZMQ. | 1 | GO: Pupil Capture launches from Nix/RPM package; ZMQ endpoint reachable |
| 15.13 | **Complete first-boot experience testing.** NixOS path: start from minimal NixOS install, add flake input `exwm-vr`, enable `services.exwm-vr.enable = true;`, `nixos-rebuild switch`, reboot, select EXWM-VR from greetd, verify desktop functional. Rocky path: start from Rocky 10 minimal install, `dnf install exwm-vr`, reboot, select EXWM-VR from GDM, verify desktop functional. Document both paths step-by-step in `docs/installation.md`. Measure time from package install to first working desktop: target < 10 minutes (NixOS with cache), < 15 minutes (Rocky with RPM). | 2 | GO: both first-boot paths documented and tested; target times met |

**Research (parallel):**
- R15.1: SELinux policy audit -- run `audit2allow -a` during full test session, identify all required permissions. Compare against minimal policy. Check for overly broad permissions that should be tightened. (1 agent)
- R15.2: FIPS 140-3 implications for TLS in VR streaming (WiVRn) -- determine which cipher suites WiVRn uses, whether FIPS-approved alternatives exist, impact on latency. (1 agent)
- R15.3: Survey Nix flake packaging patterns for Wayland compositors -- study niri-flake, Hyprland flake, sway NixOS module for best practices. Extract patterns for session management, environment variable propagation, GPU driver integration. (1 agent)
- R15.4: Rocky Linux EPEL dependency analysis -- enumerate which build/runtime dependencies require EPEL on Rocky 9 vs base repos on Rocky 10. Plan for EPEL-free installation path if possible. (1 agent)

**Completion Metrics:**
- [ ] NixOS: `nixos-rebuild switch` with exwm-vr module boots to functional VR WM
- [ ] NixOS: home-manager module generates correct user config files
- [ ] NixOS: Cachix cache hit rate > 95% for unchanged packages
- [ ] NixOS: fresh install completes in < 5 minutes (cached)
- [ ] Rocky: `rpmbuild` succeeds for x86_64 and aarch64
- [ ] Rocky: `dnf install exwm-vr` installs all subpackages
- [ ] Rocky: compositor starts without SELinux denials in enforcing mode
- [ ] SELinux: policy module covers compositor, Monado, BrainFlow
- [ ] Systemd: `exwm-vr.target` brings up full stack
- [ ] Display manager: greetd and at least one other DM show EXWM-VR session
- [ ] BrainFlow: packaged and functional on both NixOS and Rocky
- [ ] Pupil Capture: launchable from packaged environment
- [ ] First-boot: < 10 min NixOS, < 15 min Rocky
- [ ] >= 100 cumulative ERT tests passing

**Gate: GO/NOGO/ASK**
- GO if NixOS and Rocky x86_64 both produce functional desktop from clean install
- ASK if ARM64 GPU drivers problematic (defer ARM VR, keep headless)
- ASK if SELinux policy requires overly broad permissions (may need to iterate)
- NOGO if Emacs pgtk crashes on Rocky 10 (investigate pgtk build flags, consider Nix-on-Rocky fallback)

**Composability Notes:**
- NixOS module option tree directly maps to all defcustom variables in Elisp
- Home-manager config generation ensures consistency between Nix config and Emacs runtime
- SELinux policy composes with BCI (Week 19) serial device access

**Parallelism Opportunities:**
- Stages 15.1/15.2 (NixOS modules) and 15.5 (RPM spec) are fully independent platform tracks
- Stages 15.6 (SELinux) and 15.7 (FIPS) are independent security tracks
- Stages 15.11 (BrainFlow) and 15.12 (Pupil Labs) are independent hardware packaging
- All 4 research agents run in parallel with build stages

**Integration Points:**
- Week 1: flake.nix foundation consumed and extended here
- Week 3: compositor binary packaged into RPM/Nix
- Week 7: Monado service configuration
- Week 11: Pupil Labs packaging for eye tracking
- Week 14: KeePassXC packaging and D-Bus configuration
- Week 16: multi-architecture builds extend the packaging done here
- Week 19: BrainFlow packaging consumed by full BCI integration

---

### Week 16: Multi-Architecture & Cross-Compilation

**Goal:** Cross-compile for aarch64 from x86_64; headless compositor for s390x mainframes; aspirational RISC-V build; CI matrix across architectures; GPU driver compatibility matrix; container builds via nix2container; per-architecture binary caches and performance profiling

**Dependencies:** Week 15 (NixOS module, RPM spec), Week 3 (compositor)

| Stage | Task | Agents | Gate |
|-------|------|--------|------|
| 16.1 | **Nix cross-compilation x86_64 -> aarch64.** Configure `flake.nix` with `crossSystem = { system = "aarch64-linux"; }`. Cross-compile compositor Rust crate using `pkgsCross.aarch64-multiplatform.rustPlatform.buildRustPackage`. Handle cross-compilation challenges: (a) Smithay depends on `libdrm`, `libgbm`, `libinput`, `libwayland` -- all must be aarch64 versions. (b) Emacs pgtk: cross-compile via `pkgsCross.aarch64-multiplatform.emacs-pgtk`. (c) BrainFlow Python: use aarch64 Python with pre-built numpy wheels. Verify cross-compiled binaries with `file` command showing `ELF 64-bit LSB ... ARM aarch64`. Test on actual aarch64 hardware or QEMU user-mode emulation. Target: full Nix closure cross-compiles in < 30 minutes on 8-core x86_64. | 2 | GO: `nix build .#packages.aarch64-linux.compositor` produces valid aarch64 ELF binary |
| 16.2 | **Headless compositor mode for s390x (no GPU, terminal Emacs).** Implement `--headless` flag in compositor: skips DRM backend init, skips OpenXR, uses Smithay headless backend (in-memory buffers). Wayland clients still connect and render to off-screen buffers. Emacs runs in terminal mode (`emacs -nw`) under `tmux` or `screen` with full WM keybindings. IPC still functional: Emacs sends workspace/layout commands, compositor manages virtual surfaces. Use case: IBM Z mainframe running Rocky Linux, used for remote Emacs sessions over SSH. Compositor manages window layout even without display -- surfaces accessible via VNC/Wayland-to-VNC bridge or purely as logical workspace management for terminal Emacs. Implement `(defcustom exwm-vr-headless-mode nil)` that disables all VR/gaze/visual features. | 2 | GO: `exwm-vr-compositor --headless` starts; Emacs connects via IPC; workspace switching works in terminal |
| 16.3 | **RISC-V build attempt.** Try `pkgsCross.riscv64.rustPlatform.buildRustPackage` for compositor. Expected issues: (a) Smithay may not compile on riscv64 (missing platform support in dependencies). (b) Emacs pgtk likely works (Emacs has RISC-V support). (c) Monado unlikely to work (no VR on RISC-V). (d) BrainFlow may work (Python-based, numpy has RISC-V wheels in recent versions). Document every failure with specific error messages and upstream issue links. If compositor fails, try headless-only mode. Target: at minimum, Emacs + headless compositor + IPC working on riscv64. Mark as aspirational/experimental. | 1 | GO if headless mode works; NOGO expected for full stack, document gaps |
| 16.4 | **CI matrix (GitHub Actions).** Configure `.github/workflows/multi-arch.yml` with matrix: `{os: [ubuntu-latest], arch: [x86_64, aarch64], mode: [full, headless]}` plus `{os: [ubuntu-latest], arch: [s390x], mode: [headless]}`. For aarch64: use `runs-on: ubuntu-arm64` (GitHub Actions ARM runners) or QEMU emulation via `docker run --platform linux/arm64`. For s390x: use QEMU system emulation via `docker run --platform linux/s390x`. Build steps: (a) `nix build .#packages.$ARCH.compositor`, (b) run headless integration tests, (c) `cachix push exwm-vr`. Timeout: 60 minutes per job (cross-compilation is slow). Cache: Nix store cached between CI runs via `actions/cache`. Matrix total: 5 jobs (x86_64-full, x86_64-headless, aarch64-full, aarch64-headless, s390x-headless). | 2 | GO: CI matrix green for x86_64-full, x86_64-headless, aarch64-headless; aarch64-full and s390x-headless are ASK |
| 16.5 | **Container builds (OCI via nix2container).** Create OCI container images using `nix2container` (GloriousFlywheel pattern -- deterministic, layered, no Docker daemon needed). Images: (a) `exwm-vr-compositor:latest` -- minimal image with compositor binary + Wayland libs + DRM libs. (b) `exwm-vr-full:latest` -- compositor + Emacs + Monado + BrainFlow + Pupil relay. (c) `exwm-vr-headless:latest` -- headless compositor + terminal Emacs only (smallest image, ~200MB). (d) `exwm-vr-dev:latest` -- full stack + development tools (rust-analyzer, gdb, perf). Tag with git SHA and semver. Push to GitHub Container Registry (`ghcr.io/exwm-vr/`). Multi-arch manifests for x86_64 + aarch64. | 2 | GO: `docker run ghcr.io/exwm-vr/exwm-vr-headless:latest --headless` starts compositor in container |
| 16.6 | **GPU driver compatibility matrix validation.** Test compositor rendering on each GPU driver stack: (a) AMD radeonsi (OpenGL) + radv (Vulkan) -- primary target, expected full support. (b) Intel iris (OpenGL) + anv (Vulkan) -- secondary target, expected full support. (c) NVIDIA nouveau (OpenGL) -- limited (no Vulkan, no VR). (d) NVIDIA proprietary (OpenGL + Vulkan) -- test with `WLR_RENDERER=gles2` and `vulkan`; known Wayland issues with EGLStream vs GBM; require NVIDIA >= 535 for GBM support. (e) ARM Mali (Panfrost/Lima) -- aarch64 only, test on Raspberry Pi 5 or Pine64. (f) Qualcomm Adreno (Freedreno) -- aarch64, test on Snapdragon dev kit if available. Document results in `docs/gpu-compatibility.md` with columns: driver, GL version, Vulkan version, DMA-BUF import, DRM lease, VR support, compositor status. | 2 | GO: compatibility matrix documented with test results for >= 3 driver stacks |
| 16.7 | **Rocky Linux on IBM Z specifics.** Document `s390x` limitations: (a) No GPU -- llvmpipe software rendering only. (b) No VR (no HMD support). (c) No eye tracking (no USB for Pupil Labs; OpenBCI theoretically possible over serial-over-IP). (d) Compositor runs in headless mode. (e) Emacs runs in terminal mode (emacs-nox or emacs-pgtk over VNC). Build compositor with `--features headless-only` (disable DRM/OpenXR/EGL features at compile time, reducing binary size and dependency footprint). RPM subpackage `exwm-vr-headless` for s390x with minimal deps. Test on IBM LinuxONE Community Cloud (free tier). | 1 | GO: headless RPM installs and runs on s390x Rocky Linux; Emacs manages workspaces over SSH |
| 16.8 | **Rocky Linux on ARM64 (Raspberry Pi 5, NVIDIA Jetson).** Test RPM on aarch64 Rocky Linux 10. Raspberry Pi 5: VC4/V3D GPU driver (Mesa), test compositor with DRM backend. NVIDIA Jetson (Orin/Xavier): NVIDIA Tegra drivers, test with `WLR_RENDERER=gles2`. Pi 5 expectations: 2D compositor works, VR unlikely (no HMD driver support, insufficient GPU). Jetson expectations: 2D compositor works, VR possible with USB HMD (Index via USB). Eye tracking: Pupil Labs Core connects via USB, should work on both. OpenBCI: serial via USB, should work on both. Document performance: target 60fps for 2D compositor on Pi 5, 90fps VR on Jetson. | 1 | GO: compositor renders at >= 30fps on Pi 5; >= 60fps on Jetson (2D mode) |
| 16.9 | **Performance profiling per-architecture.** Run benchmark suite (from Week 20 design, implemented early) on each architecture: (a) Frame render time (compositor only, no Emacs IPC): target p50 < 5ms, p99 < 11ms on x86_64. (b) IPC round-trip latency: target < 1ms all architectures. (c) Gaze processing latency (eye tracker -> compositor -> Emacs): target < 20ms. (d) Memory usage: compositor RSS target < 100MB idle, < 300MB with 10 surfaces. (e) Startup time: compositor launch to first frame: target < 2s on x86_64, < 5s on aarch64. Profile with `perf stat`, `perf record` (x86_64/aarch64), or `operf` (s390x). Generate flamegraphs. Identify architecture-specific bottlenecks. | 2 | GO: benchmark results documented for x86_64 and aarch64; performance targets met on x86_64 |
| 16.10 | **Binary cache per-architecture.** Extend Cachix/Attic configuration to push builds for each architecture. CI workflow: after successful build on each arch, `cachix push exwm-vr $OUT_PATH`. Verify cache works: on clean x86_64 machine, `nix build .#packages.aarch64-linux.compositor` fetches from cache without building. Monitor cache storage: alert if total size > 10GB. Implement cache garbage collection: remove builds older than 90 days except tagged releases. Create `just cache-status` recipe showing cache hit rates per architecture. | 1 | GO: cache hit on `nix build` for x86_64 and aarch64 on clean machine |
| 16.11 | **Cross-architecture IPC compatibility testing.** Verify IPC protocol works across architectures: x86_64 compositor talking to aarch64 Emacs (via network IPC, future feature) and vice versa. Test s-expression encoding for endianness correctness (s-expressions are text, so endianness is not an issue -- verify this assumption). Test msgpack encoding (if used) for endianness. Verify all integer sizes, float representations, and string encodings are portable. Write ERT tests that parse IPC messages generated on each architecture. | 1 | GO: IPC messages generated on x86_64 parse correctly on aarch64 and vice versa |
| 16.12 | **Architecture-specific optimizations documentation.** Document: (a) x86_64: enable AVX2 for BrainFlow signal processing (`CFLAGS=-mavx2`), use Vulkan for VR rendering. (b) aarch64: enable NEON for signal processing, use GLES2 for rendering (wider driver compatibility). (c) s390x: no GPU optimizations, focus on IPC throughput. (d) RISC-V: no SIMD (V extension not yet widespread), baseline performance only. Create `docs/architecture-notes.md` with optimization flags, expected performance, known issues per arch. | 1 | GO: documentation complete with actionable optimization flags |

**Research (parallel):**
- R16.1: Benchmark QEMU user-mode emulation speed for CI -- compare native aarch64 build time vs QEMU-emulated on x86_64. Determine if GitHub ARM runners are cost-effective alternative. (1 agent)
- R16.2: Survey RISC-V Wayland compositor status -- check if any Smithay/wlroots compositor has been successfully built and run on RISC-V hardware. Identify specific blocking issues. (1 agent)
- R16.3: Research GPU passthrough for containerized compositor -- can compositor inside a container use host GPU via device mapping? Test with `--device /dev/dri`. Assess security implications. (1 agent)

**Completion Metrics:**
- [ ] x86_64: full VR stack builds and passes all tests
- [ ] aarch64: cross-compiled compositor binary is valid ELF, runs on aarch64 hardware/QEMU
- [ ] aarch64: 2D compositor renders at >= 30fps on aarch64 hardware
- [ ] s390x: headless compositor builds and runs on s390x (QEMU or real hardware)
- [ ] s390x: Emacs terminal mode + IPC functional
- [ ] RISC-V: build status documented with specific failure points
- [ ] CI matrix: >= 3 of 5 jobs green
- [ ] OCI containers: all 4 images build and push to ghcr.io
- [ ] GPU compatibility matrix: >= 3 driver stacks tested and documented
- [ ] Performance profiling: flamegraphs generated for x86_64 and aarch64
- [ ] Binary cache: per-architecture caches populated and verified
- [ ] IPC cross-architecture: messages roundtrip correctly
- [ ] >= 105 cumulative ERT tests passing

**Gate: GO/NOGO/ASK**
- GO if x86_64 full + aarch64 headless both work
- ASK if aarch64 full (with GPU) fails (may need specific GPU driver work)
- ASK if s390x QEMU too slow for CI (consider on-demand IBM Z cloud instances)
- ASK if RISC-V has unexpected blockers (deprioritize, document as future work)
- NOGO if cross-compilation fundamentally broken in Nix for our dependency tree

**Composability Notes:**
- Container images compose with CI/CD pipelines for automated testing
- Headless mode on s390x composes with remote access (SSH + tmux) for mainframe Emacs
- GPU compatibility matrix informs HMD compatibility matrix (Week 20 closing section)

**Parallelism Opportunities:**
- Stages 16.1 (cross-compile) and 16.2 (headless mode) are independent
- Stages 16.4 (CI) and 16.5 (containers) are independent build infrastructure
- Stages 16.6 (GPU matrix) and 16.7/16.8 (platform-specific) are independent
- All 3 research agents run in parallel with build stages

**Integration Points:**
- Week 15: NixOS module and RPM spec extended for multi-arch
- Week 3: compositor build system must support cross-compilation and headless feature flags
- Week 20: performance benchmarks started here, finalized in release week

---

### Week 17: Qutebrowser Deep Integration

**Goal:** Full qutebrowser.el port for Wayland surfaces; gaze-based link following implementing Apple Vision Pro "look and tap" pattern; gaze-based scrolling; theme sync; bookmark/history via consult sources; download manager; reader mode with VR-optimized rendering; ad blocking; tab-as-buffer management; userscript bridge

**Dependencies:** Week 5 (ewwm.el), Week 6 (Qutebrowser under compositor), Week 12 (gaze focus), Week 13 (wink confirmation)

| Stage | Task | Agents | Gate |
|-------|------|--------|------|
| 17.1 | **Port qutebrowser.el for ewwm.** Fork existing `qutebrowser.el` package. Replace all X11 window ID references with Wayland surface IDs from ewwm surface-buffer mapping. Core functions to port: `qutebrowser-open-url` (send `:open URL` to qutebrowser), `qutebrowser-yank-url` (get current URL), `qutebrowser-back`/`forward`/`reload`, `qutebrowser-zoom-in`/`out`/`reset`. Surface identification: match qutebrowser surface by `app_id = "org.qutebrowser.qutebrowser"` from `xdg_toplevel.set_app_id`. Multiple qutebrowser windows: track via `ewwm-surface-alist` filtered by app_id. Implement `(ewwm-qutebrowser-current-surface)` returning the focused qutebrowser surface ID. All commands route through FIFO/socket IPC (stage 17.2). | 2 | GO: `M-x qutebrowser-open-url RET https://example.com RET` opens URL in focused qutebrowser window |
| 17.2 | **FIFO/socket IPC for qutebrowser commands.** Qutebrowser exposes IPC via: (a) FIFO at `$XDG_RUNTIME_DIR/qutebrowser/ipc-$(echo -n $USER | md5sum | cut -d' ' -f1)`. (b) Socket-based IPC via `--ipc-socket` flag (preferred, bidirectional). Implement `ewwm-qutebrowser-ipc.el`: connect to qutebrowser IPC socket, send JSON-RPC commands. Command protocol: `{"args": [":open https://example.com"], "target_arg": null, "protocol_version": 1}`. Response parsing: monitor for completion. For multi-window: each qutebrowser instance has separate IPC endpoint; map surface-id -> IPC socket. Implement `(ewwm-qutebrowser-command SURFACE-ID CMD &rest ARGS)` dispatcher. Handle qutebrowser restart: reconnect IPC on surface creation event. | 2 | GO: `(ewwm-qutebrowser-command surf-id ":open" "https://example.com")` returns success; page loads |
| 17.3 | **Gaze-based link following -- compositor side.** Implement link hint overlay system in compositor. When user activates gaze-follow mode (keybind or voice command), compositor queries qutebrowser for clickable element positions via userscript (see 17.12). Qutebrowser userscript returns JSON: `[{"id": 0, "text": "Link Text", "rect": {"x": 100, "y": 200, "w": 150, "h": 20}, "url": "https://..."}, ...]`. Compositor renders small hint labels (1-2 char codes like qutebrowser's default hint mode) overlaid at each element position. Gaze ray intersects with hint bounding boxes. When gaze dwells on a hint for 300ms, highlight it (bold border, color change). This is the "look" phase of Apple Vision Pro "look and tap." Emit `(:gaze-hint :hint-id 3 :text "Link Text" :url "https://..." :surface-id 42)` to Emacs. | 2 | GO: link hints visible in VR; gaze correctly highlights the hint user is looking at |
| 17.4 | **Gaze-based link following -- confirmation.** "Tap" phase of "look and tap": once gaze highlights a hint, user confirms with: (a) Wink (left wink = open in current tab, right wink = open in new tab) -- from Week 13 wink detection. (b) Pinch gesture (from Week 18 hand tracking, if available). (c) Keyboard press (Enter = current tab, Shift+Enter = new tab). (d) P300 BCI confirmation (from Week 13/19, if OpenBCI connected). (e) Dwell timeout (800ms total dwell = auto-confirm, configurable, disabled by default to prevent Midas touch). On confirmation: send `:hint-follow HINT_ID` to qutebrowser via IPC. Clear hint overlay. `(defcustom exwm-vr-gaze-follow-confirm-method 'keyboard)` with values: `'keyboard`, `'wink`, `'pinch`, `'dwell`, `'p300`. | 1 | GO: gaze + wink-confirm opens correct link; gaze + keyboard-confirm opens correct link |
| 17.5 | **Gaze-based scrolling.** Compositor implements gaze-triggered scroll events. When gaze is in top 10% of surface: emit `wl_pointer.axis` events for scroll-up. When gaze in bottom 10% of surface: scroll-down. Velocity proportional to gaze distance from center: at very top edge = fast scroll (10 lines/frame), at 10% boundary = slow scroll (1 line/frame). Linear interpolation between. Horizontal scrolling: gaze at left/right 10% edges. Scroll events sent to the focused Wayland surface (qutebrowser receives them as normal mouse wheel). Activation: only when `exwm-vr-gaze-scroll-mode` active (toggled by keybind or gaze-zone modifier). Deactivation: automatic when gaze returns to center 80% of surface. Smooth scrolling: emit fractional pixel scroll events at 60Hz for buttery feel. `(defcustom exwm-vr-gaze-scroll-speed 5.0)` -- multiplier. `(defcustom exwm-vr-gaze-scroll-edge-pct 0.10)` -- edge zone size. | 2 | GO: looking at bottom edge scrolls page down; scroll speed increases with gaze distance from center |
| 17.6 | **Theme sync: Emacs theme -> qutebrowser.** Implement `ewwm-qutebrowser-theme.el`. Extract colors from current Emacs face definitions: `(face-attribute 'default :background)`, `:foreground`, `(face-attribute 'mode-line :background)`, `(face-attribute 'highlight :background)`, etc. Map to qutebrowser config variables: `c.colors.webpage.bg`, `c.colors.tabs.bar.bg`, `c.colors.statusbar.normal.bg`, `c.colors.completion.fg`, `c.colors.hints.bg`, etc. Generate `~/.config/qutebrowser/exwm-vr-theme.py` with `config.source('exwm-vr-theme.py')` in `config.py`. Auto-regenerate on `(load-theme)` via `after-load-theme-hook`. Send `:config-source` to qutebrowser via IPC to hot-reload. Support both light and dark Emacs themes. `(defcustom exwm-vr-qutebrowser-theme-sync t)`. | 1 | GO: switching Emacs theme from modus-vivendi to modus-operandi updates qutebrowser colors within 2 seconds |
| 17.7 | **Bookmark/history integration via consult sources.** Implement `ewwm-qutebrowser-consult.el`. Define `consult--source-qutebrowser-bookmarks`: read `~/.local/share/qutebrowser/bookmarks/urls` (format: `URL TITLE` per line). Define `consult--source-qutebrowser-history`: read `~/.local/share/qutebrowser/history.sqlite` via `sqlite-mode` or `emacsql-sqlite`. Query: `SELECT url, title, atime FROM History ORDER BY atime DESC LIMIT 1000`. Define `consult--source-qutebrowser-quickmarks`: read `~/.config/qutebrowser/quickmarks`. Integrate into `consult-buffer` as additional sources. Custom command `(defun ewwm-qutebrowser-consult-open ()` that combines all three sources and opens selected URL in qutebrowser. Use `marginalia` annotations for URL preview. | 1 | GO: `M-x ewwm-qutebrowser-consult-open` shows bookmarks + history + quickmarks; selecting one opens URL |
| 17.8 | **Download manager integration.** Hook into qutebrowser's download system via IPC event `download-started`. Display download progress in Emacs mode-line or dedicated `*Downloads*` buffer. Implement `ewwm-qutebrowser-downloads.el`: subscribe to download events, display file name, size, progress percentage, speed. On download complete: notify via Emacs `notifications-notify`. Open downloaded file with `(find-file PATH)` or `(async-shell-command (format "xdg-open %s" PATH))`. Cancel download from Emacs: send `:download-cancel ID` via IPC. `(defcustom exwm-vr-qutebrowser-download-dir "~/Downloads")`. | 1 | GO: download progress visible in Emacs; download completion triggers notification |
| 17.9 | **Reader mode with VR-optimized rendering.** Implement qutebrowser userscript `exwm-vr-reader.js` that extracts article content (using Mozilla Readability.js or similar). Inject extracted content into a new page with VR-optimized CSS: large fonts (18pt base), high contrast, wide line spacing (1.8em), max-width 60ch, dark background matching Emacs theme. In VR mode: render reader-mode content on a curved surface (cylindrical projection from Week 8) positioned at optimal reading distance (1.2m virtual). `(defcustom exwm-vr-reader-font-size 18)`. `(defcustom exwm-vr-reader-line-spacing 1.8)`. Trigger via keybind or Emacs command `(ewwm-qutebrowser-reader-mode)`. | 1 | GO: reader mode renders article with VR-optimized typography; readable at 1.2m in VR |
| 17.10 | **Ad blocker integration.** Qutebrowser supports Brave-compatible ad blocking via `c.content.blocking.method = "both"` (host-based + Brave adblock). Configure via Emacs: `(defcustom exwm-vr-adblock-lists '("https://easylist.to/easylist/easylist.txt" "https://easylist.to/easylist/easyprivacy.txt"))`. Generate `~/.config/qutebrowser/adblock-config.py` setting `c.content.blocking.adblock.lists`. Update lists on demand via `(ewwm-qutebrowser-adblock-update)` which sends `:adblock-update` via IPC. Display blocked request count in mode-line. Note: full uBlock Origin is not available in QtWebEngine; Brave adblock is the best available alternative. | 1 | GO: ad blocking active; blocked count visible; list update command works |
| 17.11 | **Tab management via Emacs buffers.** Each qutebrowser tab appears as a separate Emacs buffer in `ewwm-qutebrowser-mode`. Buffer name format: `*QB: Page Title*`. Buffer-local variables: `ewwm-qutebrowser-url`, `ewwm-qutebrowser-tab-id`, `ewwm-qutebrowser-surface-id`. Switching to a qutebrowser buffer in Emacs focuses that tab in qutebrowser: `(add-hook 'ewwm-buffer-focus-hook #'ewwm-qutebrowser--sync-tab)`. Closing buffer closes tab: `(add-hook 'kill-buffer-hook #'ewwm-qutebrowser--close-tab)`. New tab from Emacs: `(ewwm-qutebrowser-new-tab &optional URL)`. Tab tree visualization in Emacs buffer (parent-child tab relationships). Integrate with `consult-buffer` so `C-x b` shows all browser tabs alongside Emacs buffers. | 2 | GO: each QB tab is an Emacs buffer; switching buffer switches tab; closing buffer closes tab |
| 17.12 | **Userscript bridge for custom page automation.** Implement bidirectional bridge between qutebrowser userscripts and Emacs. Qutebrowser userscripts write to FIFO (`$QUTE_FIFO`); our bridge monitors this FIFO and forwards events to Emacs via compositor IPC. Emacs can trigger userscripts via `(ewwm-qutebrowser-run-userscript NAME &rest ARGS)`. Pre-built userscripts: (a) `exwm-vr-hints.js` -- extract clickable element positions for gaze-based link following (stage 17.3). (b) `exwm-vr-reader.js` -- extract article for reader mode (stage 17.9). (c) `exwm-vr-form-fill.js` -- expose form fields for KeePassXC integration (Week 14). (d) `exwm-vr-tab-tree.js` -- extract tab parent-child relationships. Userscript directory: `~/.local/share/qutebrowser/userscripts/exwm-vr/`. Install via NixOS home-manager module (Week 15). | 2 | GO: userscript returns clickable element positions; Emacs receives the data; gaze-follow pipeline works end-to-end |

**Research (parallel):**
- R17.1: Benchmark QtWebEngine accessibility tree API -- can we get element positions without userscripts? Test `QWebEngineView::page()->runJavaScript()` latency for DOM queries. Compare against userscript FIFO approach. (1 agent)
- R17.2: Research alternative VR-first browsers -- investigate Nickel, Servo, and other Rust-based browser engines. Assess whether a more deeply integrated browser could replace qutebrowser long-term. (1 agent)
- R17.3: Apple Vision Pro Safari integration analysis -- study how visionOS Safari handles gaze-based link targeting, scroll acceleration curves, and tab management. Extract UX patterns applicable to our qutebrowser integration. (1 agent)
- R17.4: Profile qutebrowser memory usage with many tabs -- determine practical tab count limit. Test with 50, 100, 200 tabs. Measure RSS, swap, QtWebEngine process count. Inform tab-as-buffer design. (1 agent)

**Completion Metrics:**
- [ ] All qutebrowser.el core commands work via Wayland surface IPC
- [ ] Gaze-based link following: > 80% correct link identified on first gaze dwell
- [ ] Gaze-based link following: end-to-end latency (gaze dwell -> page load) < 1.5s
- [ ] Gaze scrolling: smooth, correct direction, proportional speed
- [ ] Theme sync: colors match within 1 second of Emacs theme switch
- [ ] Consult sources: bookmarks, history, quickmarks all searchable
- [ ] Download manager: progress visible, completion notified
- [ ] Reader mode: article readable in VR at 1.2m virtual distance
- [ ] Ad blocker: blocks ads on test sites (EasyList coverage)
- [ ] Tab-as-buffer: switching Emacs buffer switches qutebrowser tab
- [ ] Userscript bridge: element positions extracted and received by compositor
- [ ] >= 110 cumulative ERT tests passing

**Gate: GO/NOGO/ASK**
- GO if browser usable with gaze + keyboard for daily browsing
- ASK if gaze-based link following accuracy < 70% (fall back to keyboard hints with gaze pre-filtering)
- ASK if QtWebEngine accessibility tree API is more reliable than userscripts (switch approach)
- NOGO if qutebrowser IPC fundamentally broken under our compositor (investigate alternative: Nyxt browser with Common Lisp IPC)

**Composability Notes:**
- Gaze link following composes with ALL confirmation methods: wink (13), pinch (18), keyboard, P300 (19)
- Tab-as-buffer composes with `consult-buffer` and all buffer-switching commands (including wink-switch from 13)
- Theme sync composes with home-manager module (15) for declarative configuration
- Userscript bridge is the glue layer enabling compositor-level gaze to interact with page-level DOM

**Parallelism Opportunities:**
- Stages 17.1/17.2 (core port + IPC) are prerequisite; all other stages can parallelize after
- Stages 17.6 (theme), 17.7 (consult), 17.8 (downloads), 17.10 (adblock) are fully independent
- Stages 17.3/17.4 (gaze follow) depend on 17.12 (userscript bridge) -- start 17.12 early
- All 4 research agents run in parallel with build stages

**Integration Points:**
- Week 6: qutebrowser compatibility validation
- Week 12: gaze focus for surface-level targeting
- Week 13: wink confirmation for link following
- Week 14: KeePassXC form-fill via userscript bridge
- Week 15: packaging, home-manager module installs userscripts
- Week 18: pinch gesture as alternative link confirmation

---

## Phase 5: Advanced Input & Transhumanism (Weeks 18-19)

### Week 18: Hand Tracking & VR Controllers

**Goal:** Full OpenXR controller input with configurable keymaps per interaction profile; optical hand tracking with 26-joint skeleton per hand; pinch-to-click with per-finger discrimination; gesture recognition framework with trainable custom gestures; hand + gaze composability implementing Apple Vision Pro "look and tap"; haptic feedback system; controller and hand skeleton rendering in VR scene

**Dependencies:** Week 7 (OpenXR session), Week 10 (VR interaction), Week 12 (gaze focus)

| Stage | Task | Agents | Gate |
|-------|------|--------|------|
| 18.1 | **OpenXR controller input: action system.** Implement OpenXR action system in compositor. Create `XrActionSet` named "exwm-vr-actions". Define actions: `select` (trigger/click, type `XR_ACTION_TYPE_BOOLEAN_INPUT`), `grab` (grip, `BOOLEAN`), `scroll` (thumbstick Y, `FLOAT`), `workspace_switch` (thumbstick X, `FLOAT`), `modifier_ctrl` (A/X button, `BOOLEAN`), `modifier_meta` (B/Y button, `BOOLEAN`), `menu` (menu button, `BOOLEAN`), `aim_pose` (controller aim pose, `POSE`), `grip_pose` (controller grip pose, `POSE`), `haptic` (haptic output, `VIBRATION`). Bind to interaction profiles: `/interaction_profiles/valve/index_controller` (Index), `/interaction_profiles/oculus/touch_controller` (Quest), `/interaction_profiles/htc/vive_controller` (Vive), `/interaction_profiles/khr/simple_controller` (fallback). Use `xrSuggestInteractionProfileBindings()` for each. Sync actions every frame via `xrSyncActions()`. | 2 | GO: trigger press on Index/Quest controller detected; aim pose provides ray direction |
| 18.2 | **Controller button -> Emacs command mapping.** Implement `exwm-vr-controller.el` with configurable keymaps. Default bindings: trigger = `select` (mouse click at aim ray intersection), grip = `grab-window` (grab focused surface), thumbstick-up = `scroll-down`, thumbstick-down = `scroll-up`, thumbstick-left = `previous-buffer`, thumbstick-right = `next-buffer`, A/X = `C-` modifier, B/Y = `M-` modifier, menu = `M-x`. Configurable via `(defcustom exwm-vr-controller-map (make-sparse-keymap))` with `(define-key exwm-vr-controller-map [trigger] #'ewwm-select)`. Support simultaneous left+right controller: left for navigation, right for interaction (or user-swapped). Compositor forwards button state changes via IPC: `(:controller :hand :left :button :trigger :state :pressed :timestamp ...)`. Emacs dispatches through keymap. | 2 | GO: trigger press -> click at aim point; grip press -> window grab; thumbstick -> buffer switch |
| 18.3 | **OpenXR hand tracking: joint data acquisition.** Enable `XR_EXT_hand_tracking` extension. Create `XrHandTrackerEXT` for each hand via `xrCreateHandTrackerEXT()`. Each frame, call `xrLocateHandJointsEXT()` to get `XrHandJointLocationsEXT` with 26 joints per hand: `XR_HAND_JOINT_PALM_EXT` (0), `XR_HAND_JOINT_WRIST_EXT` (1), `XR_HAND_JOINT_THUMB_METACARPAL_EXT` (2) through `XR_HAND_JOINT_LITTLE_TIP_EXT` (25). Each joint provides `XrPosef` (position + orientation quaternion) and `radius` (float, joint sphere radius). Check `XR_HAND_TRACKING_DATA_SOURCE_UNOBSTRUCTED_EXT` vs `XR_HAND_TRACKING_DATA_SOURCE_CONTROLLER_EXT` via `XR_EXT_hand_tracking_data_source` to distinguish optical tracking from controller-inferred hand pose. Store joint data in per-hand ring buffer (last 10 frames for velocity/gesture computation). Emit compressed hand data to Emacs via IPC only on significant change (delta > 1mm position or > 2deg orientation). | 2 | GO: 26 joint positions per hand received at >= 30Hz; joint radius data available |
| 18.4 | **Pinch-to-click detection algorithm.** Implement `PinchDetector` in compositor. Compute distance between thumb tip (`THUMB_TIP`, joint 4) and each fingertip: index (`INDEX_TIP`, joint 9), middle (`MIDDLE_TIP`, joint 14), ring (`RING_TIP`, joint 19), little (`LITTLE_TIP`, joint 24). Pinch detected when tip-to-tip distance < threshold (default: 2.0cm, configurable). Per-finger pinch mapping: index pinch = primary click (left click), middle pinch = secondary click (right click), ring pinch = middle click, little pinch = reserved (custom action). State machine: `Open` -> `Approaching` (distance < 4cm) -> `Pinched` (distance < 2cm) -> `Released` (distance > 3cm, hysteresis). Debounce: ignore state changes within 50ms to prevent jitter. Emit IPC: `(:hand-pinch :hand :right :finger :index :state :pinched :distance-mm 15.2 :timestamp ...)`. Reference: KWin VR MR implements finger pinch bindings with similar distance thresholds. | 2 | GO: index pinch detected within 50ms of physical pinch; false positive rate < 3% during normal hand movement |
| 18.5 | **Hand gesture recognition framework.** Implement `GestureRecognizer` struct in compositor. Define gestures as joint configuration templates: (a) **Pinch** -- thumb tip near index tip, other fingers extended. (b) **Point** -- index finger extended, all others curled (thumb metacarpal-to-tip angle < 30deg, index angle > 150deg, others < 60deg). (c) **Fist** -- all fingers curled (all tip-to-metacarpal distances < 4cm). (d) **Open palm** -- all fingers extended (all tip-to-metacarpal distances > 8cm), palm facing user. (e) **Thumbs up** -- thumb extended upward (tip Y > wrist Y + 5cm), all fingers curled. (f) **Peace sign** -- index and middle extended, ring and little curled. Gesture matching: compute feature vector (5 finger curl angles + palm orientation) per frame, compare against templates using cosine similarity, threshold > 0.85. Hold time: gesture must persist for > 200ms to confirm (prevents transient misclassification). | 2 | GO: >= 5 gestures recognized with > 85% accuracy on test recordings |
| 18.6 | **Gesture -> Emacs command mapping.** Default gesture bindings: pinch = `select` (confirm gaze target -- Apple Vision Pro pattern), point = `aim-ray` (override head-gaze with finger ray), fist = `grab-window` (grab + move focused surface), open-palm = `release` (release grabbed window, cancel current action), thumbs-up = `confirm` (approve dialog, save file), peace = `workspace-next`. Configurable via `(defcustom exwm-vr-gesture-map '((pinch . ewwm-select) (point . ewwm-aim-ray) (fist . ewwm-grab) (open-palm . ewwm-release) (thumbs-up . ewwm-confirm) (peace . ewwm-workspace-next)))`. IPC: `(:gesture :hand :right :gesture :thumbs-up :confidence 0.92 :timestamp ...)`. | 1 | GO: thumbs-up gesture triggers `ewwm-confirm`; peace sign switches workspace |
| 18.7 | **Custom gesture training framework.** Implement `exwm-vr-gesture-train` interactive command in Emacs. Opens training buffer: "Perform gesture 'my-custom-gesture' 10 times. Press SPACE when ready for each sample." Records 10 samples of joint configuration. Computes mean template and variance. Saves to `~/.config/exwm-vr/custom-gestures.json`. Add to gesture recognizer at runtime via IPC: `(:gesture-template-add :name "my-custom-gesture" :template [...] :threshold 0.85)`. Users can define arbitrarily many custom gestures and bind them to any Emacs command. Constraint: at most 20 total gestures (including built-in) to maintain real-time performance. | 1 | GO: custom gesture trained in < 2 minutes; recognized in live use with > 80% accuracy |
| 18.8 | **Hand + Gaze composability (Apple Vision Pro pattern).** Implement the core "look and tap" interaction paradigm. Pipeline: (a) User looks at target (gaze identifies surface + position from Week 12). (b) Compositor highlights gaze target with subtle cursor/ring. (c) User pinches to confirm selection. (d) Compositor sends click event at gaze intersection point (NOT at hand position). This decouples pointing (eyes, high-bandwidth, ~200 degrees FOV) from confirmation (hands, intentional motor action). Alternative mode: hand-aimed pointing -- point gesture overrides gaze with finger ray from index tip through index distal phalanx direction. `(defcustom exwm-vr-pointing-mode 'gaze)` with values: `'gaze` (eyes aim, hand confirms), `'hand` (hand aims, trigger/pinch confirms), `'hybrid` (gaze for coarse, hand for fine adjustment). Hybrid mode: gaze provides initial 5-degree targeting cone, hand ray refines within cone. | 2 | GO: in `'gaze` mode, pinch confirms selection at gaze point; in `'hand` mode, finger ray selects target |
| 18.9 | **Haptic feedback system.** Implement haptic event emission via OpenXR `XR_OUTPUT_HAPTIC` action. `xrApplyHapticFeedback()` with `XrHapticVibration { duration: ..., frequency: ..., amplitude: ... }`. Haptic events: (a) Focus change: short pulse (duration=50ms, frequency=200Hz, amplitude=0.3). (b) Window snap to grid: medium pulse (100ms, 150Hz, 0.5). (c) Window boundary reached: double pulse (2x 30ms, 300Hz, 0.4, 50ms gap). (d) Gaze zone activation: gentle buzz (80ms, 100Hz, 0.2). (e) Error/denied action: long vibration (200ms, 400Hz, 0.8). (f) Texture feedback: continuous low vibration while hand hovers over window surface (20ms pulses at 60Hz, amplitude proportional to surface content -- text areas buzz faintly, images buzz differently). `(defcustom exwm-vr-haptic-enabled t)`. `(defcustom exwm-vr-haptic-intensity 1.0)` -- global multiplier (0.0 to 2.0). Map Emacs events to haptic via `(defcustom exwm-vr-haptic-map '((focus-change . (:duration 50 :frequency 200 :amplitude 0.3)) ...))`. | 1 | GO: haptic pulse felt on controller when focus changes; haptic map configurable |
| 18.10 | **Controller render models in VR scene.** Retrieve controller render models via OpenXR `XR_FB_render_model` extension (Quest) or `XR_MSFT_controller_model` (WMR) or fallback generic models. Render controller mesh at grip pose position each frame. When hand tracking active, hide controller models and show hand skeleton instead. Transition: if controller detected in hand (data source = `CONTROLLER_EXT`), show controller; if optical tracking (data source = `UNOBSTRUCTED_EXT`), show hand skeleton. Compositor loads GLTF/GLB model files, renders via existing GL pipeline. | 1 | GO: controller model visible in VR at correct position/orientation; model follows hand movement |
| 18.11 | **Hand skeleton visualization.** Render hand skeleton as: (a) Spheres at each joint (radius from `XrHandJointLocationEXT.radius`). (b) Cylinders connecting adjacent joints (bones). (c) Semi-transparent mesh skin (optional, lower priority). Color coding: relaxed hand = blue, active gesture = green, pinch in progress = yellow, grab = red. Ghost trail: render previous 3 frames at decreasing opacity for motion feedback. Performance: hand rendering must not exceed 0.5ms per frame per hand (measured via GPU timestamp queries). `(defcustom exwm-vr-hand-visualization 'skeleton)` with values: `'skeleton`, `'spheres-only`, `'mesh`, `'none`. | 1 | GO: hand skeleton visible in VR; colors change with gesture state; < 0.5ms render time |
| 18.12 | **Integration tests for controller and hand tracking.** Test with synthetic controller input (mock OpenXR actions). Test with recorded hand tracking data (pre-recorded joint positions played back). Tests: (a) controller trigger -> click at correct position, (b) thumbstick -> buffer switch, (c) pinch detection -> correct finger identified, (d) gesture recognition -> correct gesture classified, (e) gaze + pinch -> click at gaze point (not hand point), (f) haptic emission -> correct parameters sent to OpenXR, (g) custom gesture training -> roundtrip save/load/recognize. Target: >= 12 new ERT tests. | 2 | GO: all hand/controller tests pass; >= 120 cumulative ERT tests |
| 18.13 | **Controller interaction profile auto-detection.** On OpenXR session start, query `xrGetCurrentInteractionProfile()` for each hand. Map detected profile to appropriate binding set. Support runtime controller swap (e.g., user switches from Index to Quest controllers mid-session via WiVRn reconnect). Log detected profile: `(message "EXWM-VR: Detected controller: Valve Index (left), Valve Index (right)")`. If no controller detected and hand tracking available, auto-switch to hand-only mode. If neither available, graceful fallback to head-gaze only (Week 10). | 1 | GO: correct interaction profile detected; bindings applied; fallback to hand/gaze on controller disconnect |

**Research (parallel):**
- R18.1: Benchmark hand tracking latency on different HMDs -- measure time from physical hand movement to joint data available in compositor. Compare Quest 3 (integrated) vs Ultraleap (external). Target: < 20ms. (1 agent)
- R18.2: Study KWin VR MR hand interaction implementation -- extract patterns for grab/move/resize via hand tracking. Note differences from our approach. (1 agent)
- R18.3: Research one-handed interaction patterns for accessibility -- some users may only have use of one hand. Design complete WM interaction using only left OR only right hand + gaze. Document in `docs/accessibility.md`. (1 agent)
- R18.4: Evaluate Ultraleap (Leap Motion) as additional hand tracking source outside VR -- Ultraleap provides skeletal hand tracking without HMD, useful for flat-screen gaze+hand setup. Assess OpenXR integration via Ultraleap's OpenXR hand tracking layer. (1 agent)
- R18.5: Profile gesture recognition CPU cost -- measure time per frame for 6+ gesture templates with 26 joints x 2 hands. Ensure < 0.2ms per frame. Consider SIMD optimizations if needed. (1 agent)

**Completion Metrics:**
- [ ] Controller actions bound for >= 3 interaction profiles (Index, Quest, simple)
- [ ] Controller button -> Emacs command: all default bindings functional
- [ ] Hand tracking: 26 joints per hand received at >= 30Hz
- [ ] Pinch-to-click: true positive > 95%, false positive < 3%
- [ ] Per-finger pinch: index, middle, ring correctly discriminated
- [ ] Gesture recognition: >= 5 gestures at > 85% accuracy
- [ ] Custom gesture training: trainable in < 2 minutes, usable in live session
- [ ] Gaze + pinch "look and tap": works end-to-end (gaze selects, pinch confirms)
- [ ] Haptic feedback: felt on controller for focus change and window snap events
- [ ] Controller/hand visualization: visible in VR scene
- [ ] Hand skeleton render time: < 0.5ms per frame per hand
- [ ] Interaction profile auto-detection: correct on Index and Quest
- [ ] >= 120 cumulative ERT tests passing

**Gate: GO/NOGO/ASK**
- GO if pinch-to-click works AND at least 3 gestures recognized AND gaze+pinch composability functional
- ASK if hand tracking accuracy too low on target HMD (fall back to controller-only with degraded gesture set)
- ASK if Ultraleap provides better flat-screen hand tracking than webcam-based alternatives
- NOGO if OpenXR hand tracking extension not supported by Monado for any tested HMD (major gap)

**Composability Notes:**
- Hand pinch replaces wink (Week 13) as confirmation for users who prefer hand over eye
- Gaze + pinch is the primary "look and tap" paradigm (Apple Vision Pro pattern)
- Controller thumbstick competes with wink for buffer switching -- user configures preferred modality
- Haptic feedback composes with all events: gaze zone activation, focus change, BCI confirmation
- Hand tracking data could feed BCI motor imagery training (Week 19) as ground truth for movement

**Parallelism Opportunities:**
- Stages 18.1/18.2 (controllers) and 18.3/18.4/18.5 (hand tracking) are independent tracks
- Stages 18.9 (haptics), 18.10 (controller rendering), 18.11 (hand rendering) are independent
- Stage 18.8 (gaze+hand composability) requires 18.4 (pinch) and Week 12 (gaze) -- start after both complete
- All 5 research agents run in parallel with build stages

**Integration Points:**
- Week 10: VR interaction (head-gaze ray) extended with hand-aimed ray
- Week 12: gaze focus provides targeting for "look and tap"
- Week 13: wink detection competes/composes with pinch confirmation
- Week 17: qutebrowser gaze link following uses pinch as confirmation method
- Week 19: hand tracking data feeds BCI motor imagery calibration
- Week 20: performance benchmarks include hand tracking latency

---

### Week 19: OpenBCI Full Harness & BCI Integration

**Goal:** Full OpenBCI Cyton/Cyton+Daisy EEG harness integration as first-class input modality; BrainFlow-powered signal processing pipeline; attention/focus monitoring with WM behavior adaptation; SSVEP-based workspace selection; P300-based command confirmation; motor imagery classification for buffer/workspace navigation; neurofeedback training mode; combined multi-modal input (EEG + gaze + hand); comprehensive exwm-bci.el module; all processing local (zero cloud, zero telemetry)

**THIS IS A MAJOR WEEK -- first-class BCI is a defining feature of EXWM-VR's transhuman identity**

**Dependencies:** Week 13 (P300/SSVEP prototypes), Week 12 (gaze), Week 15 (BrainFlow packaging), Week 18 (hand tracking for multi-modal)

| Stage | Task | Agents | Gate |
|-------|------|--------|------|
| 19.1 | **OpenBCI hardware setup and validation.** Document and automate hardware setup: (a) **Cyton board (8-channel):** Connect via USB dongle (FTDI FT231X, VID=0x0403, PID=0x6015) to `/dev/ttyUSB0` (or `/dev/openbci` via udev symlink from Week 15). Board ID = 0 in BrainFlow. 8 EEG channels, 250 Hz sample rate, 24-bit ADC resolution (ADS1299). Recommended electrode placement for 8-channel: Fp1, Fp2, C3, C4, P3, P4, O1, O2 (covers frontal attention, motor cortex, parietal P300, occipital SSVEP). (b) **Cyton+Daisy (16-channel):** Daisy piggyback board adds 8 channels. Board ID = 2 in BrainFlow. Full 10-20 system: Fp1, Fp2, F3, F4, F7, F8, C3, C4, T3, T4, P3, P4, T5, T6, O1, O2. Reference: earlobes (A1/A2) or Cz. Ground: Fpz or AFz. (c) **Electrode cap:** Gold-cup electrodes with Ten20 paste, or Ag/AgCl snap electrodes with saline. Impedance target: < 10 kOhm per channel. Implement `exwm-bci-hardware-check` Emacs command that runs impedance test via BrainFlow `board.config_board("z")` and reports per-channel impedance in a buffer. Color-coded: green (< 5k), yellow (5-10k), red (> 10k). | 2 | GO: BrainFlow connects to Cyton board; 8 channels streaming at 250Hz; impedance check reports < 10k on all channels with properly applied electrodes |
| 19.2 | **BrainFlow daemon architecture.** Implement `exwm-vr-brainflow-daemon.py` -- long-running Python daemon that: (a) Connects to OpenBCI via `BoardShim(board_id, params)` where `params.serial_port = "/dev/openbci"`. (b) Starts streaming: `board.prepare_session(); board.start_stream(45000)` (45000-sample ring buffer = 3 minutes at 250Hz). (c) Reads data in 250ms windows (62.5 samples): `data = board.get_board_data(62)`. (d) Applies preprocessing: bandpass filter 1-50Hz via `DataFilter.perform_bandpass(channel, 250, 1.0, 50.0, 4, FilterTypes.BUTTERWORTH)`, notch filter at 60Hz (US) or 50Hz (EU) via `DataFilter.remove_environmental_noise(channel, 250, NoiseTypes.SIXTY)`. (e) Rejects eye blink artifacts: detect blinks via Fp1/Fp2 amplitude > 100uV, zero out affected 200ms window across all channels. (f) Rejects muscle artifacts: detect EMG via high-frequency power (> 30Hz) exceeding threshold, flag affected windows. (g) Outputs processed data via Unix socket at `/run/user/$UID/exwm-vr-brainflow.sock` using msgpack encoding: `{"timestamp": 1702345678.123, "channels": [[...], [...], ...], "quality": [0.95, 0.92, ...], "artifacts": ["blink_fp1", ...]}`. (h) Socket protocol: compositor connects as client, daemon pushes data frames. | 2 | GO: daemon starts, connects to board, streams preprocessed data to Unix socket; compositor receives frames |
| 19.3 | **Attention/Focus monitoring.** Implement `AttentionMonitor` in compositor (Rust) consuming BrainFlow daemon output. Compute band powers per channel per 2-second window (500 samples): (a) **Alpha power (8-12Hz)** at O1/O2: high alpha = eyes closed/relaxed; low alpha = engaged/attentive (alpha suppression). (b) **Beta power (12-30Hz)** at F3/F4: high beta = active concentration. (c) **Theta power (4-8Hz)** at Fz: high theta = drowsy/mind-wandering. (d) **Theta/Beta ratio** at Fz/F4: high ratio = inattentive; low ratio = focused. (e) Compute **focus score** (0.0 to 1.0): `focus = sigmoid(beta_power / (alpha_power + theta_power) * calibration_factor)`. Calibration: 2-minute session alternating focused (reading code) and relaxed (eyes closed). Compute personalized sigmoid parameters. Emit IPC: `(:bci-attention :focus-score 0.78 :alpha-power 12.3 :beta-power 18.7 :theta-power 5.1 :state :focused :timestamp ...)`. States: `:deep-focus` (> 0.8), `:focused` (0.6-0.8), `:neutral` (0.4-0.6), `:relaxed` (0.2-0.4), `:drowsy` (< 0.2). | 2 | GO: focus score tracks actual attention state with > 70% accuracy in calibrated 2-class test |
| 19.4 | **Attention-adaptive WM behavior.** Map attention states to WM actions in `exwm-bci.el`: (a) `:deep-focus` -> suppress all notifications (`(setq exwm-vr-dnd-mode t)`), hide mode-line non-essential segments, increase gaze dwell threshold to 400ms. (b) `:focused` -> normal operation, notifications shown but not popup. (c) `:neutral` -> normal operation. (d) `:relaxed` -> suggest break if sustained > 5 minutes. (e) `:drowsy` -> urgent alert, increase all input thresholds, auto-save all buffers. `(defcustom exwm-bci-attention-threshold 0.6)`. `(defcustom exwm-bci-attention-dnd-threshold 0.8)`. Hook: `exwm-bci-attention-change-hook` runs with old-state and new-state. | 1 | GO: entering deep focus auto-enables DND; drowsy state triggers alert and auto-save |
| 19.5 | **SSVEP-based workspace selection.** Full implementation building on Week 13 prototype. Compositor renders workspace thumbnail bar (4-8 workspaces) flickering at unique frequencies. Frequencies for 120Hz display: 12Hz, 15Hz, 20Hz, 24Hz, 10Hz, 8Hz, 6Hz, 40Hz. EEG at O1/O2: 3-second sliding window, FFT with Hanning window, extract power at target frequencies, CCA for classification. Accuracy target: > 85% with 3-second window. Emit: `(:bci-ssvep :selected-workspace 3 :frequency 20.0 :snr-db 8.5 :confidence 0.93)`. `(defcustom exwm-bci-ssvep-frequencies '((1 . 12.0) (2 . 15.0) (3 . 20.0) (4 . 24.0)))`. Toggle: `M-x exwm-bci-ssvep-mode`. | 2 | GO: 4-workspace SSVEP selection > 85% accuracy with 3-second window |
| 19.6 | **P300-based confirmation system.** Full implementation building on Week 13 prototype. Oddball paradigm: flash candidates at 200ms SOA, 100ms duration. EEG at Pz: detect positive peak 250-500ms post-stimulus > 5uV. LDA classifier with 3-5 repetition averaging. Use cases: command confirmation, menu selection, P300 speller. Speed: 4-8 selections/minute. `(defcustom exwm-bci-p300-repetitions 5)`. Emit: `(:bci-p300 :selected-target 7 :confidence 0.88 :latency-ms 320 :amplitude-uv 6.8)`. | 2 | GO: P300 achieves > 80% accuracy with 5 repetitions in 6-target paradigm |
| 19.7 | **Motor imagery classification.** Left hand imagery -> mu desynchronization at C4. Right hand imagery -> mu desynchronization at C3. Foot imagery -> mu desynchronization at Cz. Pipeline: 2-second window -> bandpass 8-30Hz -> log-variance of mu band -> CSP feature extraction -> LDA classifier. Calibration: 5 minutes, 20 trials each class. Save model to `~/.config/exwm-vr/mi-classifier.pkl`. Mapping: left MI = `previous-buffer`, right MI = `next-buffer`, foot MI = `ewwm-workspace-cycle`. `(defcustom exwm-bci-motor-imagery-enabled nil)` -- requires calibration. | 2 | GO: 3-class MI classification > 60% accuracy after calibration |
| 19.8 | **Neurofeedback training mode.** `exwm-bci-neurofeedback-mode` -- dedicated Emacs buffer with: (a) Raw EEG waveforms (scrolling, 8/16 channels). (b) Band power bar graphs. (c) Topographic head map. Training games: alpha trainer (relaxation), beta trainer (concentration), MI trainer. Session logging to `~/.local/share/exwm-vr/neurofeedback/`. Long-term accuracy tracking across sessions. | 1 | GO: real-time EEG visualization >= 10fps; alpha trainer responsive |
| 19.9 | **Combined multi-modal input: EEG + Gaze + Hand.** Fusion pipeline: (a) **EEG attention + Gaze dwell = adaptive targeting:** focus > 0.7 reduces dwell to 150ms; focus < 0.4 increases to 400ms. (b) **EEG MI + Gaze = two-factor command:** gaze selects, MI confirms. (c) **EEG SSVEP + Head pose = spatial navigation.** (d) **EEG P300 + Gaze + Pinch = three-factor security.** Compositor multi-modal state machine. Fusion events: `(:multimodal :modalities (:gaze ... :bci ... :hand ...) :fused-action ...)`. | 2 | GO: adaptive dwell threshold works; two-factor MI+gaze command works |
| 19.10 | **exwm-bci.el comprehensive module.** Submodules: `exwm-bci-core.el`, `exwm-bci-attention.el`, `exwm-bci-ssvep.el`, `exwm-bci-p300.el`, `exwm-bci-mi.el`, `exwm-bci-nfb.el`. Core: `(exwm-bci-start)`, `(exwm-bci-stop)`, `(exwm-bci-restart)`, `(exwm-bci-status)`, `(exwm-bci-signal-quality)`, `(exwm-bci-calibrate-attention)`, `(exwm-bci-calibrate-mi)`. Defcustoms: `exwm-bci-board-id` (0/2/-1), `exwm-bci-serial-port`, `exwm-bci-attention-enabled`, `exwm-bci-ssvep-enabled`, `exwm-bci-p300-enabled`, `exwm-bci-mi-enabled`, `exwm-bci-artifact-rejection`, `exwm-bci-notch-frequency` (50/60). Hooks: `exwm-bci-connected-hook`, `exwm-bci-disconnected-hook`, `exwm-bci-attention-change-hook`. | 2 | GO: full lifecycle (start/status/calibrate/stop) works |
| 19.11 | **Fatigue detection from EEG patterns.** Extend Week 13 fatigue monitoring. EEG indicators: theta power increase at Fz, alpha increase at posterior, reduced beta at frontal, increased theta/alpha ratio. Composite fatigue index: `0.3*theta + 0.25*alpha + 0.2*blink_rate + 0.15*beta_decrease + 0.1*ratio`. Alert thresholds: 0.5 (mild), 0.7 (moderate), 0.9 (severe auto-save). Integrate with `exwm-vr-fatigue.el`. | 1 | GO: EEG fatigue index correlates with subjective reports (r > 0.6) |
| 19.12 | **Privacy and data sovereignty.** ALL processing local. BrainFlow daemon: Unix socket only, no TCP. Data files: 0600 permissions. Secure deletion: `shred -u`. Export: CSV, EDF, BrainFlow native. Data inventory: `(exwm-bci-list-stored-data)`. Retention: `(defcustom exwm-bci-data-retention-days 90)`. | 1 | GO: zero TCP sockets; 0600 permissions; shred works |
| 19.13 | **Synthetic data mode.** BrainFlow synthetic board (id=-1). Includes: baseline alpha, injected P300 ERPs, SSVEP responses, blink artifacts. For CI and development. `(exwm-bci-inject-synthetic-event :p300 :latency-ms 300 :amplitude-uv 7.0)`. | 1 | GO: synthetic pipeline produces classifiable events |
| 19.14 | **Integration tests for BCI pipeline.** Synthetic board tests: daemon -> compositor -> attention score, SSVEP classification, P300 detection, MI classification, fatigue alert, calibration roundtrip. Target: >= 15 new ERT tests. | 2 | GO: >= 135 cumulative ERT tests |
| 19.15 | **BCI quick-start guide and electrode placement reference.** Shopping list, electrode placement diagram, impedance procedure, calibration walkthrough, troubleshooting, expected accuracy ranges. Part of Week 20 documentation deliverable. | 1 | GO: covers unboxing to first classification |

**Research (parallel):**
- R19.1: Survey BCI frameworks beyond BrainFlow -- OpenViBE, MNE-Python, LSL. Assess real-time classification capabilities. (1 agent)
- R19.2: Research EEG-based authentication -- brainwave biometrics literature survey. (1 agent)
- R19.3: Benchmark BCI accuracy vs channel count -- test all paradigms with 4, 8, 16 channels. (2 agents)
- R19.4: Dry electrode evaluation -- signal quality and accuracy degradation vs gel electrodes. (1 agent)
- R19.5: Combined EEG+fNIRS for attention detection -- assess dual-modality improvement. (1 agent)

**Completion Metrics:**
- [ ] Cyton 8-channel: connects, streams, preprocesses at 250Hz
- [ ] Cyton+Daisy 16-channel: connects, streams at 125Hz
- [ ] BrainFlow daemon: stable > 1 hour
- [ ] Artifact rejection: blink artifacts removed cleanly
- [ ] Attention monitoring: > 70% 2-class accuracy
- [ ] SSVEP: > 85% 4-class accuracy, 3-second window
- [ ] P300: > 80% accuracy, 6-target, 5 repetitions
- [ ] Motor imagery: > 60% 3-class accuracy
- [ ] Neurofeedback: >= 10fps visualization
- [ ] Multi-modal fusion: adaptive dwell works
- [ ] Privacy: zero network, encrypted at rest
- [ ] Synthetic mode: full pipeline testable
- [ ] >= 135 cumulative ERT tests

**Gate: GO/NOGO/ASK**
- GO if attention monitoring works AND SSVEP or P300 > 75% accuracy
- ASK if MI < 50% (consider dropping for v0.1.0)
- ASK if electrode setup > 15 min (investigate dry electrodes)
- ASK if BrainFlow API breaks (pin version)
- NOGO if Cyton USB unreliable (evaluate alternatives)

**Composability Notes:**
- BCI attention is the "meta-modality" modulating ALL inputs: gaze dwell, wink threshold, haptic intensity
- SSVEP replaces gaze zones (Week 13) for EEG-only users
- P300 replaces wink/pinch (Weeks 13/18) for zero-movement confirmation
- Motor imagery enables hands-free, eyes-free WM control
- EEG fatigue corroborates eye tracker fatigue (Week 13)
- Three-factor security (gaze + P300 + pinch) is highest-assurance confirmation

**Parallelism Opportunities:**
- Stages 19.1/19.2 prerequisite; all paradigms (19.3-19.7) parallelize after
- Stage 19.8 (neurofeedback) independent of paradigm stages
- Stages 19.11/19.12/19.13 independent
- All 6 research agents parallel with build stages

**Integration Points:**
- Week 13: P300/SSVEP prototypes evolved here
- Week 13: fatigue monitoring enhanced with EEG
- Week 14: secure input mode pauses EEG logging
- Week 15: BrainFlow packaging consumed
- Week 18: hand tracking for MI calibration ground truth
- Week 20: BCI in integration tests and benchmarks

---

## Phase 6: Polish & Release (Week 20)

### Week 20: Integration Testing, Documentation, Release

**Goal:** Comprehensive integration test suites across all operating modes; performance benchmark suite with quantitative targets; security audit of all biometric data paths; complete documentation suite (user, VR, eye tracking, BCI, developer, API reference); v0.1.0 release with changelog, binary cache, and community announcement

**Dependencies:** ALL previous weeks

| Stage | Task | Agents | Gate |
|-------|------|--------|------|
| 20.1 | **End-to-end integration test: flat desktop mode.** Compositor + Emacs without VR or biometrics. Verify: workspace switching, window tiling, focus-follows-mouse, XWayland apps, layer-shell panels, IPC round-trip < 1ms. Automated via headless Wayland backend + wtype. 20 flat-mode test cases. Run on NixOS and Rocky Linux x86_64. | 2 | GO: all flat desktop tests pass on both platforms |
| 20.2 | **End-to-end integration test: VR mode.** Compositor + Emacs + Monado headless/simulated. Verify: OpenXR FOCUSED state, 90fps frame submission, head-gaze ray intersection, window grab/move/release, DRM lease lifecycle, stereo rendering. Record 10000-frame timing histogram. | 2 | GO: VR tests pass; frame timing p99 < 11ms |
| 20.3 | **End-to-end integration test: eye tracking mode.** Compositor + Emacs + simulated gaze (mock Pupil Labs ZMQ). Verify: gaze visualization, dwell focus, saccade filtering, wink detection, gaze zones, fatigue monitoring. Replay recorded gaze session. | 2 | GO: > 90% correct gaze interactions |
| 20.4 | **End-to-end integration test: BCI mode.** Compositor + Emacs + BrainFlow synthetic board. Verify: attention score, SSVEP classification, P300 detection, MI classification, fatigue alert, secure input mode EEG pause. | 2 | GO: all BCI paradigms produce correct output |
| 20.5 | **End-to-end integration test: full stack.** ALL systems simultaneously: compositor + Emacs + mock HMD + simulated gaze + synthetic EEG + mock hand tracking. Verify: concurrent modalities, multi-modal fusion, secure input mode pauses ALL streams, no resource leaks. 5-minute session. | 2 | GO: zero crashes; frame timing p99 < 12ms; stable RSS |
| 20.6 | **Performance benchmark suite.** `just benchmark` recipe. Metrics: (a) Frame timing (p50/p95/p99/max). Target: p50 < 5ms, p99 < 11ms. (b) Input latency (keyboard < 5ms, mouse < 5ms, gaze < 30ms excl. dwell, BCI < 500ms). (c) IPC round-trip < 1ms. (d) Memory: < 100MB idle, < 50MB/surface. (e) GPU utilization < 50% on mid-range GPU. Output: JSON + flamegraphs. Archive per commit. | 2 | GO: all targets met on x86_64 reference hardware |
| 20.7 | **Security audit.** Review: (a) Gaze data not logged in secure input mode. (b) EEG daemon no TCP listeners. (c) Hand data ephemeral only. (d) IPC socket permissions 0700. (e) KeePassXC NaCl encryption verified. (f) Credential strings cleared via `clear-string`. (g) Wayland surface isolation enforced. Generate `docs/security-audit-v0.1.0.md`. | 2 | GO: no critical findings; all biometric paths verified |
| 20.8 | **User guide.** `docs/user-guide.md`: system requirements, NixOS install, Rocky install, first boot, configuration reference (all defcustoms), keyboard shortcuts, workspaces, tiling, app integration (Qutebrowser, KeePassXC), theming, troubleshooting FAQ. | 2 | GO: covers zero to functional desktop; reviewed by non-author |
| 20.9 | **VR setup guide.** `docs/vr-guide.md`: supported HMDs, Monado config, DRM lease, WiVRn wireless, scene config (PPU, distance, curvature), head-gaze interaction, performance tuning, troubleshooting. | 1 | GO: covers all supported HMDs |
| 20.10 | **Eye tracking guide.** `docs/eye-tracking-guide.md`: supported trackers, Pupil Capture setup, calibration, gaze focus, wink detection, gaze zones, gaze scrolling, fatigue monitoring, privacy. | 1 | GO: covers setup through advanced config |
| 20.11 | **BCI guide.** `docs/bci-guide.md`: hardware list, electrode placement (10-20 diagram), impedance checking, BrainFlow daemon, attention calibration, SSVEP, P300, MI, neurofeedback, signal troubleshooting, privacy. | 1 | GO: covers hardware to all paradigms |
| 20.12 | **Developer guide.** `docs/developer-guide.md`: architecture, building from source, IPC protocol reference (all message types with examples), writing extensions, adding gestures, adding BCI paradigms, testing, contributing. | 1 | GO: enables new contributor to build and extend |
| 20.13 | **API reference.** Auto-generated from docstrings. All public functions, defcustoms, hooks, IPC message types. Per-module pages. Target: >= 95% public symbols documented. | 1 | GO: auto-generation works; >= 95% coverage |
| 20.14 | **Release process.** Freeze features, merge to main. Full test suite. Benchmark suite. `git-cliff --tag v0.1.0 > CHANGELOG.md`. Tag `v0.1.0`. Build all platforms. Push Cachix. Build RPMs. GitHub Release with binary assets. Verify on clean NixOS and Rocky VMs. | 2 | GO: v0.1.0 tagged; Release published; Cachix populated; RPMs uploaded |
| 20.15 | **Community announcement.** Post to: emacs-devel mailing list, Reddit r/emacs, Hacker News "Show HN", Monado forums, OpenBCI forums. Create GitHub Pages project site. | 1 | GO: >= 3 communities notified |

**Research (parallel):**
- R20.1: Competitive analysis -- compare against wxrd, KWin VR MR, Simula, immersed.io. Document unique differentiators. (1 agent)
- R20.2: UX evaluation -- 3 testers, 1-hour sessions. Measure task completion: keyboard-only vs gaze+wink vs gaze+pinch. (2 agents)
- R20.3: Post-v0.1.0 roadmap draft -- voice control (Vosk), EMG wristband, foveated rendering, multi-user VR, AI assistant integration. (1 agent)

**Completion Metrics:**
- [ ] Flat desktop: 100% test pass
- [ ] VR mode: 100% test pass; frame timing p99 < 11ms
- [ ] Eye tracking: > 90% correct interactions
- [ ] BCI: all paradigms correct with synthetic data
- [ ] Full stack: 5-min session, zero crashes, stable memory
- [ ] Benchmarks: all targets met
- [ ] Security audit: no critical findings
- [ ] User guide: reviewed by non-author
- [ ] VR/eye tracking/BCI/developer guides: complete
- [ ] API reference: >= 95% coverage
- [ ] Release: v0.1.0 published
- [ ] Announcements: >= 3 communities
- [ ] >= 150 cumulative ERT tests
- [ ] End-to-end workflow: boot -> VR -> gaze focus -> wink switch -> Qutebrowser gaze browse -> KeePassXC auto-type -> BCI attention monitoring

**Final Gate: RELEASE/HOLD**
- RELEASE if all test suites pass AND frame timing met AND security audit clean AND docs complete AND >= 1 external tester confirms
- HOLD if critical bugs in VR interaction, security, or data privacy
- HOLD if performance regression from full-stack testing

**Composability Notes:**
- Integration tests validate ALL cross-week composability claims
- Full stack test is the ultimate composability validation
- Benchmark suite becomes the regression baseline for future development

**Parallelism Opportunities:**
- Stages 20.1-20.5 (test suites) can run in parallel on different CI runners
- Stages 20.8-20.13 (documentation) are fully independent of each other
- Stage 20.14 (release) depends on 20.1-20.7 completion
- All 4 research agents parallel with build stages

**Integration Points:**
- ALL previous weeks feed into this week
- This week produces the release artifact that represents the culmination of all 20 weeks

---

## Risk Register (Expanded)

| # | Risk | Likelihood | Impact | Mitigation | Owner | Week |
|---|------|-----------|--------|------------|-------|------|
| R1 | Emacs pgtk cannot run under custom Smithay compositor | Low | Critical | Test in Week 1 R1.2; fallback to XWayland for Emacs client. Emacs pgtk has been tested under weston/sway; custom compositors may expose edge cases in GDK4 Wayland backend. | Compositor team | 1 |
| R2 | Smithay API instability or breaking changes | Medium | High | Pin Smithay to specific git commit in Cargo.toml. Track niri compositor (production Smithay user) for migration patterns. Maintain abstraction layer over Smithay internals. Estimated effort if Smithay breaks: 1-2 weeks to adapt. | Compositor team | 3-20 |
| R3 | VR HMD compatibility across target devices | Medium | High | Support Monado (open-source, wide HMD support) + SteamVR (proprietary fallback). DRM lease is standard Wayland protocol. Test with at least Valve Index + Quest 3 via WiVRn. Somnium VR1/Pimax Crystal are moving targets -- deprioritize. | VR team | 7-9 |
| R4 | Eye tracking accuracy insufficient for gaze focus (> 3 degree error) | Medium | Medium | Increase dwell threshold (200ms -> 400ms), add 5-point calibration UI, increase gaze target size. Per-user calibration in Week 13. Pupil Labs Core typically achieves 0.6-1.0 degree accuracy after calibration. | Eye tracking team | 11-13 |
| R5 | Emacs single-threaded event loop blocks VR frame submission | Medium | High | Architecture prevents this: compositor is separate process communicating via async IPC. Emacs GC pauses do not affect compositor frame timing. Risk is IPC backpressure if Emacs is slow to consume events -- mitigate with bounded event queues and drop-oldest policy. | Architecture | 4-5 |
| R6 | Rocky Linux missing Wayland/Smithay build dependencies | Low | Medium | Bundle in RPM spec or provide Nix-on-Rocky fallback. Rocky 10 includes most Wayland deps in base repos. EPEL covers remainder. Document exact package list. | Packaging team | 15 |
| R7 | RISC-V and s390x no GPU support | Certain | Low | Headless mode only, documented limitation. s390x: terminal Emacs + headless compositor for logical workspace management. RISC-V: aspirational, document build status. | Multi-arch team | 16 |
| R8 | User fatigue from sustained eye tracking interaction | Medium | Medium | Configurable via defcustom; keyboard fallback for ALL eye-driven operations. Fatigue monitoring (Week 13) alerts users proactively. Wink-based interaction limited to 30-minute sessions per study data. | UX team | 13 |
| R9 | OpenBCI signal quality insufficient for reliable BCI | Medium | High | Impedance checking in exwm-bci-hardware-check. Artifact rejection pipeline. Per-user calibration. Minimum viable: attention monitoring (low accuracy acceptable). SSVEP/P300 require < 10k ohm impedance. Dry electrodes may be insufficient -- recommend gel for reliable operation. | BCI team | 19 |
| R10 | Pupil Labs hardware availability or discontinuation | Low | Medium | Support multiple eye tracking backends: OpenXR native (HMD-integrated), Pupil Labs (external), future Tobii (if SDK becomes FOSS-friendly). Abstraction layer in compositor isolates backend choice. Pupil Labs Neon is current product line; Core is discontinued but available used. | Eye tracking team | 11 |
| R11 | Somnium VR1 SDK changes or delayed release | High | Low | Somnium VR1 is aspirational target, not primary. Primary HMDs: Valve Index (mature), Quest 3 via WiVRn (stable). Pimax Crystal SLAM and Beyond 2E similarly deprioritized. Focus on HMDs with known Monado support. | VR team | 9 |
| R12 | BrainFlow API stability across versions | Medium | Medium | Pin BrainFlow version in requirements.txt/Nix derivation. Test with pinned AND latest in CI. BrainFlow maintains reasonable backward compatibility. If breaking change: update daemon, re-test all paradigms. Estimated effort: 2-3 days. | BCI team | 19 |
| R13 | Emacs pgtk regressions in upstream Emacs | Medium | Medium | Pin Emacs version in Nix flake (emacs-overlay allows version pinning). Test with current release and master. Maintain compatibility with Emacs 29.x and 30.x. Report pgtk regressions upstream. | Elisp team | 1-20 |
| R14 | SELinux policy conflicts with compositor DRM/input access | Medium | Medium | Develop type enforcement policy in Week 15. Test in enforcing mode. Use `audit2allow` iteratively. Worst case: provide permissive domain for compositor (not recommended for production). Consult Red Hat SELinux documentation for multimedia/compositor patterns. | Security team | 15 |
| R15 | FIPS 140-3 compliance gaps in crypto operations | Low | Medium | KeePassXC browser protocol uses NaCl (not FIPS-approved). Mitigation: FIPS environments use D-Bus Secret Service instead (no crypto needed, local IPC). Document FIPS-compatible code path. WiVRn DTLS can use FIPS-approved ciphers. | Security team | 15 |
| R16 | Eye tracking fatigue causes blink rate false positives | Medium | Medium | Fatigue monitoring distinguishes elevated blink rate from intentional winks via duration analysis. Wink calibration wizard (Week 13) tunes thresholds per user. Auto-disable wink detection when fatigue index > 0.7. | UX team | 13 |
| R17 | BCI calibration drift between sessions | High | Medium | Motor imagery patterns shift between sessions. Recommend per-session recalibration (5 min). Attention monitoring is more stable (calibration valid for days). SSVEP is stimulus-driven, no calibration drift. P300 has moderate drift. Store calibration timestamp, prompt recalibration if > 24 hours old. | BCI team | 19 |
| R18 | DMA-BUF zero-copy pipeline breaks on specific GPU/driver combinations | Medium | High | DMA-BUF import (surface buffer -> EGL image -> GL texture) is the critical rendering path. Test on AMD radv, Intel anv, NVIDIA GBM. Fallback: CPU-side texture copy (10x slower, breaks VR frame budget). Maintain GPU compatibility matrix (Week 16). | Rendering team | 8 |

---

## Success Metrics (End of 20 Weeks)

| # | Metric | Target | Measurement Method |
|---|--------|--------|--------------------|
| S1 | ERT test count | >= 150 | `just test` output |
| S2 | ERT test pass rate | 100% | CI pipeline |
| S3 | Frame timing (VR) p50 | < 5ms | `just benchmark` |
| S4 | Frame timing (VR) p95 | < 8ms | `just benchmark` |
| S5 | Frame timing (VR) p99 | < 11ms | `just benchmark` |
| S6 | Frame timing (VR) max | < 16ms | `just benchmark` |
| S7 | IPC round-trip latency | < 1ms | `just benchmark` |
| S8 | Keyboard input latency | < 5ms | `just benchmark` |
| S9 | Gaze-to-focus latency (excl. dwell) | < 30ms | `just benchmark` |
| S10 | Gaze-to-focus accuracy | > 90% | Integration test with recorded gaze |
| S11 | Wink detection accuracy (post-calibration) | > 92% | Calibration holdout set |
| S12 | Gaze zone false positive rate | < 2% | 30-minute usage session |
| S13 | BCI attention 2-class accuracy | > 70% | Calibrated offline test |
| S14 | SSVEP 4-class accuracy (3s window) | > 85% | Online classification test |
| S15 | P300 6-target accuracy (5 reps) | > 80% | Online classification test |
| S16 | Motor imagery 3-class accuracy | > 60% | Calibrated offline test |
| S17 | Supported HMDs | >= 2 (Index + Quest 3) | Manual test report |
| S18 | Supported eye trackers | >= 2 (OpenXR + Pupil) | Manual test report |
| S19 | Supported platforms (full) | NixOS x86_64, Rocky x86_64 | First-boot test |
| S20 | Supported platforms (partial) | aarch64 (2D), s390x (headless) | Build + basic test |
| S21 | Daily-driveable apps | Emacs, Qutebrowser, KeePassXC, terminal, Firefox | Manual test |
| S22 | Compositor memory (idle) | < 100MB RSS | `just benchmark` |
| S23 | Compositor memory (per surface) | < 50MB additional | `just benchmark` |
| S24 | First-boot time (NixOS, cached) | < 5 minutes | Timed fresh install |
| S25 | First-boot time (Rocky, RPM) | < 15 minutes | Timed fresh install |
| S26 | Documentation completeness | 5 guides + API reference | Manual review |
| S27 | Public API documentation coverage | >= 95% | Auto-generation script |
| S28 | Security audit | Zero critical findings | Audit report |
| S29 | BrainFlow daemon stability | > 1 hour continuous | Soak test |
| S30 | External tester validation | >= 1 non-author successful test | User report |

---

## Key Technical Decisions (Expanded)

| # | Decision | Rationale | Alternatives Considered | Week |
|---|----------|-----------|------------------------|------|
| D1 | **Smithay over wlroots/Hyprland** | Rust memory safety critical for VR frame loop (no use-after-free in hot path). DRM lease protocol built-in. calloop event loop integrates cleanly with async IPC. niri proves Smithay production-readiness. | wlroots-rs (unstable bindings), Hyprland (C++, less safe), writing from scratch (too much work) | 1 |
| D2 | **Separate compositor process from Emacs** | Emacs single-threaded event loop cannot drive 90fps VR rendering. GC pauses in Emacs would cause dropped frames. Decoupling via IPC means compositor maintains frame timing independently. | Emacs dynamic module (blocked by GIL), Emacs async.el (still single-threaded), Emacs subprocess with shared memory (complex) | 3-4 |
| D3 | **S-expression IPC protocol** | Native to Emacs (`read`/`print` are zero-cost). Fast to parse in Rust via `serde` with `serde-lexpr` crate. Human-readable for debugging (`socat` on socket). Self-describing (no schema needed). | msgpack (faster but opaque), JSON (verbose, Emacs json.el is slower than native read), Protocol Buffers (overkill, schema maintenance) | 4 |
| D4 | **OpenXR via Monado for VR runtime** | Industry standard API. Monado is the only fully open-source OpenXR runtime. Supports eye tracking (`XR_EXT_eye_gaze_interaction`), hand tracking (`XR_EXT_hand_tracking`), DRM lease. | SteamVR (proprietary, Linux support declining), custom VR runtime (enormous effort), Vulkan XR extensions directly (non-standard) | 7 |
| D5 | **Pupil Labs for external eye tracking** | Only FOSS eye tracking hardware+software stack. ZMQ protocol is well-documented and language-agnostic. Core headset available used (~$200). Neon is current commercial product. | Tobii (proprietary SDK, restrictive license), EyeLink (academic pricing, proprietary), webcam-based (insufficient accuracy) | 11 |
| D6 | **Keep X11 EXWM working alongside Wayland** | The lisp/core/ modules remain functional for users not ready for Wayland/VR. Provides migration path. Existing EXWM users can adopt incrementally. | Wayland-only (alienates existing users), X11-only (no VR future), separate project (fragments community) | 2 |
| D7 | **KeePassXC via Secret Service D-Bus as primary, NaCl browser protocol as secondary** | D-Bus Secret Service is standard freedesktop API, secrets.el built into Emacs, works with other consumers (git, ssh-agent). Browser protocol adds encrypted direct access for auto-type and TOTP. | Bitwarden CLI (requires network), pass/password-store (GPG complexity), GNOME Keyring (GNOME dependency) | 14 |
| D8 | **OpenBCI Cyton as primary BCI hardware** | Best channel count in consumer BCI (8/16 channels). Open-source hardware and firmware. BrainFlow provides cross-platform Python API. 24-bit ADC resolution (ADS1299, same as clinical systems). Full 10-20 system coverage with Daisy expansion. | Muse (4 channels, insufficient for MI/SSVEP), Emotiv (proprietary, encrypted data), NeuroSky (1 channel, toy), BrainBit (limited channels) | 19 |
| D9 | **BrainFlow over direct OpenBCI serial protocol** | BrainFlow abstracts hardware-specific serial protocol. Provides built-in signal processing (filters, FFT, CSP, ML models). Supports synthetic board for testing. Multi-language bindings. Active maintenance. | Direct serial (fragile, board-specific), OpenViBE (GUI-focused, not embeddable), MNE-Python (offline analysis, not real-time), LSL (additional abstraction layer) | 19 |
| D10 | **DMA-BUF zero-copy texture pipeline** | Surface buffer -> EGL image -> GL texture without CPU-side copy. Essential for VR frame budget (< 11ms). Standard Linux graphics path. Supported by all Mesa drivers and NVIDIA >= 535. KWin VR MR uses same pattern. | CPU-side copy (10x slower), Vulkan import (more complex, less driver support), shared memory (no GPU acceleration) | 8 |
| D11 | **Per-user calibration for all biometric inputs** | Wink thresholds, gaze accuracy, BCI classifier weights all vary significantly between users. Default thresholds provide degraded-but-functional experience; calibration unlocks full accuracy. | Universal thresholds (too many false positives/negatives), no calibration (poor UX for power features), mandatory calibration (blocks quick start) | 13, 19 |
| D12 | **All biometric processing local, zero cloud** | Privacy-critical: EEG data reveals cognitive state, gaze data reveals visual attention, both are deeply personal. GDPR/privacy-by-design. Users must trust that their brain data stays on their machine. | Cloud classification (lower latency possible with powerful models, but privacy nightmare), hybrid (complex, partial privacy), anonymized telemetry (still a privacy risk) | 19 |
| D13 | **Compositor-level key injection over ydotool for auto-type** | Direct `wl_keyboard` event injection from compositor is fastest, most reliable, and requires no external daemon. Falls back to ydotool if compositor injection unavailable. | ydotool only (requires daemon, separate process), wtype (simpler but less control), xdotool (X11 only), DBus input simulation (non-standard) | 14 |
| D14 | **NixOS as primary platform, Rocky Linux as secondary** | Nix provides reproducible builds, binary caching, and clean dependency management critical for a complex multi-language stack (Rust + Elisp + Python + C). Rocky Linux provides enterprise/RHEL compatibility. | Debian/Ubuntu (larger user base but less reproducible), Arch (rolling release instability), Guix (smaller ecosystem), Fedora (too fast-moving) | 15 |

---

## Composability Matrix

How all input modalities compose with each other. Cells show the interaction pattern.

| | **Gaze** | **Wink** | **Pinch** | **EEG Attention** | **EEG SSVEP** | **EEG P300** | **EEG MI** | **Keyboard** | **Controller** | **Head Pose** |
|---|---|---|---|---|---|---|---|---|---|---|
| **Gaze** | -- | Gaze selects target, wink confirms (buffer switch) | Gaze selects, pinch confirms (Apple Vision Pro "look and tap") | Attention modulates gaze dwell threshold (150-400ms) | Gaze directs to SSVEP stimulus, EEG confirms | Gaze pre-selects region, P300 confirms specific target | Gaze selects surface, MI selects action on it | Gaze zones provide modifier prefix for next keystroke | Gaze coarse-targets, controller fine-adjusts | Gaze for fine targeting, head for coarse orientation |
| **Wink** | (symmetric) | -- | Wink cancels pinch, pinch overrides wink | Wink disabled when attention < 0.3 (drowsy) | Wink exits SSVEP mode | Wink aborts P300 sequence | Not composed (conflict) | Wink replaces modifier key (wink = C-x prefix) | Wink replaces trigger press | Not composed |
| **Pinch** | (symmetric) | (symmetric) | -- | Pinch sensitivity adjusted by attention | Pinch exits SSVEP mode | Pinch can replace P300 for faster confirmation | Not composed (both motor) | Pinch replaces Enter key | Per-finger pinch = different controller buttons | Not composed |
| **EEG Attention** | (symmetric) | (symmetric) | (symmetric) | -- | Attention gates SSVEP (only active when focused) | Attention gates P300 (suppress when drowsy) | Attention correlates with MI accuracy | DND mode suppresses notifications during deep focus | Haptic intensity scales with attention | Not composed |
| **EEG SSVEP** | (symmetric) | (symmetric) | (symmetric) | (symmetric) | -- | SSVEP selects category, P300 selects item within | Not composed (both EEG, interference) | SSVEP for workspace, keyboard for editing | Not composed | Head turns between SSVEP stimuli |
| **EEG P300** | (symmetric) | (symmetric) | (symmetric) | (symmetric) | (symmetric) | -- | Not composed (both EEG) | P300 for confirmation, keyboard for input | Not composed | Not composed |
| **EEG MI** | (symmetric) | (symmetric) | (symmetric) | (symmetric) | (symmetric) | (symmetric) | -- | MI for navigation, keyboard for input | MI replaces thumbstick for buffer switching | Not composed |
| **Keyboard** | (symmetric) | (symmetric) | (symmetric) | (symmetric) | (symmetric) | (symmetric) | (symmetric) | -- | Keyboard for text, controller for spatial | Keyboard primary, head secondary |
| **Controller** | (symmetric) | (symmetric) | (symmetric) | (symmetric) | (symmetric) | (symmetric) | (symmetric) | (symmetric) | -- | Controller aim augments head-gaze ray |
| **Head Pose** | (symmetric) | (symmetric) | (symmetric) | (symmetric) | (symmetric) | (symmetric) | (symmetric) | (symmetric) | (symmetric) | -- |

**Key composability patterns:**
1. **"Look and Tap" (Apple Vision Pro):** Gaze + Pinch (or Gaze + Wink, or Gaze + P300)
2. **"Xray" (KWin VR MR):** Head Pose generates aim ray, gaze refines target, hand/controller confirms
3. **"Brain-Gaze Fusion":** EEG attention modulates gaze sensitivity, creating adaptive interface
4. **"Three-Factor Security":** Gaze + P300 + Pinch for highest-assurance confirmation
5. **"Zero-Movement Interface":** EEG SSVEP + EEG MI + EEG P300 (no physical movement required)

---

## Agent Allocation Summary (Per Week)

| Week | Build Agents | Research Agents | Test Agents | Integration Agents | Total |
|------|-------------|----------------|-------------|-------------------|-------|
| 1 | 6 | 4 | 1 | 0 | 11 |
| 2 | 5 | 4 | 1 | 0 | 10 |
| 3 | 8 | 2 | 1 | 0 | 11 |
| 4 | 6 | 2 | 1 | 0 | 9 |
| 5 | 8 | 2 | 1 | 1 | 12 |
| 6 | 6 | 0 | 1 | 1 | 8 |
| 7 | 8 | 2 | 1 | 1 | 12 |
| 8 | 8 | 2 | 1 | 1 | 12 |
| 9 | 6 | 0 | 1 | 1 | 8 |
| 10 | 9 | 2 | 1 | 1 | 13 |
| 11 | 8 | 2 | 1 | 1 | 12 |
| 12 | 8 | 0 | 2 | 1 | 11 |
| 13 | 12 | 6 | 2 | 1 | 21 |
| 14 | 12 | 4 | 2 | 1 | 19 |
| 15 | 14 | 4 | 2 | 1 | 21 |
| 16 | 13 | 3 | 2 | 1 | 19 |
| 17 | 12 | 4 | 2 | 2 | 20 |
| 18 | 14 | 5 | 2 | 2 | 23 |
| 19 | 17 | 6 | 2 | 2 | 27 |
| 20 | 12 | 4 | 6 | 3 | 25 |
| **Total** | **191** | **58** | **31** | **21** | **301** |

**Notes:**
- Weeks 13-20 have significantly higher agent counts due to expanded scope
- Week 19 (BCI) is the peak week with 27 agents reflecting the complexity of first-class BCI integration
- Test agents appear from Week 1 but increase in later weeks as integration testing demands grow
- Integration agents appear from Week 5 when cross-system testing begins

---

## Dependency Graph

```
Week 1 (Repo Setup)
  |
  v
Week 2 (Codebase Reorg) --------+
  |                              |
  v                              v
Week 3 (Smithay Compositor) --> Week 15 (NixOS/RPM) --> Week 16 (Multi-Arch)
  |                              ^
  v                              |
Week 4 (IPC Protocol) ----------+
  |
  v
Week 5 (ewwm.el) --> Week 6 (XWayland)
  |                    |
  v                    v
Week 7 (OpenXR) --> Week 8 (VR Rendering) --> Week 9 (DRM Lease) --> Week 10 (VR Interaction)
  |                    |                                                |
  |                    +-- DMA-BUF zero-copy pipeline                   |
  v                                                                     v
Week 11 (Eye Tracking HW) --> Week 12 (Gaze Focus) --> Week 13 (Blink/Wink/Zones)
  |                            |                         |
  |                            |                         +--> Week 14 (KeePassXC)
  |                            |                         |
  |                            +-------------------------+--> Week 17 (Qutebrowser)
  |                                                      |
  +------------------------------------------------------+--> Week 18 (Hand Tracking)
                                                         |
                                                         +--> Week 19 (BCI Full Harness)
                                                                |
                                                                v
                                                         Week 20 (Integration/Release)
```

**Critical path:** 1 -> 2 -> 3 -> 4 -> 5 -> 7 -> 8 -> 10 -> 11 -> 12 -> 13 -> 19 -> 20

**Parallel tracks (can run concurrently once prerequisites met):**
- VR track: 7 -> 8 -> 9 -> 10 (after Week 3)
- Eye tracking track: 11 -> 12 -> 13 (after Week 3/4)
- Platform track: 15 -> 16 (after Week 3/4)
- App integration track: 14, 17 (after Week 12/13)
- Hand tracking: 18 (after Week 7/10)
- BCI track: 19 (after Week 13/15)

---

## HMD Compatibility Matrix

| HMD | Display Output | Eye Tracking | Hand Tracking | DRM Lease | Monado Support | Status |
|-----|---------------|-------------|---------------|-----------|----------------|--------|
| **Valve Index** | DisplayPort 1.2 | No (external Pupil Labs Addon) | No (controllers only) | Yes (standard) | Full | **Primary target** -- mature hardware, excellent Monado support, proven DRM lease |
| **Quest 3** (via WiVRn) | Wireless streaming | Yes (XR_EXT_eye_gaze_interaction via WiVRn relay) | Yes (XR_EXT_hand_tracking) | N/A (wireless) | Via WiVRn bridge | **Primary target** -- wireless freedom, integrated eye+hand tracking, but adds streaming latency (~20ms) |
| **HP Reverb G2** | DisplayPort 1.3 | No | No (WMR controllers) | Yes (standard) | Partial (Monado WMR driver) | **Supported** -- good display resolution (2160x2160 per eye), but no eye/hand tracking, WMR driver less mature |
| **Somnium VR1** | DisplayPort 2.0 | Planned (Tobii or custom) | Unknown | Unknown (new hardware) | Unknown | **Aspirational** -- open-source friendly ethos, but SDK/drivers not yet available. Monitor development. |
| **Pimax Crystal SLAM** | DisplayPort 1.4 | Yes (Tobii, proprietary SDK) | No | Unknown | Partial (Pimax OpenXR layer) | **Aspirational** -- high resolution, but Tobii eye tracking requires proprietary SDK that may not be Linux-compatible |
| **Beyond 2E** | DisplayPort 1.4 | Possible | Unknown | Unknown | Unknown | **Aspirational** -- insufficient information, monitor development. Very low priority. |
| **Bigscreen Beyond** | DisplayPort 1.4 | No | No (SteamVR controllers) | Possible | Unknown | **Not targeted** -- small FOV, no biometric inputs, SteamVR dependency |
| **Simulated/Headless** | None (in-memory) | Synthetic data | Synthetic data | N/A | Monado headless | **Development/CI** -- used for all automated testing, no hardware required |

**Notes:**
- "Display Output" refers to the physical connection type; DRM lease operates over this connection
- Quest 3 via WiVRn adds ~20ms streaming latency, acceptable for desktop work but not competitive gaming
- Eye tracking quality varies significantly: Quest 3 (~5 degree accuracy) vs Pupil Labs Core (~0.6 degree accuracy)
- Hand tracking on Quest 3 is optical (from HMD cameras); Valve Index requires external Ultraleap sensor
- All HMDs fall back to head-gaze (Xray pattern) when eye tracking unavailable
